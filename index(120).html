﻿﻿<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>画布工具 v8.3 (排序功能版)</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <!-- Cache buster: 2024-12-19-21:35 -->
    <style>
        /* Accessibility - Visually hidden labels */
        .visually-hidden {
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            padding: 0 !important;
            margin: -1px !important;
            overflow: hidden !important;
            clip: rect(0, 0, 0, 0) !important;
            white-space: nowrap !important;
            border: 0 !important;
        }
        

        /* CSS Variables for Theme Colors */
        :root {
            --menu-bar-bg: #FFFFFF;
            --node-bg: #C0CCD8;
            --node-text: #FFFFFF;
            --group-color: #CFCFCF;
            --canvas-bg: #F3F4F6;
            --grid-color: #E5E7EB;
            --input-bg: #F9FAFB;
            --btn-active: #F5F5F5;
            --btn-inactive: #D2D5DB;
            --toggle-on: #8BC34A;
            --toggle-off: #ABABAB;
            --text-color: #111827;
            --clear-btn: #DB5247;
            --node-border: #D2D5DB;
            --context-menu-bg: #FFFFFF;
        }

        /* General Body and Resets */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
            background-color: var(--canvas-bg);
            color: var(--text-color);
            margin: 0;
        }

        /* Toast Animation */
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                    opacity: 0;
               }
                to {
                  transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        /* Canvas & Text Editor */
        #canvas {
            display: block;
            background-color: var(--canvas-bg);
            cursor: default;
        }
        #text-editor {
            position: absolute;
            display: none;
            padding: 10px; /* 与节点PADDING一致 */
            border: none; /* 去掉边框 */
            background-color: transparent; /* 透明背景，让节点背景显示 */
            color: inherit; /* 继承节点文字颜色 */
            font: bold 16px sans-serif; /* 与节点字体完全一致 */
            z-index: 10; /* 调整层级，避免覆盖其他面板 */
            box-shadow: none; /* 移除阴影，保持简洁 */
            border-radius: 8px; /* 与节点圆角一致 */
            resize: none;
            line-height: 1.2; /* 与节点行高一致 */
            text-align: center; /* 与节点文字居中对齐 */
            outline: none; /* 移除焦点轮廓 */
            box-sizing: border-box; /* 确保尺寸计算一致 */
            white-space: pre-wrap; /* 保持换行符 */
            word-wrap: break-word; /* 自动换行 */
            overflow: hidden; /* 隐藏溢出内容 */
            margin: 0; /* 确保没有默认margin */
        }
        
        /* Toolbar */
        #toolbar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 0.25rem 0.5rem;
            background-color: var(--menu-bar-bg);
            /*backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);*/
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            z-index: 10;
            display: flex;
            align-items: center;
            flex-wrap: nowrap;
            gap: 0.5rem;
            overflow-x: auto;
            overflow-y: hidden;
        }

        /* 工具栏滚动条样式 */
        #toolbar::-webkit-scrollbar {
            height: 6px;
        }

        #toolbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
        }

        #toolbar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        #toolbar::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        /* Firefox滚动条样式 */
        #toolbar {
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0.1);
        }

        /* 工具栏子元素防换行样式 */
        #toolbar > * {
            flex-shrink: 0;
            white-space: nowrap;
        }

        #toolbar .control-btn,
        #toolbar .control-label,
        #toolbar input,
        #toolbar button {
            flex-shrink: 0;
            white-space: nowrap;
        }

        /* 强制工具栏单行显示 */
        #toolbar {
            flex-wrap: nowrap !important;
        }

        #toolbar > *,
        #toolbar .control-group,
        #toolbar .custom-color-picker-wrapper {
            flex-shrink: 0 !important;
        }

        .toolbar-section {
            display: contents;
        }
        
        .toolbar-section.divider {
            display: contents;
        }
        
        .toolbar-divider {
            width: 1px;
            height: 20px;
            background-color: #475569;
            margin: 0 0.25rem;
            flex-shrink: 0;
        }
        
        #clear-section {
            display: contents;
        }

        /* Form Controls & Buttons */
        .control-group {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            flex-shrink: 0;
            white-space: nowrap;
        }
        
        .control-btn {
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            transition: all 0.2s;
            border: none;
            font-size: 0.875rem;
            cursor: pointer;
            background-color: var(--btn-inactive);
            color: var(--text-color);
        }
        .control-btn:hover {
            filter: brightness(1.2);
        }
        .control-btn:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
            box-shadow: 0 0 0 2px #475569, 0 0 0 4px #0ea5e9;
        }
        .control-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            filter: brightness(1);
        }

        .control-label {
             display: block;
             font-size: 0.875rem;
             font-weight: 500;
             white-space: nowrap;
        }

        /* Focus Button Styles */
        #focus-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            background-color: #4879db !important;
            color: white !important;
            padding: 6px 8px;
            border-radius: 4px;
            border: none;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(72, 121, 219, 0.3);
            min-width: 40px;
            text-align: center;
        }

        #focus-btn:hover {
            background-color: #3d6bc7 !important;
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(72, 121, 219, 0.4);
        }

        #focus-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 4px rgba(72, 121, 219, 0.3);
        }

        /* Responsive adjustments for mobile */
        @media (max-width: 768px) {
            #focus-btn {
                bottom: 15px;
                right: 15px;
                padding: 5px 7px;
                font-size: 11px;
                min-width: 35px;
            }
        }

        @media (max-width: 480px) {
            #focus-btn {
                bottom: 12px;
                right: 12px;
                padding: 4px 6px;
                font-size: 10px;
                min-width: 30px;
            }
        }

        .shortcut-input, #canvas-name-input {
            border: 1px solid;
            border-radius: 0.375rem;
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
            outline: none;
            transition: box-shadow 0.2s;
        }

        #canvas-name-input {
            width: 90px;
        }

        .shortcut-input {
             width: 69px; 
             padding: 2px 6px; 
             font-size: 12px;
        }

        .shortcut-input:focus, #canvas-name-input:focus {
            box-shadow: 0 0 0 1px #0ea5e9;
        }
        
        .toggle-btn:hover {
            filter: brightness(1.1);
        }

        #search-container {
            position: relative;
            display: flex;
            align-items: center;
            width: 80px;
            overflow: visible;
            /* 确保容器不阻止交互 */
            pointer-events: auto;
            z-index: 50;
        }
        #search-box {
            padding-right: 18px;
            text-align: left;
            border: 1px solid #4b5563;
            border-radius: 4px;
            width: 100%;
            box-sizing: border-box;
            /* 强制确保输入框可交互 */
            pointer-events: auto !important;
            z-index: 100 !important;
            position: relative !important;
            /* 确保输入框可以获得焦点 */
            outline: none;
            background: var(--bg-color);
            color: var(--text-color);
            /* 确保文字可以被选择 */
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }
        #search-clear-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.1) !important;
            border: none !important;
            color: var(--text-color);
            cursor: pointer;
            font-size: 1.2rem !important;
            padding: 0 !important;
            margin: 0 !important;
            display: none;
            line-height: 1 !important;
            opacity: 0.7;
            transition: opacity 0.2s ease;
            width: 15px !important;
            height: 15px !important;
            min-width: 15px !important;
            min-height: 15px !important;
            max-width: 15px !important;
            max-height: 15px !important;
            border-radius: 2.5px !important;
            /* PC端垂直对齐微调 */
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            z-index: 101;
            /* 强制重置浏览器默认按钮样式 */
            -webkit-appearance: none !important;
            -moz-appearance: none !important;
            appearance: none !important;
            box-sizing: border-box !important;
            /* 确保清除按钮不阻止输入框点击 */
            pointer-events: auto;
            /* 移动端触摸目标重置 */
            -webkit-tap-highlight-color: transparent !important;
            touch-action: manipulation !important;
        }
        
        #search-clear-btn:hover {
            opacity: 1;
        }
        
        #search-scope-toggle {
            transition: all 0.2s ease;
            min-width: 36px;
        }
        
        #search-scope-toggle:hover {
            background-color: #374151;
        }
        
        /* 全局搜索状态的特殊样式 */
        #search-scope-toggle.global-mode {
            background-color: #3b82f6;
            color: white;
        }


        
        #search-scope-toggle.global-mode:hover {
            background-color: #2563eb;
        }
        
        /* Color Picker */
        input[type="color"] {
            width: 24px; height: 24px; border: 1px solid #4b5563;
            border-radius: 4px; background: transparent; cursor: pointer; padding: 0;
            z-index: 1; position: relative;
        }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 2px; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-moz-color-swatch { border: none; border-radius: 2px; }
        input[type="color"]::-moz-focus-inner { border: 0; padding: 0; }
        
        .color-preset-panel {
            position: absolute; top: 100%; left: 0; margin-top: 8px;
            background: #2d3748; border: 1px solid #4a5568; border-radius: 6px;
            padding: 8px; display: none; grid-template-columns: repeat(9, 1fr);
            gap: 3px; z-index: 9999; box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        .color-preset {
            width: 20px; height: 20px; border: 1px solid #4a5568;
            border-radius: 3px; cursor: pointer; transition: transform 0.1s;
        }
        .color-preset:hover { transform: scale(1.1); }
        .color-picker-wrapper { position: relative; display: inline-block; }
        .color-picker-wrapper.active .color-preset-panel { display: grid; }

        /* Custom Color Picker Styles */
        .custom-color-picker-wrapper {
            position: relative;
            display: inline-block;
            flex-shrink: 0;
            white-space: nowrap;
        }
        
        .color-display {
            width: 24px;
            height: 24px;
            border: 1px solid var(--node-border);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            z-index: 1;
        }
        
        .custom-color-picker-panel {
            position: fixed;
            top: 60px;
            left: 20px;
            background: var(--context-menu-bg);
            border: 1px solid var(--node-border);
            border-radius: 8px;
            padding: 16px;
            display: none;
            z-index: 10001;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
            width: 280px;
            user-select: none;
        }
        
        .custom-color-picker-panel.active {
            display: block;
        }
        
        .color-picker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .color-picker-title {
            color: var(--text-color);
            font-size: 14px;
            font-weight: 600;
        }
        
        .color-mode-tabs {
            display: flex;
            gap: 4px;
        }
        
        .color-mode-tab {
            padding: 4px 8px;
            background: var(--btn-inactive);
            color: var(--text-color);
            border: none;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .color-mode-tab.active {
            background: var(--btn-active);
        }
        
        .color-picker-main {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .color-area {
            width: 200px;
            height: 120px;
            position: relative;
            border-radius: 6px;
            overflow: hidden;
            cursor: crosshair;
        }
        
        .color-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to right, #fff, transparent);
            z-index: 1;
        }
        
        .color-area::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to top, #000, transparent);
            z-index: 2;
        }
        
        .color-area-cursor {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid #fff;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 0 1px rgba(0,0,0,0.3);
            z-index: 3;
        }
        
        .hue-slider-container {
            width: 20px;
            height: 120px;
            position: relative;
        }
        
        .hue-slider {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            cursor: pointer;
            background: linear-gradient(to bottom,
                #ff0000 0%,
                #ffff00 16.66%,
                #00ff00 33.33%,
                #00ffff 50%,
                #0000ff 66.66%,
                #ff00ff 83.33%,
                #ff0000 100%
            );
        }
        
        .hue-slider-cursor {
            position: absolute;
            left: -2px;
            width: 24px;
            height: 4px;
            background: #fff;
            border: 1px solid rgba(0,0,0,0.3);
            border-radius: 2px;
            pointer-events: none;
            transform: translateY(-50%);
        }
        
        .color-inputs {
            margin-bottom: 12px;
        }
        
        .color-input-group {
            display: flex;
            flex-direction: row;
            gap: 6px;
            align-items: end;
            height: 100%;
            min-height: 40px;
        }
        
        .color-input-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            flex: 1;
        }



        .color-inputs-row {
            display: flex;
            align-items: end;
            gap: 8px;
            min-height: 40px;
        }


        
        .color-input-label {
            font-size: 10px;
            color: var(--text-color);
            opacity: 0.7;
            text-transform: uppercase;
            line-height: 1.2;
            margin-bottom: 2px;
        }
        
        .color-input {
            padding: 4px 4px;
            background: var(--input-bg);
            border: 1px solid var(--btn-inactive);
            border-radius: 4px;
            color: var(--text-color);
            font-size: 12px;
            text-align: center;
            width: 50px;
        }
        
        .color-input:focus {
            outline: none;
            border-color: var(--btn-active);
        }
        
        .hex-input-group {
            display: flex;
            flex-direction: row;
            gap: 6px;
            align-items: end;
            height: 100%;
            min-height: 40px;
        }
        
        .hex-input-group .color-input-label {
            font-size: 10px;
            color: var(--text-color);
            opacity: 0.7;
            text-transform: uppercase;
            line-height: 1.2;
            margin-bottom: 2px;
        }
        
        .hex-input {
            width: 162px;
            padding: 4px 4px;
            background: var(--input-bg);
            border: 1px solid var(--btn-inactive);
            border-radius: 4px;
            color: var(--text-color);
            font-size: 12px;
            text-align: center;
            font-family: monospace;
        }
        
        .color-presets {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 4px;
            margin-bottom: 12px;
        }
        
        .color-preset-item {
            width: 24px;
            height: 24px;
            border: 1px solid #4a5568;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        
        .color-preset-item:hover {
            transform: scale(1.1);
        }
        
        .color-picker-tools {
            display: flex;
            gap: 8px;
            justify-content: space-between;
            align-items: end;
            height: 100%;
            min-height: 40px;
        }
        
        .eyedropper-btn {
            padding: 0;
            background: var(--btn-inactive);
            color: var(--text-color);
            border: 1px solid var(--btn-inactive);
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            width: 28px;
            height: 26px;
            box-sizing: border-box;
        }
        
        .eyedropper-btn:hover {
            background: var(--btn-active);
        }
        
        .color-preview {
            width: 28px;
            height: 26px;
            border: 1px solid #4a5568;
            border-radius: 4px;
            position: relative;
            box-sizing: border-box;
        }
        
        .color-preview-current {
            width: 100%;
            height: 100%;
            border-radius: 3px;
        }


        
        /* New Draggable History Modal Styles */
        .new-history-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 100;
            pointer-events: none;
        }
        
        .new-history-modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--menu-bar-bg);
            border: 1px solid var(--btn-active, #334155);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            min-width: 333px;
            max-width: 400px;
            max-height: 70vh;
            pointer-events: auto;
            user-select: none;
            overflow: hidden;
            opacity: 0.65;
        }
        
        .new-history-modal-header {
background: var(--menu-bar-bg);
            border-bottom: 1px solid var(--btn-active, #334155);
            padding: 12px 16px;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .new-history-modal-header:active {
            cursor: grabbing;
        }
        
        #new-history-title {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-color, #E0E0E0);
        }
        
        .new-history-close-btn {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--text-color, #E0E0E0);
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .new-history-close-btn:hover {
            background: var(--btn-active, #334155);
        }
        
        .new-history-modal-body {
            padding: 16px;
            max-height: calc(70vh - 60px);
            overflow-y: auto;
        }
        
        .new-history-list {
            display: flex;
            flex-direction: column;
            /* 移除gap以消除历史记录项之间的缝隙 */
        }
        
        .new-history-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            background: transparent;
            color: var(--text-color, #E0E0E0);
            border: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            min-height: 32px;
            line-height: 1.3;
            position: relative;
        }
        
        .new-history-item:hover {
            background: var(--btn-active, #334155);
        }
        
        .new-history-item.current {
            background: var(--btn-active, #334155);
            font-weight: 600;
        }
        
        .new-history-item.selected {
            background: var(--btn-active, #334155);
            box-shadow: 0 0 0 2px var(--text-color, #E0E0E0);
        }
        
        .new-history-item-number {
            min-width: 30px;
            margin-right: 8px;
            font-weight: bold;
            color: var(--text-color, #E0E0E0);
            opacity: 0.7;
        }
        
        .new-history-item-text {
            flex: 1;
            text-align: left;
        }
        
        /* Node Set Navigation Breadcrumb */
        .nodeset-navigation {
            position: fixed;
            top: 60px; /* 菜单栏高度约为60px，确保导航栏显示在菜单栏下方 */
            left: 0;
            width: 100%;
            background: transparent; /* 移除背景色，设置为透明 */
            border-bottom: 1px solid var(--btn-active);
            padding: 8px 16px;
            font-size: 14px;
            color: var(--text-color);
            z-index: 9; /* 比菜单栏的z-index: 10稍低 */
            box-shadow: none; /* 移除阴影效果 */
        }
        
        .breadcrumb-container {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .breadcrumb-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            background: transparent;
            color: var(--text-color);
        }
        
        .breadcrumb-item:hover {
            background: transparent;
        }
        
        .breadcrumb-item.current {
            background: transparent;
            font-weight: 600;
        }
        
        .breadcrumb-icon {
            font-size: 12px;
            display: none;
        }
        
        .breadcrumb-text {
            font-size: 12px;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .breadcrumb-separator {
            color: var(--text-color);
            opacity: 0.6;
            font-size: 12px;
        }

        /* Context Menu & Sub-menu */
        .context-menu {
            position: fixed; background-color: #1e293b; border: 1px solid #475569;
            border-radius: 6px; padding: 4px 0;
            z-index: 1000; display: none; min-width: 150px;
        }
        .context-menu-item {
            padding: 8px 16px; cursor: pointer; transition: background-color 0.2s;
            font-size: 14px; user-select: none;
            position: relative; /* For submenu indicator */
        }
        .context-menu-item:hover { background-color: #334155; }
        .submenu .context-menu-item:hover { background-color: #334155; }
        .context-menu-divider { height: 1px; background-color: #475569; margin: 4px 0; }
        .context-menu-item.has-submenu::after {
            content: '▶';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #94a3b8;
        }
        .context-menu .submenu {
            display: none;
            position: absolute;
            left: 100%;
            top: -5px; /* Adjust vertical alignment */
            z-index: 1001; /* Ensure submenu appears above other elements */
        }
        .context-menu-item.has-submenu:hover > .submenu {
            display: block;
        }
        .context-menu-item.has-submenu:hover,
        .context-menu-item.has-submenu:focus-within {
            background-color: #334155;
        }
        .context-menu-item.has-submenu:hover > .submenu,
        .context-menu-item.has-submenu:focus-within > .submenu {
            display: block;
        }
        
        /* Confirmation & Help Modals */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        .modal-content {
            background-color: #1f2937;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 32rem; /* Increased width for help */
            color: #e2e8f0;
        }
        .help-modal-content {
            background-color: var(--menu-bar-bg) !important;
            color: var(--text-color) !important;
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }
        .modal-message {
            margin-bottom: 1rem;
        }
        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
        }
        #help-modal h2 {
            margin-top: 0;
            color: var(--text-color);
        }
        #help-modal ul {
            padding-left: 20px;
            margin-bottom: 1.5rem;
        }
        #help-modal li {
            margin-bottom: 0.5rem;
        }
        #help-modal code {
            background-color: var(--btn-inactive);
            color: var(--text-color);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }

        
        /* Custom Confirm Modal Styles */
        #custom-confirm-cancel-btn:hover {
            background-color: #374151 !important;
            border-color: #9ca3af !important;
        }
        #custom-confirm-ok-btn:hover {
            background-color: #2563eb !important;
        }
        #custom-confirm-modal-close-btn:hover {
            color: #dc2626 !important;
        }
        #help-modal-close-btn {
            position: absolute;
            top: 8px;
            right: 12px;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #94a3b8;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        /* Shortcut Configuration Modal */
        .shortcut-config-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }
        
        /* Three column layout for larger screens */
        @media (min-width: 800px) {
            .shortcut-config-content {
                grid-template-columns: 1fr 1fr 1fr;
                gap: 4px;
            }
            #shortcut-modal {
                max-width: 1260px !important;
            }
        }
        .shortcut-config-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 8px;
            background-color: var(--input-bg);
            border-radius: 4px;
            border: 1px solid var(--node-border);
        }
        .shortcut-config-item:hover {
            background-color: var(--btn-inactive);
        }
        .shortcut-function-name {
            font-weight: 500;
            color: var(--text-color);
            flex: 1;
            margin-right: 11px;
            font-size: 17px;
            display: flex;
            align-items: center;
        }
        .shortcut-inputs {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .shortcut-input {
            width: 60px;
            padding: 6px 8px;
            background-color: #1f2937;
            border: 1px solid #6b7280;
            border-radius: 4px;
            color: #f3f4f6;
            text-align: center;
            font-size: 12px;
            text-transform: uppercase;
        }
        .shortcut-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        .shortcut-plus {
            color: #9ca3af;
            font-weight: bold;
            user-select: none;
        }
        
        /* New Shortcut Input Design */
        .shortcut-inputs-new {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }
        .modifier-switches {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .modifier-switch {
            display: flex;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            padding: 1px 4px;
            border-radius: 3px;
            transition: all 0.2s ease;
        }
        .modifier-switch:hover {
            background-color: rgba(59, 130, 246, 0.1);
        }
        .switch-label {
            font-size: 13px;
            color: #9ca3af;
            font-weight: 500;
            min-width: 34px;
        }
        .modifier-switch.active .switch-label {
            color: #10b981;
        }
        .switch-toggle {
            width: 28px;
            height: 14px;
            background-color: #374151;
            border-radius: 7px;
            position: relative;
            transition: background-color 0.2s ease;
            border: 1px solid #4b5563;
        }
        .modifier-switch.active .switch-toggle {
            background-color: #10b981;
            border-color: #10b981;
        }
        .switch-slider {
            width: 8px;
            height: 8px;
            background-color: #f3f4f6;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: transform 0.2s ease;
        }
        .modifier-switch.active .switch-slider {
            transform: translateX(14px);
        }
        .main-key-input {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .key-label {
            font-size: 13px;
            color: #9ca3af;
            font-weight: 500;
        }
        .shortcut-main-input {
            width: 70px;
            padding: 4px 6px;
            background-color: var(--input-bg);
            border: 1px solid var(--node-border);
            border-radius: 3px;
            color: var(--text-color);
            text-align: center;
            font-size: 14px;
            text-transform: lowercase;
        }
        .shortcut-main-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.2);
        }
        
        #shortcut-modal-close-btn:hover {
            color: #dc2626;
        }
        
        /* Responsive design for shortcut configuration */
        @media (max-width: 600px) {
            .shortcut-config-content {
                grid-template-columns: 1fr;
            }
            #shortcut-modal {
                max-width: 95vw !important;
                padding: 11px !important;
            }
            .shortcut-function-name {
                font-size: 15px;
            }
            .shortcut-inputs-new {
                gap: 4px;
            }
            .modifier-switches {
                gap: 4px;
            }
            .switch-label {
                font-size: 11px;
                min-width: 28px;
            }
            .shortcut-main-input {
                width: 63px;
                font-size: 13px;
            }
        }
        
        /* Theme Switcher Dropdown */
        .dropdown-container {
            position: relative;
        }
        .dropdown-menu {
            display: none;
            position: fixed;
            top: 60px;
            right: 20px;
            background-color: var(--btn-inactive);
            border: 1px solid var(--btn-inactive);
            border-radius: 6px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 10001;
            min-width: 150px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        .dropdown-menu.show {
            display: block;
        }
        .theme-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
            color: var(--text-color) !important; /* 使用主题文字颜色 */
        }
        .theme-item:hover {
            background-color: var(--btn-active);
        }
        .theme-item.highlighted {
            background-color: var(--btn-active);
        }
        .theme-category {
            padding: 8px 16px;
            font-weight: bold;
            font-size: 12px;
            border-top: 1px solid var(--btn-active);
            background-color: var(--btn-inactive);
        }
        .theme-category:first-child {
            border-top: none;
        }
        
        /* Canvas Info Display */
        .canvas-info {
            position: fixed;
            bottom: 10px;
            left: 10px;
            padding: 8px 12px;
            font-size: 12px;
            color: #e2e8f0;
            z-index: 1000;
            pointer-events: none;
            user-select: none;
            background: transparent;
        }
        
        .info-line {
            margin: 2px 0;
            white-space: nowrap;
        }
        .gradient-text {
        background: linear-gradient(to right, #38bdf8, #818cf8);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        }
        /* 同时，为帮助弹窗添加滚动条样式 */
        #help-modal::-webkit-scrollbar { width: 8px; }
        #help-modal::-webkit-scrollbar-track { background: var(--menu-bar-bg); }
#help-modal::-webkit-scrollbar-thumb { background-color: var(--btn-inactive); border-radius: 10px; border: 2px solid var(--menu-bar-bg); }
        
        /* 移动设备响应式样式 */
        @media (max-width: 768px) {
            /* 防止页面滚动和拖拽 */
            body {
                overflow: visible;
                position: fixed;
                width: 100%;
                height: 100%;
            }
            
            /* 工具栏优化 */
            #toolbar {
                padding: 0.375rem; /* 减少到75% (0.5rem * 0.75) */
                flex-wrap: nowrap; /* 改为不换行，保持单行布局 */
                gap: 0.25rem;
                min-height: 45px; /* 减少到75% (60px * 0.75) */
                overflow-x: auto; /* 支持水平滚动 */
                overflow-y: visible;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none; /* 隐藏滚动条 */
                -ms-overflow-style: none; /* 隐藏滚动条 */
            }
            
            #toolbar::-webkit-scrollbar {
                display: none;
            }
            
            .toolbar-section {
                flex-shrink: 0;
                gap: 0.25rem;
            }
            
            .control-btn {
                min-height: 18px; /* 减少到75% (24px * 0.75) */
                padding: 0.195rem 0.3rem; /* 高度和宽度都减少到75% (0.26rem * 0.75, 0.4rem * 0.75) */
                font-size: 0.8rem;
                white-space: nowrap;
                min-width: 24px; /* 减少到75% (32px * 0.75) */
                touch-action: manipulation;
            }
            
            /* 保持主题预设按钮和搜索方向按钮的原始宽度 */
            #theme-switcher-btn {
                min-width: 32px; /* 保持原始宽度 */
                padding: 0.195rem 0.4rem; /* 保持原始宽度的padding */
            }
            
            /* 搜索导航按钮保持紧凑但高度调整 */
            #search-prev-btn,
            #search-next-btn {
                min-width: 24px; /* 保持紧凑宽度 */
                padding: 0.195rem 0.25rem; /* 高度调整到75%，保持紧凑宽度 */
            }
            
            #canvas-name-input {
                width: 80px;
                min-height: 44px;
                font-size: 0.8rem;
            }
            
            /* 平板端面板优化 */
            .custom-color-picker-panel {
                z-index: 10000;
            }
            
            .dropdown-menu {
                z-index: 10001;
            }
            
            /* 左下角信息显示优化 */
            .canvas-info {
                position: fixed;
                bottom: 10px;
                left: 10px;
                right: auto;
                background: transparent;
                padding: 8px 12px;
                font-size: 11px;
                z-index: 1000;
                max-width: calc(100vw - 20px);
                box-sizing: border-box;
            }
            
            .info-line {
                margin: 1px 0;
                font-size: 10px;
                line-height: 1.2;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            
            /* 上下文菜单优化 */
            .context-menu {
                min-width: 120px; /* 进一步减少最小宽度，与手机端一致 */
                font-size: 12px; /* 减小字体大小，与手机端一致 */
                max-width: 80vw; /* 更小的最大宽度，与手机端一致 */
                border-radius: 8px; /* 增加圆角 */
                padding: 1px 0; /* 进一步减少内边距，与手机端一致 */
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); /* 增强阴影效果 */
                max-height: 70vh; /* 限制最大高度 */
                overflow-y: auto; /* 添加垂直滚动 */
                -webkit-overflow-scrolling: touch; /* 平滑滚动 */
            }
            
            .context-menu-item {
                padding: 1px 8px !important; /* 进一步减少内边距，与手机端一致 */
                min-height: 24px !important; /* 进一步减少最小高度，与手机端一致 */
                touch-action: manipulation;
                line-height: 1 !important; /* 更紧凑的行高，与手机端一致 */
                font-weight: 400; /* 调整字重 */
                display: flex; /* 使用flex布局优化垂直居中 */
                align-items: center; /* 垂直居中对齐 */
                font-size: 12px !important; /* 字体大小与手机端一致 */
                white-space: nowrap; /* 防止文字换行 */
            }
            
            /* 子菜单优化 */
            .context-menu .submenu {
                min-width: 100px; /* 子菜单更紧凑，与手机端一致 */
                font-size: 12px; /* 子菜单字体与主菜单一致 */
                padding: 1px 0; /* 进一步减少内边距，与手机端一致 */
                max-height: 60vh; /* 子菜单也限制高度 */
                overflow-y: auto; /* 子菜单也可滚动 */
            }
            
            .context-menu .submenu .context-menu-item {
                padding: 1px 8px !important; /* 子菜单项更紧凑的间距，与手机端一致 */
                min-height: 24px !important; /* 进一步减少最小高度，与手机端一致 */
                line-height: 1 !important; /* 更紧凑的行高，与手机端一致 */
                font-size: 12px !important; /* 字体大小与手机端一致 */
            }
            
            /* 菜单分隔线优化 */
            .context-menu-divider {
                margin: 0; /* 完全移除分隔线间距 */
                height: 1px; /* 确保分隔线高度 */
            }
            
            /* 帮助模态框优化 */
            .modal-backdrop {
                padding: 10px;
                box-sizing: border-box;
            }
            
            #help-modal {
                width: 100%;
                height: 100%;
                max-width: none;
                max-height: none;
                margin: 0;
                border-radius: 12px;
                overflow: hidden;
            }
            
            .help-modal-content {
                height: 100%;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                padding: 16px !important;
                box-sizing: border-box;
            }
            
            /* 帮助模态框标题和关闭按钮布局优化 */
            .help-modal-content h1 {
                padding-right: 60px; /* 为关闭按钮留出空间 */
                margin-top: 20px; /* 增加顶部间距，避免与关闭按钮重叠 */
            }
            
            #help-modal-close-btn {
                top: 8px !important; /* 确保按钮在更高的位置 */
                right: 8px !important;
                z-index: 1000 !important; /* 确保按钮在最上层 */
                width: 44px !important; /* 设置固定宽度 */
                height: 44px !important; /* 设置固定高度，确保正方形 */
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                font-size: 1.8rem !important;
                line-height: 1 !important;
            }
            
            .modal-content {
                padding: 16px;
                height: 100%;
                box-sizing: border-box;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            /* 确认对话框在移动端的特殊样式 */
            #confirm-modal {
                height: auto !important;
                max-height: 80vh !important;
                width: 90% !important;
                max-width: 400px !important;
            }
            
            /* 搜索容器优化 */
            #search-container {
                flex-shrink: 0;
                min-width: 120px;
            }
            
            #search-box {
                min-height: 44px;
                font-size: 0.8rem;
                touch-action: manipulation;
            }
            
            /* 颜色选择器优化 */
            input[type="color"] {
                width: 32px;
                height: 32px;
            }
        }
        
        @media (max-width: 480px) {
            /* 超小屏幕优化 */
            body {
                overflow: visible;
            }
            
            #toolbar {
                padding: 0.19rem; /* 减少25% (0.25rem * 0.75) */
                min-height: 38px; /* 减少25% (50px * 0.75) */
                overflow-y: visible;
            }
            
            /* 移动端面板优化 */
            .custom-color-picker-panel {
                position: fixed;
                top: 70px;
                bottom: auto;
                left: 10px;
                right: 10px;
                width: auto;
                max-width: calc(100vw - 20px);
                max-height: calc(100vh - 90px);
                z-index: 10000;
                margin-top: 0;
                overflow-y: auto;
            }
            
            .dropdown-menu {
                position: fixed;
                top: 70px;
                bottom: auto;
                /* 移除固定的left和right，让动态宽度生效 */
                max-width: calc(100vw - 20px);
                z-index: 10001;
                margin-top: 0;
                max-height: calc(100vh - 90px);
                overflow-y: auto;
                min-width: 100px; /* 移动端适中的最小宽度 */
            }
            
            .control-btn {
                min-height: 18px !important; /* 减少25% (24px * 0.75) */
                padding: 0.165rem 0.24rem !important; /* 减少25% (0.22rem * 0.75, 0.32rem * 0.75) */
                font-size: 0.75rem !important;
                min-width: 20px !important; /* 减少25% (27px * 0.75) */
            }
            
            /* 特殊按钮的额外调整 */
            #search-btn,
            #search-scope-toggle {
                padding: 0.19rem 0.28rem !important; /* 减少25% (0.25rem * 0.75, 0.375rem * 0.75) */
            }
            
            #search-scope-toggle {
                font-size: 0.56rem !important; /* 减少25% (0.75rem * 0.75) */
            }
            
            /* 搜索导航按钮紧凑化 */
            #search-prev-btn,
            #search-next-btn {
                min-width: 15px; /* 减少25% (20px * 0.75) */
                padding: 0.135rem 0.15rem; /* 减少25% (0.18rem * 0.75, 0.2rem * 0.75) */
            }
            
            #canvas-name-input {
                width: 70px;
                min-height: 30px; /* 减少25% (40px * 0.75) */
                font-size: 0.75rem;
            }
            
            /* 其他输入框高度调整 */
            .shortcut-input {
                padding: 1.5px 4.5px; /* 减少25% (2px * 0.75, 6px * 0.75) */
                font-size: 9px; /* 减少25% (12px * 0.75) */
            }
            
            /* 搜索框特殊处理 - 保持可用性 */
            #search-box {
                padding: 0.19rem 14px 0.19rem 0.19rem !important; /* 减少25% 但保持右侧空间给清除按钮 */
                font-size: 0.65rem !important; /* 减少25% (0.875rem * 0.75) */
                min-height: 22px !important; /* 减少25% */
                line-height: 1.2 !important;
                /* 强制确保移动端触摸交互 */
                touch-action: manipulation !important;
                -webkit-user-select: text !important;
                user-select: text !important;
                pointer-events: auto !important;
                z-index: 1000 !important;
                position: relative !important;
                /* 移除内联宽度样式的影响 */
                width: 100% !important;
                /* 移动端特殊处理 */
                -webkit-appearance: none !important;
                appearance: none !important;
                outline: none !important;
                background: var(--bg-color) !important;
                color: var(--text-color) !important;
                border: 1px solid #4b5563 !important;
                border-radius: 4px !important;
            }
            
            /* 搜索容器调整 */
            #search-container {
                width: 60px !important; /* 调整为80px的75% */
                min-height: 22px !important;
                /* 强制确保容器不阻止点击 */
                pointer-events: auto !important;
                position: relative !important;
                overflow: visible !important;
                z-index: 50 !important;
                display: flex !important;
                align-items: center !important;
            }
            
            /* 搜索清除按钮调整 */
            #search-clear-btn {
                width: 15px !important;
                height: 15px !important;
                min-width: 15px !important;
                min-height: 15px !important;
                max-width: 15px !important;
                max-height: 15px !important;
                font-size: 12px !important;
                right: 8px !important;
                z-index: 1001 !important;
                pointer-events: auto !important;
                border-radius: 2.5px !important;
                /* 移动端垂直对齐保持一致 */
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                /* 强制重置移动端默认样式 */
                -webkit-appearance: none !important;
                -moz-appearance: none !important;
                appearance: none !important;
                padding: 0 !important;
                margin: 0 !important;
                border: none !important;
                background: rgba(255, 255, 255, 0.1) !important;
                box-sizing: border-box !important;
                -webkit-tap-highlight-color: transparent !important;
                touch-action: manipulation !important;
            }
            
            .color-input {
                padding: 3px 3px; /* 减少25% (4px * 0.75) */
                font-size: 9px; /* 减少25% (12px * 0.75) */
                width: 38px; /* 减少25% (50px * 0.75) */
            }
            
            .hex-input {
                padding: 3px 3px; /* 减少25% (4px * 0.75) */
                font-size: 9px; /* 减少25% (12px * 0.75) */
                width: 122px; /* 减少25% (162px * 0.75) */
            }
            
            .hex-input-group {
                min-height: 30px; /* 减少25% (40px * 0.75) */
            }
            
            .canvas-info {
                bottom: 5px;
                left: 5px;
                right: auto;
                padding: 6px 8px;
                font-size: 10px;
                max-width: calc(100vw - 10px);
                background: transparent;
            }
            
            .info-line {
                font-size: 9px;
            }
            
            /* 超小屏幕右键菜单进一步优化 */
            .context-menu {
                min-width: 120px; /* 进一步减少最小宽度 */
                font-size: 12px; /* 进一步减小字体 */
                max-width: 80vw; /* 更小的最大宽度 */
                padding: 1px 0; /* 进一步减少内边距 */
                max-height: 70vh; /* 限制最大高度 */
                overflow-y: auto; /* 添加垂直滚动 */
                -webkit-overflow-scrolling: touch; /* 平滑滚动 */
            }
            
            .context-menu-item {
                padding: 1px 8px !important; /* 进一步减少内边距 */
                min-height: 24px !important; /* 进一步减少最小触摸高度 */
                font-size: 12px !important; /* 进一步减小字体 */
                line-height: 1 !important; /* 更紧凑的行高 */
                display: flex; /* 使用flex布局 */
                align-items: center; /* 垂直居中 */
                white-space: nowrap; /* 防止文字换行 */
            }
            
            .context-menu .submenu {
                min-width: 100px; /* 子菜单更小 */
                font-size: 12px; /* 统一字体大小为12px */
                padding: 1px 0; /* 进一步减少内边距 */
                max-height: 60vh; /* 子菜单也限制高度 */
                overflow-y: auto; /* 子菜单也可滚动 */
            }
            
            .context-menu .submenu .context-menu-item {
                padding: 1px 8px !important; /* 子菜单项更紧凑的间距 */
                min-height: 24px !important; /* 进一步减少最小高度 */
                line-height: 1 !important; /* 更紧凑的行高 */
                font-size: 12px !important; /* 统一字体大小为12px */
            }
            
            /* 超小屏幕分隔线优化 */
            .context-menu-divider {
                margin: 0; /* 完全移除分隔线间距 */
                height: 1px;
            }
            
            #search-container {
                width: 67px;
                min-width: 67px;
            }
            
            #search-box {
                min-height: 40px;
                font-size: 0.75rem;
                padding-right: 18px;
                border: 1px solid #4b5563;
                border-radius: 4px;
            }
            
            #search-clear-btn {
                right: 2px;
                font-size: 0.7rem;
                width: 12px;
                height: 12px;
                padding: 0;
                background: rgba(255, 255, 255, 0.15);
                border-radius: 2px;
            }
        }
        
        /* 小、中、大平板设备优化 - 与手机端768px完全一致 */
        @media (min-width: 769px) and (max-width: 1366px) {
            /* 防止页面滚动和拖拽 */
            body {
                overflow: visible !important;
                position: fixed !important;
                width: 100% !important;
                height: 100% !important;
            }
            
            /* 工具栏优化 - 修改为单行布局并支持水平滚动 */
            #toolbar {
                padding: 0.375rem !important; /* 与手机端768px一致 */
                flex-wrap: nowrap !important; /* 改为不换行，保持单行布局 */
                gap: 0.25rem !important;
                min-height: 45px !important; /* 与手机端768px一致 */
                overflow-x: auto !important; /* 支持水平滚动 */
                overflow-y: visible !important;
                -webkit-overflow-scrolling: touch !important;
                scrollbar-width: none !important; /* 隐藏滚动条 */
                -ms-overflow-style: none !important; /* 隐藏滚动条 */
            }
            
            #toolbar::-webkit-scrollbar {
                display: none !important;
            }
            
            .toolbar-section {
                flex-shrink: 0 !important;
                gap: 0.25rem !important;
            }
            
            .control-btn {
                min-height: 18px !important; /* 与手机端768px一致 */
                padding: 0.195rem 0.3rem !important; /* 与手机端768px一致 */
                font-size: 0.8rem !important; /* 与手机端768px一致 */
                white-space: nowrap !important;
                min-width: 24px !important; /* 与手机端768px一致 */
                touch-action: manipulation !important;
            }
            
            /* 保持主题预设按钮和搜索方向按钮的原始宽度 - 与768px一致 */
            #theme-switcher-btn {
                min-width: 32px !important; /* 与手机端768px一致 */
                padding: 0.195rem 0.4rem !important; /* 与手机端768px一致 */
            }
            
            /* 搜索导航按钮保持紧凑但高度调整 - 与768px一致 */
            #search-prev-btn,
            #search-next-btn {
                min-width: 24px !important; /* 与手机端768px一致 */
                padding: 0.195rem 0.25rem !important; /* 与手机端768px一致 */
            }
            
            #canvas-name-input {
                width: 80px !important; /* 与手机端768px一致 */
                min-height: 33px !important; /* 缩小1/4：44px * 0.75 = 33px */
                font-size: 0.8rem !important; /* 与手机端768px一致 */
            }
            
            /* 平板端面板优化 - 与768px一致 */
            .custom-color-picker-panel {
                z-index: 10000 !important;
            }
            
            .dropdown-menu {
                z-index: 10001 !important;
            }
            
            /* 左下角信息显示优化 - 与768px一致 */
            .canvas-info {
                position: fixed !important;
                bottom: 10px !important;
                left: 10px !important;
                right: auto !important;
                background: transparent !important;
                padding: 8px 12px !important; /* 与手机端768px一致 */
                font-size: 11px !important; /* 与手机端768px一致 */
                z-index: 1000 !important;
                max-width: calc(100vw - 20px) !important;
                box-sizing: border-box !important;
            }
            
            .info-line {
                margin: 1px 0 !important;
                font-size: 10px !important; /* 与手机端768px一致 */
                line-height: 1.2 !important;
                overflow: hidden !important;
                text-overflow: ellipsis !important;
                white-space: nowrap !important;
            }
            
            /* 上下文菜单优化 - 与768px一致 */
            .context-menu {
                min-width: 120px !important; /* 与手机端768px一致 */
                font-size: 12px !important; /* 与手机端768px一致 */
                max-width: 80vw !important; /* 与手机端768px一致 */
                border-radius: 8px !important; /* 与手机端768px一致 */
                padding: 1px 0 !important; /* 与手机端768px一致 */
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important; /* 与手机端768px一致 */
                max-height: 70vh !important; /* 与手机端768px一致 */
                overflow-y: auto !important;
                -webkit-overflow-scrolling: touch !important;
            }
            
            .context-menu-item {
                padding: 1px 8px !important; /* 与手机端768px一致 */
                min-height: 24px !important; /* 与手机端768px一致 */
                touch-action: manipulation !important;
                line-height: 1 !important; /* 与手机端768px一致 */
                font-weight: 400 !important; /* 与手机端768px一致 */
                display: flex !important; /* 与手机端768px一致 */
                align-items: center !important; /* 与手机端768px一致 */
                font-size: 12px !important; /* 与手机端768px一致 */
                white-space: nowrap !important; /* 与手机端768px一致 */
            }
            
            /* 子菜单优化 - 与768px一致 */
            .context-menu .submenu {
                min-width: 100px !important; /* 与手机端768px一致 */
                font-size: 12px !important; /* 与手机端768px一致 */
                padding: 1px 0 !important; /* 与手机端768px一致 */
                max-height: 60vh !important; /* 与手机端768px一致 */
                overflow-y: auto !important; /* 与手机端768px一致 */
            }
            
            .context-menu .submenu .context-menu-item {
                padding: 1px 8px !important; /* 与手机端768px一致 */
                min-height: 24px !important; /* 与手机端768px一致 */
                line-height: 1 !important; /* 与手机端768px一致 */
                font-size: 12px !important; /* 与手机端768px一致 */
            }
            
            /* 菜单分隔线优化 - 与768px一致 */
            .context-menu-divider {
                margin: 0 !important; /* 与手机端768px一致 */
                height: 1px !important; /* 与手机端768px一致 */
            }
            
            /* 帮助模态框优化 - 与768px一致 */
            .modal-backdrop {
                padding: 10px !important;
                box-sizing: border-box !important;
            }
            
            #help-modal {
                width: 100% !important;
                height: 100% !important;
                max-width: none !important;
                max-height: none !important;
                margin: 0 !important;
                border-radius: 12px !important;
                overflow: hidden !important;
            }
            
            .help-modal-content {
                height: 100% !important;
                overflow-y: auto !important;
                -webkit-overflow-scrolling: touch !important;
                padding: 16px !important;
                box-sizing: border-box !important;
            }
            
            /* 帮助模态框标题和关闭按钮布局优化 - 与768px一致 */
            .help-modal-content h1 {
                padding-right: 60px !important; /* 与手机端768px一致 */
                margin-top: 20px !important; /* 与手机端768px一致 */
            }
            
            #help-modal-close-btn {
                top: 8px !important; /* 与手机端768px一致 */
                right: 8px !important;
                z-index: 1000 !important; /* 与手机端768px一致 */
                width: 33px !important; /* 缩小1/4：44px * 0.75 = 33px */
                height: 33px !important; /* 缩小1/4：44px * 0.75 = 33px */
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                font-size: 1.35rem !important; /* 相应缩小字体：1.8rem * 0.75 = 1.35rem */
                line-height: 1 !important;
            }
            
            .modal-content {
                padding: 16px !important;
                height: 100% !important;
                box-sizing: border-box !important;
                overflow-y: auto !important;
                -webkit-overflow-scrolling: touch !important;
            }
            
            /* 确认对话框在移动端的特殊样式 - 与768px一致 */
            #confirm-modal {
                height: auto !important;
                max-height: 80vh !important;
                width: 90% !important;
                max-width: 400px !important;
            }
            
            /* 搜索容器优化 - 与768px一致 */
            #search-container {
                flex-shrink: 0 !important;
                min-width: 120px !important; /* 与手机端768px一致 */
            }
            
            #search-box {
                min-height: 33px !important; /* 缩小1/4：44px * 0.75 = 33px */
                font-size: 0.8rem !important; /* 与手机端768px一致 */
                touch-action: manipulation !important;
            }
            
            /* 颜色选择器优化 - 缩小1/4 */
            input[type="color"] {
                width: 24px !important; /* 缩小1/4：32px * 0.75 = 24px */
                height: 24px !important; /* 缩小1/4：32px * 0.75 = 24px */
            }
            
            .context-menu .submenu .context-menu-item {
                padding: 1px 8px !important; /* 与手机端480px一致 */
                min-height: 24px !important; /* 与手机端480px一致 */
                line-height: 1 !important; /* 与手机端480px一致 */
                font-size: 12px !important; /* 与手机端480px一致 */
            }
            
            /* 分隔线优化 */
            .context-menu-divider {
                margin: 0 !important; /* 与手机端480px一致 */
                height: 1px !important;
            }
        }

        /* Help Modal Button Hover Effect */
        #help-modal-ok-btn:hover {
            background-color: #4a7bc8 !important;
        }
        
        /* 移动端触摸优化 */
        @media (pointer: coarse) {
            /* 触摸设备专用样式 */
            * {
                -webkit-tap-highlight-color: transparent;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }
            
            /* 确保所有可点击元素有足够的触摸目标大小 */
            .control-btn,
            .context-menu-item,
            button,
            input[type="button"],
            input[type="submit"] {
                min-height: 44px;
                min-width: 44px;
                touch-action: manipulation;
            }
            
            /* 长按反馈动画 */
            @keyframes longPressProgress {
                0% {
                    transform: scale(1);
                    opacity: 0.3;
                }
                100% {
                    transform: scale(1.2);
                    opacity: 0.8;
                }
            }
            
            .long-press-feedback {
                position: absolute;
                border: 2px solid #3b82f6;
                border-radius: 50%;
                pointer-events: none;
                animation: longPressProgress 0.3s ease-out;
                z-index: 9999;
            }
            
            /* 触摸反馈效果 */
            .touch-feedback {
                position: absolute;
                border: 2px solid rgba(59, 130, 246, 0.6);
                border-radius: 50%;
                pointer-events: none;
                animation: touchRipple 0.6s ease-out;
                z-index: 9998;
            }
            
            @keyframes touchRipple {
                0% {
                    transform: scale(0);
                    opacity: 1;
                }
                100% {
                    transform: scale(4);
                    opacity: 0;
                }
            }
            
            /* 画布触摸优化 */
            #canvas {
                touch-action: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }
            
            /* 文本编辑器触摸优化 */
            #text-editor {
                touch-action: manipulation;
                -webkit-user-select: text;
                -moz-user-select: text;
                -ms-user-select: text;
                user-select: text;
            }
        }
        
        /* 移动端特定的节点和组样式优化 */
        @media (max-width: 768px) {
            /* 增加节点的最小尺寸以便于触摸 */
            .node {
                min-width: 44px;
                min-height: 44px;
            }
            
            /* 增加组的边框厚度以便于触摸 */
            .group {
                border-width: 3px;
            }
            
            /* 优化选择指示器 */
            .selected-indicator {
                border-width: 3px;
            }
            
            /* 移动端子菜单优化 */
            .context-menu .submenu {
                position: fixed !important;
                z-index: 10001;
                min-width: 150px;
                max-width: calc(100vw - 40px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                overflow: hidden;
            }
            
            .context-menu .submenu .context-menu-item {
                padding: 8px 16px;
                font-size: 14px;
                line-height: 1.2;
                min-height: 40px;
                display: flex;
                align-items: center;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            /* 确保子菜单项可以正常点击 */
            .context-menu .submenu .context-menu-item:active {
                background-color: rgba(255, 255, 255, 0.2);
            }
        }
        
        /* 扩展设备分类媒体查询 */
        
        /* 中平板设备 (768px - 1024px) */
        @media (min-width: 768px) and (max-width: 1024px) {
            /* 输入框高度优化 - 缩小1/4 - 使用更强的选择器优先级 */
            body #canvas-name-input,
            #toolbar #canvas-name-input,
            input#canvas-name-input {
                min-height: 33px !important; /* 缩小1/4，从44px到33px */
                height: 33px !important; /* 强制设置高度 */
                max-height: 33px !important; /* 限制最大高度 */
            }
            
            body #search-box,
            #search-container #search-box,
            input#search-box {
                min-height: 33px !important; /* 缩小1/4，从44px到33px */
                height: 33px !important; /* 强制设置高度 */
                max-height: 33px !important; /* 限制最大高度 */
            }
            
            .context-menu {
                min-width: 120px !important;
                font-size: 12px !important;
                max-width: 80vw !important;
                padding: 1px 0 !important;
                max-height: 70vh !important;
                overflow-y: auto !important;
                -webkit-overflow-scrolling: touch !important;
            }
            
            .context-menu-item {
                padding: 1px 8px !important;
                min-height: 24px !important;
                line-height: 1 !important;
                font-size: 12px !important;
            }
            
            .context-menu .submenu {
                min-width: 100px !important;
                font-size: 12px !important;
                padding: 1px 0 !important;
                max-height: 60vh !important;
                overflow-y: auto !important;
            }
            
            .context-menu .submenu .context-menu-item {
                padding: 1px 8px !important;
                min-height: 24px !important;
                line-height: 1 !important;
                font-size: 12px !important;
            }
        }
        
        /* 大平板设备 (1025px - 1366px) */
        @media (min-width: 1025px) and (max-width: 1366px) {
            .context-menu {
                min-width: 120px !important;
                font-size: 12px !important;
                max-width: 80vw !important;
                padding: 1px 0 !important;
                max-height: 70vh !important;
                overflow-y: auto !important;
                -webkit-overflow-scrolling: touch !important;
            }
            
            .context-menu-item {
                padding: 1px 8px !important;
                min-height: 24px !important;
                line-height: 1 !important;
                font-size: 12px !important;
            }
            
            .context-menu .submenu {
                min-width: 100px !important;
                font-size: 12px !important;
                padding: 1px 0 !important;
                max-height: 60vh !important;
                overflow-y: auto !important;
            }
            
            .context-menu .submenu .context-menu-item {
                padding: 1px 8px !important;
                min-height: 24px !important;
                line-height: 1 !important;
                font-size: 12px !important;
            }
        }
    </style>
    <style id="dynamic-theme-styles"></style>
</head>
<body class="text-white">



    <canvas id="canvas"></canvas>

    <!-- Canvas Info Display -->
    <div id="canvas-info" class="canvas-info">
        <div id="canvas-position-info" class="info-line">画布位置: (0, 0) | 缩放比例: 100%</div>
        <div id="canvas-count-info" class="info-line">节点数量: 0 | 组数量: 0</div>
        <div id="canvas-selection-info" class="info-line">选中节点坐标: 未选中</div>
    </div>

    <!-- Focus Button -->
    <button id="focus-btn" title="聚焦到选中节点或画布中心">聚焦</button>

    <textarea id="text-editor"></textarea>
    <textarea id="clipboard-helper" style="position: absolute; left: -9999px; top: -9999px;"></textarea>

    <!-- Context Menus -->
    <div id="node-context-menu" class="context-menu">
        <div class="context-menu-item" id="convert-to-nodeset-item" data-action="convert-to-nodeset">转节点集</div>
        <div class="context-menu-item" id="enter-nodeset-item" data-action="enter-nodeset">进入节点集</div>
        <div class="context-menu-item" id="convert-to-node-item" data-action="convert-to-node">转普通节点</div>
            <div class="context-menu-divider"></div>
            <div class="context-menu-item has-submenu">
                <div data-action="add-status-block">添加状态块</div>
                <div class="context-menu submenu">
                    <div class="context-menu-item" data-action="add-status-block-top">上</div>
                    <div class="context-menu-item" data-action="add-status-block-bottom">下</div>
                    <div class="context-menu-item" data-action="add-status-block-left">左</div>
                    <div class="context-menu-item" data-action="add-status-block-right">右</div>
                </div>
            </div>
            <div class="context-menu-item" data-action="remove-status-block">删除状态</div>
            <div class="context-menu-item" data-action="copy-status">复制状态</div>
            <div class="context-menu-item" data-action="paste-status">粘贴状态</div>
            <div class="context-menu-divider"></div>
            <div class="context-menu-item" data-action="group">打组</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="copy">复制</div>
        <div class="context-menu-item" data-action="cut">剪切</div>
        <div class="context-menu-item" data-action="paste">粘贴</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="copy-style">复制样式</div>
        <div class="context-menu-item" data-action="paste-style">粘贴样式</div>
        <div class="context-menu-item" data-action="clear-selected-style">清空选中样式</div>
        <div class="context-menu-item" data-action="clear-all-styles">清空所有样式</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item has-submenu">
            排序
            <div class="context-menu submenu">
                <div class="context-menu-item" data-action="sort-alpha">按首字母排序</div>
                <div class="context-menu-item" data-action="sort-size">按节点大小排序</div>
                <div class="context-menu-item" data-action="sort-id">按节点ID排序</div>
            </div>
        </div>
        <div class="context-menu-item has-submenu">
            对齐
             <div class="context-menu submenu">
                <div class="context-menu-item" data-action="align-left">左对齐</div>
                <div class="context-menu-item" data-action="align-right">右对齐</div>
                <div class="context-menu-item" data-action="align-top">上对齐</div>
                <div class="context-menu-item" data-action="align-bottom">下对齐</div>
            </div>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item has-submenu">
            文字对齐
            <div class="context-menu submenu">
                <div class="context-menu-item" data-action="text-align-left">文字左对齐</div>
                <div class="context-menu-item" data-action="text-align-center">文字居中</div>
                <div class="context-menu-item" data-action="text-align-right">文字右对齐</div>
            </div>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" id="split-lines-item" data-action="split-lines">拆分换行</div>
        <div class="context-menu-item" id="merge-lines-item" data-action="merge-lines">合并换行</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="export-markdown">导出脑图文本</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="reset-node-size">重置节点长宽</div>
        <div class="context-menu-item" data-action="make-square">节点正方形化</div>
        <div class="context-menu-item" data-action="delete-node">删除节点</div>
        <div class="context-menu-item" data-action="delete-image">删除图片</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" id="add-image-item" data-action="add-image">添加图片</div>
        <div class="context-menu-item" id="change-image-item" data-action="change-image">更换图片</div>
    </div>
    <div id="group-context-menu" class="context-menu">
        <div class="context-menu-item" data-action="copy">复制</div>
        <div class="context-menu-item" data-action="cut">剪切</div>
        <div class="context-menu-item" data-action="paste">粘贴</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="resize-group-to-fit">调整组框大小</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="copy-style">复制样式</div>
        <div class="context-menu-item" data-action="paste-style">粘贴样式</div>
        <div class="context-menu-item" data-action="clear-selected-style">清空选中样式</div>
        <div class="context-menu-item" data-action="clear-all-styles">清空所有样式</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="delete-group">删除组</div>
        <div class="context-menu-item" data-action="delete-group-nodes">删除组+节点</div>
    </div>
    <div id="canvas-context-menu" class="context-menu">
        <div class="context-menu-item" data-action="paste">粘贴</div>
        <div class="context-menu-item" data-action="paste-style">粘贴样式</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="import-markdown">导入MD文本</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="clear-all-styles">清空所有样式</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="clean-orphaned-nodes">清理孤立节点</div>
    </div>

    <!-- Controls Toolbar -->
    <div id="toolbar">
        <label for="canvas-name-input" class="visually-hidden">画布名称</label>
        <input type="text" id="canvas-name-input" value="新建画布" aria-label="画布名称">
        <button id="save-btn" class="control-btn" title="保存当前项目为JSON文件">保存</button>
        <button id="save-as-btn" class="control-btn" title="将项目另存为新的JSON文件">另存</button>
        <button id="load-btn" class="control-btn" title="加载JSON项目或模块文件">加载</button>
        <button id="merge-btn" class="control-btn" title="合并其他JSON模块到当前项目">合并</button>
        <button id="export-module-btn" class="control-btn" title="导出选中内容为JSON模块文件">导出选择</button>
        <input type="file" id="file-input" style="display: none;" accept=".json">
        <input type="file" id="merge-file-input" style="display: none;" accept=".json">
        
        <button id="history-snapshot-btn" class="control-btn" title="查看和跳转到历史状态">历史</button>
        <label for="node-bg-color-picker" class="control-label">节点背景:</label>
        <div class="custom-color-picker-wrapper" data-picker-id="node-bg">
            <div class="color-display" id="node-bg-color-display" style="background-color: #4a4a4a;"></div>
        </div>
        <label for="font-color-picker" class="control-label">节点字体:</label>
        <div class="custom-color-picker-wrapper" data-picker-id="font">
            <div class="color-display" id="font-color-display" style="background-color: #f0f0f0;"></div>
        </div>
        <label for="group-color-picker" class="control-label">组颜色:</label>
        <div class="custom-color-picker-wrapper" data-picker-id="group">
            <div class="color-display" id="group-color-display" style="background-color: #3b82f6;"></div>
        </div>
        
        <button id="snap-toggle-btn" class="control-btn toggle-btn" title="节点自动吸附到网格点">吸附</button>
        <button id="magnetic-toggle-btn" class="control-btn toggle-btn" title="相邻节点会一起移动">磁吸</button>
        <button id="collision-toggle-btn" class="control-btn toggle-btn" title="节点之间产生物理碰撞效果">碰撞</button>
        <button id="push-toggle-btn" class="control-btn toggle-btn" title="拖拽节点时可推动其他节点">推动</button>
        <button id="insert-toggle-btn" class="control-btn toggle-btn" title="智能插入模式：在紧密排列的节点中插入新节点">插入</button>

        <div id="clear-section">
             <div class="control-group" style="gap: 0.25rem;">
                 <div id="search-container">
                    <label for="search-box" class="visually-hidden">搜索节点</label>
                    <input type="text" id="search-box" class="shortcut-input" placeholder="搜索..." aria-label="搜索节点">
                    <button id="search-clear-btn" aria-label="清除搜索">&times;</button>
                 </div>
                 <button id="search-btn" class="control-btn" style="padding: 0.25rem 0.375rem;" title="执行搜索">🔍</button>
                 <button id="search-scope-toggle" class="control-btn" style="padding: 0.25rem 0.375rem; font-size: 0.75rem;" title="切换搜索范围：当前层级 / 全局搜索">当前</button>
                 <button id="search-group-toggle" class="control-btn toggle-btn" title="切换是否搜索组：关闭 / 开启">组</button>
                 <button id="search-prev-btn" class="control-btn" style="padding: 0.25rem 0.375rem;" title="跳转到上一个搜索结果">&lt;</button>
                 <span id="search-count" style="font-size: 0.75rem; min-width: 40px; text-align: center;">0 / 0</span>
                 <button id="search-next-btn" class="control-btn" style="padding: 0.25rem 0.375rem;" title="跳转到下一个搜索结果">&gt;</button>
            </div>
             <button id="clear-btn" class="control-btn" title="清除画布上的所有内容">清空</button>
             <button id="grid-toggle-btn" class="control-btn toggle-btn" title="切换画布背景网格显示">网格</button>
             <button id="md-convert-btn" class="control-btn" title="导入markdown文件并转换为节点">MD导入</button>
             <button id="shortcut-config-btn" class="control-btn" title="配置快捷键">快捷键</button>
             <!-- THEME SWITCHER START -->
             <div class="dropdown-container">
                <button id="theme-switcher-btn" class="control-btn" title="切换界面配色主题">主题预设</button>
            </div>
            <!-- THEME SWITCHER END -->
             <button id="help-btn" class="control-btn" title="打开使用说明界面">帮助</button>
             <button id="auto-save-toggle-btn" class="control-btn toggle-btn" title="开启/关闭自动保存功能">自动保存</button>
             <button id="realtime-backup-toggle-btn" class="control-btn toggle-btn" title="开启/关闭实时备份功能">实时备份</button>
        </div>
    </div>
    
    <!-- Node Set Navigation Breadcrumb -->
    <div id="nodeset-navigation" class="nodeset-navigation" style="display: none;">
        <div class="breadcrumb-container">
            <span class="breadcrumb-item root-item" data-nodeset-id="root">
                <span class="breadcrumb-icon">🏠</span>
                <span class="breadcrumb-text">根画布</span>
            </span>
        </div>
    </div>
    
    <!-- Confirmation Modal -->
    <div id="confirm-modal-backdrop" class="modal-backdrop" style="display: none;">
        <div id="confirm-modal" class="modal-content" style="background-color: var(--menu-bar-bg); border: 1px solid var(--btn-inactive);">
            <p id="confirm-modal-message" class="modal-message" style="color: var(--text-color);"></p>
            <div id="confirm-modal-buttons" class="modal-buttons">
                <button id="confirm-cancel-btn" class="control-btn">取消</button>
                <button id="confirm-ok-btn" class="control-btn">确定</button>
            </div>
        </div>
    </div>

    <!-- Shortcut Configuration Modal -->
    <div id="shortcut-modal-backdrop" class="modal-backdrop" style="display: none;">
        <div id="shortcut-modal" class="modal-content" style="max-width: 896px; max-height: 88vh; overflow-y: auto; padding: 14px; background-color: var(--context-menu-bg); border: 1px solid var(--node-border);">
            <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px; padding-bottom: 8px; border-bottom: 1px solid var(--node-border);">
                <h2 style="margin: 0; font-size: 1.68rem; font-weight: bold; color: var(--text-color);">快捷键配置</h2>
                <button id="shortcut-modal-close-btn" style="background-color: var(--btn-inactive); border: 1px solid var(--node-border); font-size: 1.68rem; cursor: pointer; color: #ef4444; border-radius: 4px; padding: 4px 8px;" title="关闭">&times;</button>
            </div>
            <div id="shortcut-config-content" class="shortcut-config-content">
                <!-- Shortcut configuration items will be populated by JavaScript -->
            </div>
            <div class="modal-buttons" style="margin-top: 14px; padding-top: 8px; border-top: 1px solid var(--node-border);">
                <button id="shortcut-reset-btn" class="control-btn" style="margin-right: 11px; background-color: var(--input-bg); color: var(--text-color); border: 1px solid var(--node-border);">重置默认</button>
                <button id="shortcut-save-btn" class="control-btn" style="background-color: var(--btn-active); color: white; border: none;">保存配置</button>
            </div>
        </div>
    </div>

    <!-- New Draggable History Modal -->
    <div id="new-history-modal" class="new-history-modal" style="display: none;">
        <div class="new-history-modal-content">
            <div class="new-history-modal-header" id="new-history-modal-header">
                <h2 id="new-history-title">历史记录</h2>
                <button id="new-history-modal-close-btn" class="new-history-close-btn">&times;</button>
            </div>
            <div class="new-history-modal-body">
                <div id="new-history-list" class="new-history-list">
                    <!-- History items will be dynamically generated here -->
                </div>
            </div>
        </div>
    </div>

<!-- Help Modal -->
<div id="help-modal-backdrop" class="modal-backdrop" style="display: none;">
    <div class="modal-content help-modal-content rounded-2xl" style="position: relative; max-width: 1250px; max-height: 80vh; overflow-y: auto; padding: 2rem; background-color: var(--menu-bar-bg); border: 1px solid var(--btn-inactive);">
        <button id="help-modal-close-btn" style="position: absolute; top: 1rem; right: 1rem; background: none; border: none; font-size: 2rem; color: var(--clear-btn); cursor: pointer; z-index: 10;" title="关闭帮助页面">&times;</button>

        <!-- 页面标题区域 -->
        <header class="text-center mb-6">
            <h1 class="text-4xl sm:text-5xl lg:text-6xl font-extrabold tracking-tight" style="color: var(--text-color);">
                画布工具<span class="gradient-text ml-3">使用说明</span>
            </h1>
            <p class="mt-3 max-w-4xl mx-auto text-lg" style="color: var(--text-color);">
                这是一个用于整理思路的在线画布工具。以下是主要功能和快捷键说明，帮助您快速上手。
            </p>
        </header>

        <!-- 功能卡片区域 -->
        <main class="space-y-4">
            <!-- 基础操作 section -->
            <div>
                <h2 class="text-2xl font-bold mb-4 pb-3" style="color: var(--text-color); border-bottom: 1px solid var(--btn-inactive);">基础操作</h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- 鼠标操作 -->
                    <div class="rounded-2xl p-4 transition-all duration-300 hover:-translate-y-1" style="background-color: var(--btn-inactive); border: 1px solid var(--btn-active);">
                        <h3 class="flex items-center gap-3 text-lg font-semibold mb-2 pb-2" style="color: var(--text-color); border-bottom: 1px solid var(--btn-active);">
                            <svg class="h-5 w-5" style="color: var(--btn-active);" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="m13 13l6 6"></path></svg>
                            <span>鼠标操作</span>
                        </h3>
                        <ul class="space-y-1.5">
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">移动缩放</span><span style="color: var(--text-color);" class="text-xs">中键拖拽滚动</span></li>
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">创建节点</span><span style="color: var(--text-color);" class="text-xs">双击画布</span></li>
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">编辑节点/组</span><span style="color: var(--text-color);" class="text-xs">双击文字</span></li>
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">移动/框选</span><span style="color: var(--text-color);" class="text-xs">左键拖拽</span></li>
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">多选/取消</span><span style="color: var(--text-color);" class="text-xs">Ctrl+点击</span></li>
                        </ul>
                    </div>

                    <!-- 键盘快捷键 -->
                    <div class="rounded-2xl p-4 transition-all duration-300 hover:-translate-y-1" style="background-color: var(--btn-inactive); border: 1px solid var(--btn-active);">
                        <h3 class="flex items-center gap-3 text-lg font-semibold mb-2 pb-2" style="color: var(--text-color); border-bottom: 1px solid var(--btn-active);">
                            <svg class="h-5 w-5" style="color: var(--btn-active);" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="7" y1="7" x2="7.01" y2="7"></line><line x1="11" y1="7" x2="11.01" y2="7"></line><line x1="15" y1="7" x2="15.01" y2="7"></line><line x1="7" y1="11" x2="7.01" y2="11"></line><line x1="11" y1="11" x2="11.01" y2="11"></line><line x1="15" y1="11" x2="15.01" y2="11"></line><line x1="7" y1="15" x2="7.01" y2="15"></line><line x1="11" y1="15" x2="11.01" y2="15"></line><line x1="15" y1="15" x2="15.01" y2="15"></line></svg>
                            <span>键盘快捷键</span>
                        </h3>
                        <ul class="space-y-1.5">
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">复制/剪切/粘贴</span><span style="color: var(--text-color);" class="text-xs">Ctrl+C/X/V</span></li>
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">删除选中</span><span style="color: var(--text-color);" class="text-xs">Delete</span></li>
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">保存/加载</span><span style="color: var(--text-color);" class="text-xs">Ctrl+S/O</span></li>
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">另存</span><span style="color: var(--text-color);" class="text-xs">Ctrl+Shift+S</span></li>
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">全选节点/所有</span><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;" class="text-xs">Ctrl+A/AA</span></li>
                        </ul>
                    </div>

                    <!-- 编辑与菜单 -->
                    <div class="rounded-2xl p-4 transition-all duration-300 hover:-translate-y-1" style="background-color: var(--btn-inactive); border: 1px solid var(--btn-active);">
                        <h3 class="flex items-center gap-3 text-lg font-semibold mb-2 pb-2" style="color: var(--text-color); border-bottom: 1px solid var(--btn-active);">
                            <svg class="h-5 w-5" style="color: var(--btn-active);" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path><path d="m13 13l6 6"></path></svg>
                            <span>编辑与菜单</span>
                        </h3>
                        <ul class="space-y-1.5">
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">撤销/重做</span><span style="color: var(--text-color);" class="text-xs">Ctrl+Z/Y</span></li>
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">节点内换行</span><span style="color: var(--text-color);" class="text-xs">Shift+Enter</span></li>
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">将选中项打组</span><span style="color: var(--text-color);" class="text-xs">Ctrl+G</span></li>
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">转换/进入节点集</span><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;" class="text-xs">Ctrl+Q/Q</span></li>
                            <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">聚焦选中</span><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;" class="text-xs">空格键</span></li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- 便捷功能 section -->
            <div>
                <h2 class="text-2xl font-bold mb-4 pb-3" style="color: var(--text-color); border-bottom: 1px solid var(--btn-inactive);"><span class="gradient-text">特色功能</span></h2>
                <div class="space-y-6">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <!-- 智能辅助 -->
                        <div class="rounded-2xl p-4 transition-all duration-300 hover:-translate-y-1" style="background-color: var(--btn-inactive); border: 1px solid var(--btn-active);">
                            <h3 class="flex items-center gap-3 text-lg font-semibold mb-2 pb-2" style="color: var(--text-color); border-bottom: 1px solid var(--btn-active);">
                                <svg class="h-5 w-5" style="color: var(--btn-active);" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/><path d="M8 8l1.5 1.5"/><path d="M16 8l-1.5 1.5"/><path d="M8 16l1.5-1.5"/><path d="M16 16l-1.5-1.5"/></svg>
                                <span>智能辅助</span>
                            </h3>
                            <ul class="space-y-1.5">
                                <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">快速插入节点</span><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;" class="text-xs">智能插入</span></li>
                                <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">相邻节点粘合</span><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;" class="text-xs">磁吸效果</span></li>
                                <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">防止节点重叠</span><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;" class="text-xs">碰撞检测</span></li>
                                <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">拖拽推开节点</span><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;" class="text-xs">推动模式</span></li>
                            </ul>
                        </div>

                        <!-- 拖放即得 -->
                        <div class="rounded-2xl p-4 transition-all duration-300 hover:-translate-y-1" style="background-color: var(--btn-inactive); border: 1px solid var(--btn-active);">
                            <h3 class="flex items-center gap-3 text-lg font-semibold mb-2 pb-2" style="color: var(--text-color); border-bottom: 1px solid var(--btn-active);">
                                <svg class="h-5 w-5" style="color: var(--btn-active);" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/><path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/><path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/><path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/></svg>
                                <span>拖放即得</span>
                            </h3>
                            <ul class="space-y-1.5">
                                <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">合并节点模块</span><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;" class="text-xs">拖入.json</span></li>
                                <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">创建图片节点</span><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;" class="text-xs">拖入图片</span></li>
                                <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">创建文本节点</span><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;" class="text-xs">拖入文字</span></li>
                                <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">脑图转节点组</span><span style="color: #000;" class="text-xs"><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;">粘贴识别</span></span></li>
                            </ul>
                        </div>
                        
                        <!-- 快捷分享 -->
                        <div class="rounded-2xl p-4 transition-all duration-300 hover:-translate-y-1" style="background-color: var(--btn-inactive); border: 1px solid var(--btn-active);">
                            <h3 class="flex items-center gap-3 text-lg font-semibold mb-2 pb-2" style="color: var(--text-color); border-bottom: 1px solid var(--btn-active);">
                                <svg class="h-5 w-5" style="color: var(--btn-active);" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12h18"/><path d="m15 6 6 6-6 6"/></svg>
                                <span>快捷分享</span>
                            </h3>
                            <ul class="space-y-1.5">
                                <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">导出脑图文本</span><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;" class="text-xs">右键导出</span></li>
                                <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">聊天窗口可粘贴</span><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;" class="text-xs">JSON剪贴板</span></li>
                                <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">模块与项目兼容</span><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;" class="text-xs">格式互通</span></li>
                                <li class="px-3 py-1 rounded-lg flex justify-between items-center text-sm" style="background-color: var(--menu-bar-bg);"><span style="color: var(--text-color);">跨平台协作共享</span><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;" class="text-xs">团队协作</span></li>
                            </ul>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-6">
                        <!-- 节点集介绍 -->
                        <div class="rounded-2xl p-4 transition-all duration-300 hover:-translate-y-1" style="background-color: var(--btn-inactive); border: 1px solid var(--btn-active);">
                            <h3 class="flex items-center gap-3 text-lg font-semibold mb-2 pb-2" style="color: var(--text-color); border-bottom: 1px solid var(--btn-active);">
                                <svg class="h-5 w-5" style="color: var(--btn-active);" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-1.414-.586H13l-2.5-2.5"/><path d="m14 5 3 3"/></svg>
                                <span>节点集</span>
                            </h3>
                            <ul class="space-y-1.5 text-xs" style="color: var(--text-color);" list-disc list-inside>
                                <li>无限层级嵌套+独特视觉标识</li>
                                <li>提供层级导航与全局搜索功能</li>
                                <li>可将多个节点组织为逻辑单元</li>
                                <li>支持鼠标后退快捷键退出</li>
                            </ul>
                        </div>
                        
                        <!-- 对齐&排序 -->
                        <div class="rounded-2xl p-4 transition-all duration-300 hover:-translate-y-1" style="background-color: var(--btn-inactive); border: 1px solid var(--btn-active);">
                            <h3 class="flex items-center gap-3 text-lg font-semibold mb-2 pb-2" style="color: var(--text-color); border-bottom: 1px solid var(--btn-active);">
                                <svg class="h-5 w-5" style="color: var(--btn-active);" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3 4 7l4 4"/><path d="M4 7h16"/><path d="m16 21 4-4-4-4"/><path d="M20 17H4"/></svg>
                                <span>对齐&排序&宽度</span>
                            </h3>
                            <ul class="space-y-1.5 text-xs" style="color: var(--text-color);" list-disc list-inside>
                                <li>将节点快速排列成区块</li>
                                <li>首字母、ID、大小3种排序方式</li>
                                <li>Shift拖拽统一选中节点宽度</li>
                                <li><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;">Ctrl+方向键批量对齐节点</span></li>
                            </ul>
                        </div>

                        <!-- 主题预设 -->
                        <div class="rounded-2xl p-4 transition-all duration-300 hover:-translate-y-1" style="background-color: var(--btn-inactive); border: 1px solid var(--btn-active);">
                            <h3 class="flex items-center gap-3 text-lg font-semibold mb-2 pb-2" style="color: var(--text-color); border-bottom: 1px solid var(--btn-active);">
                                <svg class="h-5 w-5" style="color: var(--btn-active);" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="8" r="2" fill="currentColor"/><circle cx="8" cy="14" r="2" fill="currentColor"/><circle cx="16" cy="14" r="2" fill="currentColor"/><circle cx="12" cy="18" r="1.5" fill="currentColor"/><circle cx="7" cy="10" r="1.5" fill="currentColor"/><circle cx="17" cy="10" r="1.5" fill="currentColor"/><path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 6.34l-1.41-1.41M19.07 19.07l-1.41-1.41"/></svg>
                                <span>主题预设</span>
                            </h3>
                            <ul class="space-y-1.5 text-xs" style="color: var(--text-color);" list-disc list-inside>
                                <li>内置超过90种专业色彩主题</li>
                                <li>鼠标悬停即可实时预览效果</li>
                                <li>使用方向键可快速切换并应用</li>
                                <li>主题切换支持撤销重做</li>
                            </ul>
                        </div>

                        <!-- 快速搜索 -->
                        <div class="rounded-2xl p-4 transition-all duration-300 hover:-translate-y-1" style="background-color: var(--btn-inactive); border: 1px solid var(--btn-active);">
                            <h3 class="flex items-center gap-3 text-lg font-semibold mb-2 pb-2" style="color: var(--text-color); border-bottom: 1px solid var(--btn-active);">
                                <svg class="h-5 w-5" style="color: var(--btn-active);" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                                <span>快速搜索</span>
                            </h3>
                            <ul class="space-y-1.5 text-xs" style="color: var(--text-color);" list-disc list-inside>
                                <li>快速查找画布中的节点与组</li>
                                <li>支持高亮显示与逐个定位</li>
                                <li>支持当前层级与全局搜索切换</li>
                                <li><span style="background-color: #f1c043; color: #000; padding: 2px 4px; border-radius: 3px;">方向键快速切换搜索结果</span></li>
                            </ul>
                        </div>

                        <!-- 样式复制 -->
                        <div class="rounded-2xl p-4 transition-all duration-300 hover:-translate-y-1" style="background-color: var(--btn-inactive); border: 1px solid var(--btn-active);">
                            <h3 class="flex items-center gap-3 text-lg font-semibold mb-2 pb-2" style="color: var(--text-color); border-bottom: 1px solid var(--btn-active);">
                                <svg class="h-5 w-5" style="color: var(--btn-active);" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 21l1.9-5.7a8.5 8.5 0 1 1 3.8 3.8z"/><path d="M12 2v6"/><path d="M12 8a4 4 0 1 0 4 4"/><circle cx="12" cy="12" r="2"/></svg>
                                <span>样式复制</span>
                            </h3>
                            <ul class="space-y-1.5 text-xs" style="color: var(--text-color);" list-disc list-inside>
                                <li>复制粘贴自动匹配节点+组</li>
                                <li>自定义样式不受主题影响</li>
                                <li>支持一键清空所有自定义样式</li>
                                <li>批量应用样式，提升设计效率</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 确定按钮 -->
            <div class="flex justify-center mt-8 mb-6">
                <button id="help-modal-ok-btn" class="font-semibold py-2 px-5 rounded-xl transition-all duration-300 transform hover:scale-105 shadow-lg hover:shadow-xl" style="background-color: var(--btn-active); color: var(--text-color);">
                    确定
                </button>
            </div>
        </main>
    </div>
</div>

<!-- MD导入弹窗 -->
<div id="md-convert-modal-backdrop" class="modal-backdrop" style="display: none;">
    <div id="md-convert-modal" class="modal-content" style="max-width: 800px; max-height: 80vh; padding: 2rem; background-color: var(--menu-bar-bg); border: 1px solid var(--btn-inactive);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid var(--btn-inactive);">
            <h2 style="color: var(--text-color); font-size: 1.5rem; font-weight: bold; margin: 0;">Markdown转换</h2>
            <button id="md-convert-modal-close-btn" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--clear-btn);" title="关闭">&times;</button>
        </div>
        
        <div style="margin-bottom: 1.5rem;">
            <label for="md-input-textarea" style="display: block; color: var(--text-color); font-weight: bold; margin-bottom: 0.5rem;">
                输入Markdown文本：
            </label>
            <textarea 
                id="md-input-textarea" 
                placeholder="请输入Markdown文本，支持 # ## ### 等标题层级&#10;例如：&#10;# 主标题&#10;## 子标题1&#10;### 子子标题&#10;## 子标题2"
                style="width: 100%; height: 300px; padding: 1rem; border: 1px solid var(--btn-inactive); border-radius: 8px; background-color: var(--menu-bar-bg); color: var(--text-color); font-family: 'Courier New', monospace; font-size: 14px; resize: vertical; outline: none;"
            ></textarea>
        </div>
        
        <div style="display: flex; justify-content: flex-end; gap: 1rem;">
            <button id="md-convert-cancel-btn" style="padding: 0.75rem 1.5rem; border: 1px solid var(--btn-inactive); border-radius: 8px; background-color: var(--menu-bar-bg); color: var(--text-color); cursor: pointer; transition: all 0.3s;">
                取消
            </button>
            <button id="md-convert-confirm-btn" style="padding: 0.75rem 1.5rem; border: none; border-radius: 8px; background-color: var(--btn-active); color: var(--text-color); cursor: pointer; transition: all 0.3s; font-weight: bold;">
                转换
            </button>
        </div>
    </div>
</div>

<!-- 自定义确认对话框 -->
<div id="custom-confirm-modal-backdrop" class="modal-backdrop" style="display: none;">
    <div id="custom-confirm-modal" class="modal-content" style="max-width: 500px; padding: 2rem; background-color: var(--menu-bar-bg); border: 1px solid var(--btn-inactive);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid var(--btn-inactive);">
            <h2 style="color: var(--text-color); font-size: 1.25rem; font-weight: bold; margin: 0;">确认操作</h2>
            <button id="custom-confirm-modal-close-btn" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--clear-btn);" title="关闭">&times;</button>
        </div>
        
        <div id="custom-confirm-message" style="margin-bottom: 1.5rem; color: var(--text-color); line-height: 1.6;">
            <!-- 确认消息将在这里显示 -->
        </div>
        
        <div style="display: flex; justify-content: flex-end; gap: 1rem;">
            <button id="custom-confirm-cancel-btn" style="padding: 0.75rem 1.5rem; border: 1px solid var(--btn-inactive); border-radius: 8px; background-color: transparent; color: var(--text-color); cursor: pointer; transition: all 0.3s;">
                取消
            </button>
            <button id="custom-confirm-ok-btn" style="padding: 0.75rem 1.5rem; border: none; border-radius: 8px; background-color: var(--btn-active); color: var(--text-color); cursor: pointer; transition: all 0.3s; font-weight: bold;">
                确定
            </button>
        </div>
    </div>
</div>

<!-- Markdown导入确认对话框 -->
<div id="markdown-import-modal-backdrop" class="modal-backdrop" style="display: none;">
    <div id="markdown-import-modal" class="modal-content" style="max-width: 500px; padding: 2rem; background-color: var(--menu-bar-bg); border: 1px solid var(--btn-inactive);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid var(--btn-inactive);">
            <h2 style="color: var(--text-color); font-size: 1.25rem; font-weight: bold; margin: 0;">检测到Markdown格式内容</h2>
            <button id="markdown-import-modal-close-btn" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--clear-btn);" title="关闭">&times;</button>
        </div>
        
        <div id="markdown-import-message" style="margin-bottom: 1.5rem; color: var(--text-color); line-height: 1.6;">
            是否要解析为层级结构？
        </div>
        
        <div style="display: flex; justify-content: flex-end; gap: 1rem;">
            <button id="markdown-import-cancel-btn" style="padding: 0.75rem 1.5rem; border: 1px solid var(--btn-inactive); border-radius: 8px; background-color: var(--menu-bar-bg); color: var(--text-color); cursor: pointer; transition: all 0.3s;">
                取消导入
            </button>
            <button id="markdown-import-text-btn" style="padding: 0.75rem 1.5rem; border: 1px solid var(--btn-inactive); border-radius: 8px; background-color: var(--menu-bar-bg); color: var(--text-color); cursor: pointer; transition: all 0.3s;">
                文本导入
            </button>
            <button id="markdown-import-mindmap-btn" style="padding: 0.75rem 1.5rem; border: none; border-radius: 8px; background-color: var(--btn-active); color: var(--text-color); cursor: pointer; transition: all 0.3s; font-weight: bold;">
                Markdown导图
            </button>
        </div>
    </div>
</div>

<!-- Fixed position panels moved outside toolbar -->
<div id="theme-dropdown" class="dropdown-menu">
    <!-- Themes will be populated by JavaScript -->
</div>

<!-- Color picker panels moved outside toolbar -->
<div class="custom-color-picker-panel" data-picker-id="node-bg"></div>
<div class="custom-color-picker-panel" data-picker-id="font"></div>
<div class="custom-color-picker-panel" data-picker-id="group"></div>

<script>
(function() {
    'use strict';

    // ===================================================================================
    // DOM & Canvas Setup
    // ===================================================================================
    const dom = {
        canvas: document.getElementById('canvas'),
        toolbar: document.getElementById('toolbar'), // Added toolbar reference
        textEditor: document.getElementById('text-editor'),
        nodeBgColorDisplay: document.getElementById('node-bg-color-display'),
        fontColorDisplay: document.getElementById('font-color-display'),
        groupColorDisplay: document.getElementById('group-color-display'),
        
        gridToggleBtn: document.getElementById('grid-toggle-btn'),
        snapToggleBtn: document.getElementById('snap-toggle-btn'),
        magneticToggleBtn: document.getElementById('magnetic-toggle-btn'),
        collisionToggleBtn: document.getElementById('collision-toggle-btn'),
        pushToggleBtn: document.getElementById('push-toggle-btn'),
        insertToggleBtn: document.getElementById('insert-toggle-btn'),




        saveBtn: document.getElementById('save-btn'),
        saveAsBtn: document.getElementById('save-as-btn'),
        loadBtn: document.getElementById('load-btn'),
        clearBtn: document.getElementById('clear-btn'),
        helpBtn: document.getElementById('help-btn'),
        mergeBtn: document.getElementById('merge-btn'),
        exportModuleBtn: document.getElementById('export-module-btn'),
        mdConvertBtn: document.getElementById('md-convert-btn'),
        shortcutConfigBtn: document.getElementById('shortcut-config-btn'),
        shortcutModalBackdrop: document.getElementById('shortcut-modal-backdrop'),
        shortcutModal: document.getElementById('shortcut-modal'),
        shortcutModalCloseBtn: document.getElementById('shortcut-modal-close-btn'),
        shortcutConfigContent: document.getElementById('shortcut-config-content'),
        shortcutResetBtn: document.getElementById('shortcut-reset-btn'),
        shortcutSaveBtn: document.getElementById('shortcut-save-btn'),
        historySnapshotBtn: document.getElementById('history-snapshot-btn'),
        fileInput: document.getElementById('file-input'),
        mergeFileInput: document.getElementById('merge-file-input'),
        canvasNameInput: document.getElementById('canvas-name-input'),
        nodeContextMenu: document.getElementById('node-context-menu'),
        groupContextMenu: document.getElementById('group-context-menu'),
        canvasContextMenu: document.getElementById('canvas-context-menu'),
        clipboardHelper: document.getElementById('clipboard-helper'),
        addImageItem: document.getElementById('add-image-item'),
        changeImageItem: document.getElementById('change-image-item'),
        splitLinesItem: document.getElementById('split-lines-item'),
        mergeLinesItem: document.getElementById('merge-lines-item'),
        confirmModalBackdrop: document.getElementById('confirm-modal-backdrop'),
        confirmModalMessage: document.getElementById('confirm-modal-message'),
        confirmOkBtn: document.getElementById('confirm-ok-btn'),
        confirmCancelBtn: document.getElementById('confirm-cancel-btn'),
        
        // Canvas info display elements
        canvasPositionInfo: document.getElementById('canvas-position-info'),
        canvasCountInfo: document.getElementById('canvas-count-info'),
        canvasSelectionInfo: document.getElementById('canvas-selection-info'),
        
        // Focus button
        focusBtn: document.getElementById('focus-btn'),
        newHistoryModal: document.getElementById('new-history-modal'),
        newHistoryModalContent: document.querySelector('.new-history-modal-content'),
        newHistoryModalHeader: document.getElementById('new-history-modal-header'),
        newHistoryModalCloseBtn: document.getElementById('new-history-modal-close-btn'),
        newHistoryTitle: document.getElementById('new-history-title'),
        newHistoryList: document.getElementById('new-history-list'),
        helpModalBackdrop: document.getElementById('help-modal-backdrop'),
        helpModal: document.getElementById('help-modal'),
        helpModalCloseBtn: document.getElementById('help-modal-close-btn'),
        helpPageCloseBtn: document.getElementById('help-page-close-btn'),
        helpModalOkBtn: document.getElementById('help-modal-ok-btn'),
        
        // MD导入弹窗元素
        mdConvertModalBackdrop: document.getElementById('md-convert-modal-backdrop'),
        mdConvertModal: document.getElementById('md-convert-modal'),
        mdConvertModalCloseBtn: document.getElementById('md-convert-modal-close-btn'),
        mdInputTextarea: document.getElementById('md-input-textarea'),
        mdConvertCancelBtn: document.getElementById('md-convert-cancel-btn'),
        mdConvertConfirmBtn: document.getElementById('md-convert-confirm-btn'),
        
        // 自定义确认对话框元素
        customConfirmModalBackdrop: document.getElementById('custom-confirm-modal-backdrop'),
        customConfirmModal: document.getElementById('custom-confirm-modal'),
        customConfirmModalCloseBtn: document.getElementById('custom-confirm-modal-close-btn'),
        customConfirmMessage: document.getElementById('custom-confirm-message'),
        customConfirmCancelBtn: document.getElementById('custom-confirm-cancel-btn'),
        customConfirmOkBtn: document.getElementById('custom-confirm-ok-btn'),
        
        // Markdown导入确认对话框元素
        markdownImportModalBackdrop: document.getElementById('markdown-import-modal-backdrop'),
        markdownImportModal: document.getElementById('markdown-import-modal'),
        markdownImportModalCloseBtn: document.getElementById('markdown-import-modal-close-btn'),
        markdownImportMessage: document.getElementById('markdown-import-message'),
        markdownImportCancelBtn: document.getElementById('markdown-import-cancel-btn'),
        markdownImportTextBtn: document.getElementById('markdown-import-text-btn'),
        markdownImportMindmapBtn: document.getElementById('markdown-import-mindmap-btn'),
        
        searchBox: document.getElementById('search-box'),
        searchBtn: document.getElementById('search-btn'),
        searchClearBtn: document.getElementById('search-clear-btn'),
        searchScopeToggle: document.getElementById('search-scope-toggle'),
        searchGroupToggle: document.getElementById('search-group-toggle'),
        searchCount: document.getElementById('search-count'),
        searchPrevBtn: document.getElementById('search-prev-btn'),
        searchNextBtn: document.getElementById('search-next-btn'),
        themeSwitcherBtn: document.getElementById('theme-switcher-btn'),
        themeDropdown: document.getElementById('theme-dropdown'),
        
        // Node Set Navigation elements
        nodeSetNavigation: document.getElementById('nodeset-navigation'),
        breadcrumbContainer: document.querySelector('.breadcrumb-container'),
        
        // 自动保存相关元素
        autoSaveToggleBtn: document.getElementById('auto-save-toggle-btn'),
        
        // 实时备份相关元素
        realtimeBackupToggleBtn: document.getElementById('realtime-backup-toggle-btn'),
    };
    const ctx = dom.canvas.getContext('2d');
    
    // 高DPI支持变量
    let devicePixelRatio = window.devicePixelRatio || 1;
    let canvasScale = 1;
    
    // 文字渲染缓存
    let textLineCache = new Map();

    // ===================================================================================
    // State Management
    // ===================================================================================
    let state = {
        nodes: [],
        groups: [],
        magneticGroups: [],
        view: { panX: 0, panY: 0, zoom: 1 },
        interaction: {
            isPanning: false, isDragging: false, isMarquee: false, isResizingGroup: false, isResizingNode: false, isMerging: false,
            dragStart: { x: 0, y: 0 },
            lastMousePos: { x: 0, y: 0 },
            contextMenuPos: { x: 0, y: 0 },
            marqueeRect: null,
            dragOffsets: new Map(),
            draggedItems: [],
            mergingItems: [],
            magneticCluster: new Set(),
            resizeGroup: null,
            resizeNode: null,
            resizeEdge: null,
            searchResults: [],
            searchIndex: -1,
            searchScope: 'current', // 'current' for current level, 'global' for all levels
            searchGroups: false, // 是否搜索组，默认关闭
            isNavigatingResults: false, // 是否正在导航搜索结果
            // 输入法状态
            isComposing: false, // 是否正在进行输入法输入（拼音等）
            // 插入模式相关状态
            insertTarget: null, // 当前插入目标节点
            insertDirection: null, // 插入方向：'top', 'bottom', 'left', 'right'
            insertHighlightRegions: [], // 高亮区域数组
            // 触摸交互状态
            touch: {
                isActive: false,                    // 是否有触摸交互
                touches: new Map(),                 // 当前触摸点 Map<touchId, touchInfo>
                startTime: 0,                       // 触摸开始时间
                startPositions: new Map(),          // 触摸起始位置 Map<touchId, {x, y}>
                lastPositions: new Map(),           // 上次触摸位置 Map<touchId, {x, y}>
                gestureType: null,                  // 当前手势类型
                gestureState: 'idle',               // 手势状态: idle, detecting, active
                longPressTimer: null,               // 长按定时器
                longPressTriggered: false,          // 长按是否已触发
                doubleTapTimer: null,               // 双击定时器
                lastTapTime: 0,                     // 上次点击时间
                lastTapPosition: null,              // 上次点击位置
                initialDistance: 0,                 // 双指初始距离
                initialZoom: 1,                     // 双指缩放初始zoom值
                initialCenter: null,                // 双指初始中心点
                dragThreshold: 5,                   // 拖拽阈值(px)
                longPressThreshold: 300,            // 长按阈值(ms)
                doubleTapThreshold: 300,            // 双击间隔阈值(ms)
                preventContextMenu: false,          // 是否阻止右键菜单
                hitItem: null,                      // 触摸命中的项目
                marqueeInitialSelection: null,      // 框选初始选择状态
                progressIndicator: null,            // 长按进度指示器
                resizeEdge: null,                   // 触摸的节点边缘方向
            }
        },
        editingItem: null,
        // 编辑相关的监听器
        realtimeUpdateHandler: null,
        shiftEnterHandler: null,
        // 动画相关
        animation: {
            time: 0, // 动画时间
            breathingNodes: new Set(), // 呼吸灯节点集合
            isPaused: false, // 动画是否暂停
            lastInteractionTime: Date.now(), // 最后交互时间
            pauseTimeout: 5 * 60 * 1000 // 5分钟无操作后暂停动画
        },
        settings: {
            showGrid: true,
            snapToGrid: true,
            magneticNodes: false,
            collisionDetection: true,
            pushMode: false,
            insertMode: false,
            gridSize: 20,
            gridColor: 'rgba(255, 255, 255, 0.08)',
            nodeMargin: 10,
            snapShortcut: '',
            magneticShortcut: '',
            collisionShortcut: '',
            pushShortcut: '',
            insertShortcut: 'i',
            focusShortcut: 'space',
            currentThemeName: "默认主题",
            themeColors: null, // To store current theme UI colors
            // 自动保存设置
            autoSaveEnabled: false,
            autoSaveInterval: 5 * 60 * 1000, // 5分钟
            realtimeBackupInterval: 1000, // 1秒
            // 实时备份设置
            realtimeBackupEnabled: false
        },
        // 节点集导航状态
        nodeSetNavigation: {
            currentNodeSetId: null,     // 当前所在的节点集ID，null表示在根层级
            navigationPath: [],         // 导航路径，存储节点集ID的数组
            viewStack: []              // 视图状态栈，用于保存每个层级的视图状态
        },
        isDirty: true 
    };



    let history = [];
    let historyIndex = -1;
    const HISTORY_LIMIT = 30; // 减少历史记录数量从100到30
    
    // 上次保存的节点ID集合，用于增量保存
    let lastSavedNodeIds = new Set();
    let lastSavedState = { nodes: [], groups: [] };
    let lastAPressTime = 0;
    let styleClipboard = { nodeStyle: null, groupStyle: null }; // For copy/paste style

    let lastMousePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

    // 自动保存相关变量
    let autoSaveTimer = null;
        let realtimeBackupTimer = null;
        let realtimeJsonSaveTimer = null;
    let autoSaveFileIndex = 0; // 当前保存文件索引 (0-4)
    let autoSaveDB = null; // IndexedDB 实例

    function setStateDirty() {
        state.isDirty = true;
        // 当状态变为脏时，自动保存到localStorage
        // 添加延迟以避免频繁保存
        if (window.saveTimeout) {
            clearTimeout(window.saveTimeout);
        }
        window.saveTimeout = setTimeout(saveToLocalStorage, 1000); // 1秒后自动保存
    }

    // ===================================================================================
    // Utility Functions
    // ===================================================================================
    const utils = {
        generateId: () => `id_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        screenToWorld: (x, y) => {
            // 获取画布相对于页面的偏移量
            const rect = dom.canvas.getBoundingClientRect();
            // 先转换为画布坐标，再转换为世界坐标
            const canvasX = x - rect.left;
            const canvasY = y - rect.top;
            return { 
                x: (canvasX - state.view.panX) / state.view.zoom, 
                y: (canvasY - state.view.panY) / state.view.zoom 
            };
        },
        worldToScreen: (x, y) => {
            // 获取画布相对于页面的偏移量
            const rect = dom.canvas.getBoundingClientRect();
            // 先转换为画布坐标，再加上画布的偏移量
            const canvasX = x * state.view.zoom + state.view.panX;
            const canvasY = y * state.view.zoom + state.view.panY;
            return { 
                x: canvasX + rect.left, 
                y: canvasY + rect.top 
            };
        },
        isPointInNode: (x, y, node) => (x > node.x && x < node.x + node.width && y > node.y && y < node.y + node.height),
        isPointInNodeEdge: (x, y, node, threshold = 5) => {
            if (node.type === 'imageNode' && node.isSelected) {
                const inBottomRight = x > node.x + node.width - threshold && x < node.x + node.width + threshold && y > node.y + node.height - threshold && y < node.y + node.height + threshold;
                if (inBottomRight) return 'bottom-right';
            } else if (node.type !== 'imageNode' && node.isSelected) {
                // 右侧调节手柄
                const inRightEdge = x > node.x + node.width - threshold && x < node.x + node.width + threshold && y > node.y && y < node.y + node.height;
                if (inRightEdge) return 'right';
                
                // 左侧调节手柄
                const inLeftEdge = x > node.x - threshold && x < node.x + threshold && y > node.y && y < node.y + node.height;
                if (inLeftEdge) return 'left';
                
                // 上侧调节手柄
                const inTopEdge = x > node.x && x < node.x + node.width && y > node.y - threshold && y < node.y + threshold;
                if (inTopEdge) return 'top';
                
                // 下侧调节手柄
                const inBottomEdge = x > node.x && x < node.x + node.width && y > node.y + node.height - threshold && y < node.y + node.height + threshold;
                if (inBottomEdge) return 'bottom';
            }
            return null;
        },
        isPointInGroupTitle: (x, y, group) => group.titleBar && (x > group.titleBar.x && x < group.titleBar.x + group.titleBar.width && y > group.titleBar.y && y < group.titleBar.y + group.titleBar.height),
        isPointInGroupResizeHandle: (x, y, group) => group.resizeHandle && (x > group.resizeHandle.x && x < group.resizeHandle.x + group.resizeHandle.size && y > group.resizeHandle.y && y < group.resizeHandle.y + group.resizeHandle.size),
        hexToRgba: (hex, alpha) => { 
            if (!hex || hex.length < 4) hex = '#000000'; // Fallback for invalid hex
            const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16); 
            return `rgba(${r}, ${g}, ${b}, ${alpha})`; 
        },
        colorToRgba: (color, alpha) => {
            if (!color) return `rgba(0, 0, 0, ${alpha})`;
            
            // Handle HSL format
            if (color.startsWith('hsl(')) {
                // Extract HSL values
                const hslMatch = color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (hslMatch) {
                    const h = parseInt(hslMatch[1]);
                    const s = parseInt(hslMatch[2]);
                    const l = parseInt(hslMatch[3]);
                    
                    // Convert HSL to RGB
                    const hNorm = h / 360;
                    const sNorm = s / 100;
                    const lNorm = l / 100;
                    
                    const a = sNorm * Math.min(lNorm, 1 - lNorm);
                    const f = n => {
                        const k = (n + hNorm / (1/12)) % 12;
                        return lNorm - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                    };
                    
                    const r = Math.round(f(0) * 255);
                    const g = Math.round(f(8) * 255);
                    const b = Math.round(f(4) * 255);
                    
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }
            }
            
            // Handle hex format
            if (color.startsWith('#')) {
                return utils.hexToRgba(color, alpha);
            }
            
            // Handle rgb/rgba format - just add alpha
            if (color.startsWith('rgb(')) {
                const rgbMatch = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (rgbMatch) {
                    return `rgba(${rgbMatch[1]}, ${rgbMatch[2]}, ${rgbMatch[3]}, ${alpha})`;
                }
            }
            
            // Fallback
            return `rgba(0, 0, 0, ${alpha})`;
        },
        snap: val => state.settings.snapToGrid ? Math.round(val / state.settings.gridSize) * state.settings.gridSize : val,
        checkOverlap: (rectA, rectB) => (rectA.x < rectB.x + rectB.width && rectA.x + rectA.width > rectB.x && rectA.y < rectB.y + rectB.height && rectA.y + rectA.height > rectB.y),
        checkGroupTitleOverlap: (marqueeRegion, group) => {
            if (!group.titleBar) return false;
            return utils.checkOverlap(marqueeRegion, group.titleBar);
        },
        getFontSize: (fontString) => {
            if (!fontString) return 16; // Default font size
            const match = fontString.match(/(\d+)\s*px/);
            return match ? parseInt(match[1], 10) : 16;
        },
        getWrappedTextLines: (text, maxWidth, fontSize = 16) => {
            ctx.font = `bold ${fontSize}px sans-serif`; // 使用实际字体大小
            
            // 检查text是否为undefined或null
            if (!text || typeof text !== 'string') {
                return [''];
            }
            
            // First split by manual line breaks (\n)
            const manualLines = text.split('\n');
            const allLines = [];
            
            for (const manualLine of manualLines) {
                if (manualLine === '') {
                    allLines.push(''); // Preserve empty lines
                    continue;
                }
                
                // 使用智能换行算法，直接传递像素宽度
            const wrappedLines = utils.smartWrapLine(manualLine, maxWidth, fontSize);
                allLines.push(...wrappedLines);
            }
            
            return allLines.length > 0 ? allLines : [''];
        },
        
        smartWrapLine: (line, maxWidth, fontSize = 16) => {
            if (!line || line.trim() === '') return [''];
            
            // 使用精确的文本宽度测量
            ctx.font = `bold ${fontSize}px sans-serif`;
            
            const lines = [];
            let currentLine = '';
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const testLine = currentLine + char;
                const testWidth = ctx.measureText(testLine).width;
                
                // 检查是否需要换行
                if (testWidth > maxWidth && currentLine !== '') {
                    lines.push(currentLine);
                    currentLine = char;
                } else {
                    currentLine = testLine;
                }
            }
            
            if (currentLine !== '') {
                lines.push(currentLine);
            }
            
            return lines.length > 0 ? lines : [''];
        },
        getTextRequiredWidth: (text, font = 'bold 16px sans-serif') => {
            ctx.font = font;
            const lines = text.split('\n');
            let maxRequiredGrids = 0;
            
            for (const line of lines) {
                let requiredGrids = utils.calculateTextGridWidth(line);
                maxRequiredGrids = Math.max(maxRequiredGrids, requiredGrids);
            }
            
            // 最小宽度为2个网格
            const finalGrids = Math.max(2, maxRequiredGrids);
            return finalGrids * state.settings.gridSize;
        },
        
        calculateTextGridWidth: (text) => {
            if (!text || text.trim() === '') return 2; // 空文本最小2网格
            
            // 使用Canvas精确测量文本宽度
            ctx.font = 'bold 16px sans-serif';
            const actualWidth = ctx.measureText(text).width;
            
            // 新规则：字符左右两侧最少保持12px宽度（总共24px padding）
            const requiredPadding = 24; // 左右各12px
            
            // 计算所需的总宽度
            const totalRequiredWidth = actualWidth + requiredPadding;
            
            // 计算需要多少个网格
            const requiredGrids = Math.ceil(totalRequiredWidth / state.settings.gridSize);
            
            // 确保最小宽度为2个网格
            return Math.max(2, requiredGrids);
        },
        checkShortcut: (event, shortcut) => {
            if (!shortcut || shortcut.trim() === '') return false;
            
            if (shortcut.toLowerCase() === 'space' && event.key === ' ') return true;
            if (shortcut.toLowerCase() === 'space') return false; 

            const keys = shortcut.toLowerCase().split('+').map(k => k.trim());
            const mainKey = keys.find(k => !['ctrl', 'control', 'shift', 'alt'].includes(k));
            if (!mainKey) return false;
            const ctrlMatch = (keys.includes('ctrl') || keys.includes('control')) ? (event.ctrlKey || event.metaKey) : !(event.ctrlKey || event.metaKey);
            const shiftMatch = keys.includes('shift') ? event.shiftKey : !event.shiftKey;
            const altMatch = keys.includes('alt') ? event.altKey : !event.altKey;
            const keyMatch = event.key.toLowerCase() === mainKey.toLowerCase();
            return ctrlMatch && shiftMatch && altMatch && keyMatch;
        },
        adjustColorBrightness: (hexColor, factor) => {
            // 将十六进制颜色转换为RGB，然后调整亮度
            if (!hexColor || hexColor.length < 4) hexColor = '#000000';
            
            // 移除#号
            const hex = hexColor.replace('#', '');
            
            // 解析RGB值
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            // 调整亮度（factor为0.5表示50%明度）
            const adjustedR = Math.round(r * factor);
            const adjustedG = Math.round(g * factor);
            const adjustedB = Math.round(b * factor);
            
            // 确保值在0-255范围内
            const clampedR = Math.max(0, Math.min(255, adjustedR));
            const clampedG = Math.max(0, Math.min(255, adjustedG));
            const clampedB = Math.max(0, Math.min(255, adjustedB));
            
            // 转换回十六进制
            const toHex = (value) => value.toString(16).padStart(2, '0');
            return `#${toHex(clampedR)}${toHex(clampedG)}${toHex(clampedB)}`;
        },
        
        // 检测文字是否会在给定宽度下溢出
        isTextOverflowing: (text, width, font = 'bold 16px sans-serif') => {
            if (!text || text.trim() === '') return false;
            
            // 计算文字在给定宽度下需要的行数
            const lines = utils.getWrappedTextLines(text, width);
            
            // 计算当前节点高度能容纳的行数
            const lineHeight = 20; // 行高
            const padding = 10; // 上下内边距
            const currentHeight = width; // 这里应该传入当前节点高度，暂时用宽度代替
            const maxLines = Math.floor((currentHeight - padding * 2) / lineHeight);
            
            // 如果需要的行数超过能容纳的行数，则表示溢出
            return lines.length > maxLines;
        },
        
        // 计算文字在给定宽度下需要的最小高度
        getRequiredHeightForText: (text, width, font = 'bold 16px sans-serif') => {
            if (!text || text.trim() === '') {
                // 空文本最小2个网格高度
                return state.settings.gridSize * 2;
            }
            
            // 获取文本在指定宽度下的行数（考虑12px左右padding）
            const lines = utils.getWrappedTextLines(text, width - 24); // 24px是左右各12px的padding
            
            // 优化规则：对于包含手动换行的文本，使用较小的额外网格系数，使节点更接近正方形
            // 检测文本是否包含手动换行符
            const hasManualLineBreaks = text.includes('\n');
            
            // 对于有手动换行的文本：n行文字 = n+0.5个网格高度
            // 对于自动换行的文本：保持原规则 n行文字 = n+1个网格高度
            const extraGridFactor = hasManualLineBreaks ? 0.5 : 1;
            const requiredGrids = lines.length + extraGridFactor;
            
            // 确保最小高度为2个网格
            const finalGrids = Math.max(2, Math.ceil(requiredGrids));
            
            return finalGrids * state.settings.gridSize;
        }
    };
    
    // ===================================================================================
    // Status Block Functions
    // ===================================================================================
    // 状态块颜色定义
    const statusColors = [
        { status: '未开始', color: 'hsl(0, 2%, 45%)' }, // 浅灰色
        { status: '进行中', color: 'hsl(212, 50%, 35%)' }, // 浅蓝色
        { status: '已完成', color: 'hsl(132, 53%, 37%)' }, // 浅绿色
        { status: '已阻塞', color: 'hsl(0, 39%, 46%)' }, // 浅红色
        { status: '已暂停', color: 'hsl(46, 79%, 36%)' }, // 浅黄色
        { status: '已取消', color: 'hsl(218, 0%, 0%)' }, // 黑色
        { status: '特殊态', color: 'hsl(261, 72%, 60%)' }  // 浅紫色
    ];
    
    // 添加状态块
    function addStatusBlock(targetNode, direction) {
        // 检查目标节点是否已经有状态块
        const existingStatusBlock = state.nodes.find(node => 
            node.isStatusBlock && node.targetNodeId === targetNode.id && node.position === direction
        );
        
        if (existingStatusBlock) {
            // 如果已经有相同位置的状态块，则切换其状态
            existingStatusBlock.statusIndex = (existingStatusBlock.statusIndex + 1) % statusColors.length;
            existingStatusBlock.backgroundColor = statusColors[existingStatusBlock.statusIndex].color;
            existingStatusBlock.text = statusColors[existingStatusBlock.statusIndex].status; // 更新状态文字
            existingStatusBlock.color = 'rgba(255, 255, 255, 0.7)'; // 70%亮度的白色
            existingStatusBlock.font = 'bold 10px sans-serif'; // 确保使用小字体
            existingStatusBlock.textLines = null; // 清除文本行缓存，确保重新计算文字行
            saveState('切换状态块状态');
            setStateDirty();
            return;
        }
        
        // 创建新的状态块
        const gridSize = state.settings.gridSize;
        let statusBlock;
        
        // 根据方向设置状态块的位置和大小
        switch (direction) {
            case 'top':
                statusBlock = createNode(
                    targetNode.x,
                    targetNode.y - gridSize,
                    '', // 空文本
                    'node'
                );
                statusBlock.width = targetNode.width;
                statusBlock.height = gridSize; // 设置为完整网格高度
                break;
            case 'bottom':
                statusBlock = createNode(
                    targetNode.x,
                    targetNode.y + targetNode.height,
                    '', // 空文本
                    'node'
                );
                statusBlock.width = targetNode.width;
                statusBlock.height = gridSize; // 设置为完整网格高度
                break;
            case 'left':
                statusBlock = createNode(
                    targetNode.x - gridSize,
                    targetNode.y,
                    '', // 空文本
                    'node'
                );
                statusBlock.width = gridSize; // 设置为完整网格宽度
                statusBlock.height = targetNode.height;
                break;
            case 'right':
                statusBlock = createNode(
                    targetNode.x + targetNode.width,
                    targetNode.y,
                    '', // 空文本
                    'node'
                );
                statusBlock.width = gridSize; // 设置为完整网格宽度
                statusBlock.height = targetNode.height;
                break;
        }
        
        // 设置状态块属性
        statusBlock.isStatusBlock = true;
        statusBlock.targetNodeId = targetNode.id;
        statusBlock.position = direction;
        statusBlock.statusIndex = 0; // 默认使用第一个状态（未开始）
        statusBlock.backgroundColor = statusColors[0].color;
        statusBlock.hasCustomStyle = true; // 标记为自定义样式，不受主题影响
        
        // 设置状态文字并居中显示
        statusBlock.text = statusColors[0].status; // 设置状态文字
        statusBlock.textAlign = 'center'; // 文字水平居中
        statusBlock.textVerticalAlign = 'middle'; // 文字垂直居中
        statusBlock.font = 'bold 10px sans-serif'; // 设置更小的字体大小以确保显示
        statusBlock.textLines = null; // 清除文本行缓存，确保重新计算文字行
        
        // 计算相反色作为描边颜色和文字颜色
        const currentTheme = activeTheme || state.themes.default;
        const canvasBgColor = currentTheme.colors.canvasBg;
        statusBlock.strokeColor = getContrastingColor(canvasBgColor);
        statusBlock.strokeWidth = 1;
        statusBlock.color = 'rgba(255, 255, 255, 0.7)'; // 70%亮度的白色
        
        // 保存历史记录
        saveState('添加状态块');
        setStateDirty();
        updateStatusBlocks(); // 实时更新状态块大小和位置
    }
    
    // 删除状态块
    function removeStatusBlock(node) {
        // 如果点击的是状态块本身，找到其目标节点
        let targetNodeId;
        if (node.isStatusBlock) {
            targetNodeId = node.targetNodeId;
            // 删除该状态块
            state.nodes = state.nodes.filter(n => n !== node);
        } else {
            // 如果点击的是目标节点，删除所有与其关联的状态块
            state.nodes = state.nodes.filter(n => !(n.isStatusBlock && n.targetNodeId === node.id));
        }
        
        saveState('删除状态块');
        setStateDirty();
        updateStatusBlocks(); // 实时更新状态块大小和位置
    }
    
    // 获取与颜色相反的颜色
    function getContrastingColor(color) {
        // 简单实现：如果是深色背景，返回白色；如果是浅色背景，返回黑色
        // 更复杂的实现可以基于颜色亮度计算
        if (!color || color === 'transparent') return '#000000';
        
        // 解析颜色
        let r, g, b;
        if (color.startsWith('#')) {
            // 处理HEX颜色
            if (color.length === 7) {
                r = parseInt(color.slice(1, 3), 16);
                g = parseInt(color.slice(3, 5), 16);
                b = parseInt(color.slice(5, 7), 16);
            } else if (color.length === 4) {
                r = parseInt(color.slice(1, 2), 16) * 17;
                g = parseInt(color.slice(2, 3), 16) * 17;
                b = parseInt(color.slice(3, 4), 16) * 17;
            }
        } else if (color.startsWith('rgb')) {
            // 处理RGB/RGBA颜色
            const rgbMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (rgbMatch) {
                r = parseInt(rgbMatch[1]);
                g = parseInt(rgbMatch[2]);
                b = parseInt(rgbMatch[3]);
            }
        }
        
        // 计算亮度
        if (r !== undefined && g !== undefined && b !== undefined) {
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            return brightness > 125 ? '#000000' : '#ffffff';
        }
        
        return '#000000'; // 默认返回黑色
    }
    
    // 更新所有状态块的位置和大小
    function updateStatusBlocks() {
        state.nodes.forEach(node => {
            if (node.isStatusBlock && node.targetNodeId) {
                const targetNode = state.nodes.find(n => n.id === node.targetNodeId);
                if (targetNode) {
                    const gridSize = state.settings.gridSize;
                    
                    // 根据方向更新位置和大小，与addStatusBlock保持一致
                    switch (node.position) {
                        case 'top':
                            node.x = targetNode.x;
                            node.y = targetNode.y - gridSize;
                            node.width = targetNode.width;
                            node.height = gridSize;
                            break;
                        case 'bottom':
                            node.x = targetNode.x;
                            node.y = targetNode.y + targetNode.height;
                            node.width = targetNode.width;
                            node.height = gridSize;
                            break;
                        case 'left':
                            node.x = targetNode.x - gridSize;
                            node.y = targetNode.y;
                            node.width = gridSize;
                            node.height = targetNode.height;
                            break;
                        case 'right':
                            node.x = targetNode.x + targetNode.width;
                            node.y = targetNode.y;
                            node.width = gridSize;
                            node.height = targetNode.height;
                            break;
                    }
                }
            }
        });
    }
    
    // ===================================================================================
    // History (Undo/Redo)
    // ===================================================================================
    function saveState(actionDescription = '未知操作') {
        history.splice(historyIndex + 1);
        
        // 获取当前所有节点ID
        const currentNodeIds = new Set(state.nodes.map(n => n.id));
        
        // 初始化lastSavedNodeIds（首次运行时）
        if (lastSavedNodeIds.size === 0 && lastSavedState.nodes.length === 0 && state.nodes.length > 0) {
            lastSavedNodeIds = new Set(state.nodes.map(n => n.id));
            lastSavedState = {
                nodes: JSON.parse(JSON.stringify(state.nodes)),
                groups: JSON.parse(JSON.stringify(state.groups))
            };
        }
        
        // 确定变更的节点（新添加或修改的节点）
        const changedNodeIds = new Set();
        
        // 添加新节点
        [...currentNodeIds].filter(id => !lastSavedNodeIds.has(id)).forEach(id => {
            changedNodeIds.add(id);
        });
        
        // 检测修改的节点（简化版本）
        if (lastSavedState.nodes.length > 0) {
            state.nodes.forEach(node => {
                if (lastSavedNodeIds.has(node.id)) {
                    const lastNode = lastSavedState.nodes.find(n => n.id === node.id);
                    if (lastNode && (
                        node.x !== lastNode.x || node.y !== lastNode.y || 
                        node.width !== lastNode.width || node.height !== lastNode.height ||
                        node.text !== lastNode.text || node.backgroundColor !== lastNode.backgroundColor ||
                        node.color !== lastNode.color || node.groupId !== lastNode.groupId
                    )) {
                        changedNodeIds.add(node.id);
                    }
                }
            });
        }
        
        // 增量保存：只保存变更的节点
        const changedNodes = state.nodes.filter(n => changedNodeIds.has(n.id));
        
        // 准备保存的状态对象
        const stateToSave = {
            // 只保存变更的节点
            changedNodes: changedNodes.map(n => serializeNode(n)),
            // 记录新增和删除的节点ID
            addedNodeIds: [...currentNodeIds].filter(id => !lastSavedNodeIds.has(id)),
            removedNodeIds: [...lastSavedNodeIds].filter(id => !currentNodeIds.has(id)),
            
            // 基本信息
            action: actionDescription,
            timestamp: new Date().toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' })
        };
        
        // 只有当groups有变更或首次保存时才保存groups
        let groupsChanged = false;
        if (state.groups.length !== lastSavedState.groups.length) {
            groupsChanged = true;
        } else {
            // 检查组是否有变更
            for (let i = 0; i < state.groups.length; i++) {
                const group = state.groups[i];
                const lastGroup = lastSavedState.groups.find(g => g.id === group.id);
                if (!lastGroup || 
                    group.x !== lastGroup.x || group.y !== lastGroup.y ||
                    group.width !== lastGroup.width || group.height !== lastGroup.height ||
                    group.title !== lastGroup.title || JSON.stringify(group.nodeIds) !== JSON.stringify(lastGroup.nodeIds)) {
                    groupsChanged = true;
                    break;
                }
            }
        }
        
        if (groupsChanged || lastSavedState.groups.length === 0) {
            stateToSave.groups = state.groups.map(g => serializeGroup(g));
        }
        
        // 只有当nodeSetNavigation有变更时才保存
        if (state.nodeSetNavigation && Object.keys(state.nodeSetNavigation).length > 0) {
            stateToSave.nodeSetNavigation = {...state.nodeSetNavigation};
        }
        
        // 优化JSON序列化，过滤空值
        const serializedState = JSON.stringify(stateToSave, (key, value) => {
            if (Array.isArray(value) && value.length === 0) return undefined;
            if (value === undefined) return undefined;
            return value;
        });
        
        history.push(serializedState);
        
        // 更新上次保存的状态
        lastSavedNodeIds = new Set(currentNodeIds);
        lastSavedState = {
            nodes: JSON.parse(JSON.stringify(state.nodes)),
            groups: JSON.parse(JSON.stringify(state.groups))
        };

        // 限制历史记录长度为100条
        if (history.length > 100) {
            history.shift();
        }
        historyIndex = history.length - 1;
        
        // 如果历史记录面板正在显示，立即更新内容
        if (dom.newHistoryModal && dom.newHistoryModal.style.display === 'block') {
            generateNewHistoryList();
            selectedHistoryIndex = historyIndex; // 更新选中的历史记录索引
            updateHistorySelection();
        }
    }

    function undo() {
        if (historyIndex > 0) {
            historyIndex--;
            loadState(history[historyIndex]);
            
            // 如果历史记录面板是打开的，更新面板显示
            if (dom.newHistoryModal && dom.newHistoryModal.style.display === 'block') {
                generateNewHistoryList();
                selectedHistoryIndex = historyIndex;
                updateHistorySelection();
            }
        }
    }

    function redo() {
        if (historyIndex < history.length - 1) {
            historyIndex++;
            loadState(history[historyIndex]);
            
            // 如果历史记录面板是打开的，更新面板显示
            if (dom.newHistoryModal && dom.newHistoryModal.style.display === 'block') {
                generateNewHistoryList();
                selectedHistoryIndex = historyIndex;
                updateHistorySelection();
            }
        }
    }

    function loadState(jsonState) {
        const restoredState = JSON.parse(jsonState);
        
        // 检查是否是新的增量保存格式
        if (restoredState.changedNodes !== undefined) {
            // 增量保存格式处理
            if (restoredState.removedNodeIds && restoredState.removedNodeIds.length > 0) {
                // 移除已删除的节点
                const removedIds = new Set(restoredState.removedNodeIds);
                state.nodes = state.nodes.filter(node => !removedIds.has(node.id));
            }
            
            // 添加新节点或更新修改的节点
            if (restoredState.changedNodes && restoredState.changedNodes.length > 0) {
                const changedNodesMap = new Map();
                restoredState.changedNodes.forEach(nodeData => {
                    changedNodesMap.set(nodeData.id, nodeData);
                });
                
                // 更新现有节点或添加新节点
                const newNodes = [];
                state.nodes.forEach(node => {
                    if (changedNodesMap.has(node.id)) {
                        // 更新现有节点
                        const updatedNode = deserializeNode(changedNodesMap.get(node.id));
                        newNodes.push(updatedNode);
                        changedNodesMap.delete(node.id);
                    } else {
                        newNodes.push(node);
                    }
                });
                
                // 添加剩余的新节点
                changedNodesMap.forEach(nodeData => {
                    newNodes.push(deserializeNode(nodeData));
                });
                
                state.nodes = newNodes;
            }
            
            // 处理groups
            if (restoredState.groups) {
                state.groups = restoredState.groups.map(g => deserializeGroup(g));
            }
        } else if (restoredState.nodes) {
            // 旧格式处理（向后兼容）
            state.nodes = restoredState.nodes.map(n => deserializeNode(n));
            state.groups = restoredState.groups ? restoredState.groups.map(g => deserializeGroup(g)) : [];
        }
        
        // Restore node set navigation state if it exists
        if (restoredState.nodeSetNavigation) {
            state.nodeSetNavigation = {...restoredState.nodeSetNavigation};
            updateBreadcrumbNavigation();
        }
        
        // Restore theme if it exists
        if (restoredState.activeTheme) {
            activeTheme = {...restoredState.activeTheme};
            state.settings.currentThemeName = activeTheme.name;
            applyTheme(activeTheme, false, true); // skipHistory = true to avoid creating new history entry
        }
        
        // 更新历史记录状态
        updateLastSavedState();
        
        updateCanvasCountInfo();
        updateCanvasSelectionInfo();
        updateStatusBlocks(); // 确保状态块位置和尺寸正确
        setStateDirty();
    }
    
    // 更新上次保存的状态
    function updateLastSavedState() {
        lastSavedNodeIds = new Set(state.nodes.map(n => n.id));
        lastSavedState = {
            nodes: JSON.parse(JSON.stringify(state.nodes)),
            groups: JSON.parse(JSON.stringify(state.groups))
        };
    }

    // ===================================================================================
    // New History Modal Functions
    // ===================================================================================
    let selectedHistoryIndex = -1;
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };
    
    function showNewHistoryModal() {
        generateNewHistoryList();
        dom.newHistoryModal.style.display = 'block';
        
        // Center the modal panel initially
        const modalContent = dom.newHistoryModalContent;
        modalContent.style.transform = 'translate(-50%, -50%)';
        modalContent.style.left = '50%';
        modalContent.style.top = '50%';
        modalContent.style.position = 'fixed';
        
        selectedHistoryIndex = historyIndex; // Set current history as selected
        updateHistorySelection();
        
        // Focus the modal for keyboard navigation
        dom.newHistoryModal.focus();
    }

    function hideNewHistoryModal() {
        dom.newHistoryModal.style.display = 'none';
        selectedHistoryIndex = -1;
        // Clear any preview state
        clearHistoryPreview();
    }

    function generateHistoryList() {
        dom.historyList.innerHTML = '';
        
        // Get current theme colors
        const themeColors = state.settings.themeColors || {
            menuBarBg: "#1E293B",
            textColor: "#E0E0E0",
            btnActive: "#334155"
        };
        
        // Update history title with statistics and theme colors
        const historyTitle = document.getElementById('history-title');
        if (historyTitle) {
            const maxHistoryLength = 100; // Updated max history length to 100
            historyTitle.textContent = `历史记录（已记录${history.length}条，可记录${maxHistoryLength}条）`;
            historyTitle.style.color = themeColors.textColor;
            historyTitle.style.borderBottomColor = themeColors.btnActive;
        }
        
        // Update history modal background color
        const historyModal = document.getElementById('history-modal');
        if (historyModal) {
            historyModal.style.backgroundColor = themeColors.menuBarBg;
        }
        
        // Set single column layout style for the history list container - PS style with theme colors
        dom.historyList.style.cssText = `
            display: flex;
            flex-direction: column;
            gap: 1px;
            max-height: 400px;
            overflow-y: auto;
            padding: 4px;
            background: ${themeColors.menuBarBg};
            border: 1px solid ${themeColors.btnActive};
            border-radius: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 16px;
        `;
        
        // Reverse the order - newest first
        const reversedHistory = [...history].reverse();
        
        reversedHistory.forEach((historyState, reverseIndex) => {
            const originalIndex = history.length - 1 - reverseIndex;
            const parsedState = JSON.parse(historyState);
            const actionDescription = parsedState.action || '未知操作';
            const timestamp = parsedState.timestamp || '';
            
            const historyItem = document.createElement('div');
            historyItem.style.cssText = `
                display: flex;
                align-items: center;
                padding: 5px 8px;
                cursor: pointer;
                background: ${originalIndex === historyIndex ? themeColors.btnActive : 'transparent'};
                color: ${originalIndex === historyIndex ? themeColors.textColor : themeColors.textColor};
                border: none;
                border-radius: 0;
                transition: background-color 0.1s ease;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                font-size: 16px;
                min-height: 24px;
                line-height: 1.2;
            `;
            
            // Add hover effect - PS style with theme colors
            historyItem.addEventListener('mouseenter', () => {
                if (originalIndex !== historyIndex) {
                    historyItem.style.background = themeColors.btnActive;
                    historyItem.style.opacity = '0.7';
                }
            });
            
            historyItem.addEventListener('mouseleave', () => {
                if (originalIndex !== historyIndex) {
                    historyItem.style.background = 'transparent';
                    historyItem.style.opacity = '1';
                }
            });
            
            // Create number indicator
            const numberIndicator = document.createElement('span');
            numberIndicator.style.cssText = `
                min-width: 30px;
                margin-right: 8px;
                display: inline-block;
                text-align: left;
                font-size: 16px;
                flex-shrink: 0;
                font-weight: bold;
                color: ${themeColors.textColor};
            `;
            numberIndicator.textContent = `${originalIndex + 1}.`;
            
            // Create icon based on action type - PS style
            const icon = document.createElement('span');
            icon.style.cssText = `
                width: 16px;
                height: 16px;
                margin-right: 8px;
                display: inline-block;
                text-align: center;
                font-size: 12px;
                flex-shrink: 0;
                opacity: 0.8;
            `;
            
            // Set icon based on action description
            if (actionDescription.includes('创建')) {
                icon.textContent = '📄';
            } else if (actionDescription.includes('删除')) {
                icon.textContent = '🗑️';
            } else if (actionDescription.includes('移动') || actionDescription.includes('拖拽')) {
                icon.textContent = '↔️';
            } else if (actionDescription.includes('编辑') || actionDescription.includes('修改')) {
                icon.textContent = '✏️';
            } else if (actionDescription.includes('复制')) {
                icon.textContent = '📋';
            } else if (actionDescription.includes('粘贴')) {
                icon.textContent = '📌';
            } else if (actionDescription.includes('组') && actionDescription.includes('创建')) {
                icon.textContent = '📁';
            } else if (actionDescription.includes('加载') || actionDescription.includes('打开')) {
                icon.textContent = '📂';
            } else if (actionDescription.includes('选择')) {
                icon.textContent = '👆';
            } else {
                icon.textContent = '⚙️';
            }
            
            // Create action text - PS style
            const actionText = document.createElement('span');
            actionText.style.cssText = `
                flex: 1;
                color: inherit;
                font-weight: normal;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            `;
            actionText.textContent = actionDescription;
            
            // PS style doesn't need additional current state indicator
            // The blue background already indicates the current state
            
            historyItem.appendChild(numberIndicator);
            historyItem.appendChild(icon);
            historyItem.appendChild(actionText);
            
            // Add click event
            historyItem.addEventListener('click', () => {
                jumpToHistoryState(originalIndex);
                hideHistorySnapshot();
            });
            
            dom.historyList.appendChild(historyItem);
        });
    }

    function generateHistoryPanel() {
        const historyPanel = document.querySelector('.history-panel');
        if (!historyPanel) return;
        
        // Get current theme colors
        const themeColors = state.settings.themeColors || {
            menuBarBg: "#1E293B",
            textColor: "#E0E0E0",
            btnActive: "#334155"
        };
        
        // Clear existing content
        historyPanel.innerHTML = '';
        
        // Create title
        const title = document.createElement('div');
        title.className = 'history-panel-title';
        const maxHistoryLength = 100;
        title.textContent = `历史记录（已记录${history.length}条，可记录${maxHistoryLength}条）`;
        title.style.color = themeColors.textColor;
        title.style.borderBottomColor = themeColors.btnActive;
        historyPanel.appendChild(title);
        
        // Create list container
        const listContainer = document.createElement('div');
        listContainer.className = 'history-panel-list';
        historyPanel.appendChild(listContainer);
        
        // Update panel background color
        historyPanel.style.backgroundColor = themeColors.menuBarBg;
        historyPanel.style.borderColor = themeColors.btnActive;
        
        // Reverse the order - newest first, but limit to last 10 items for hover panel
        const reversedHistory = [...history].reverse().slice(0, 10);
        
        reversedHistory.forEach((historyState, reverseIndex) => {
            const originalIndex = history.length - 1 - reverseIndex;
            const parsedState = JSON.parse(historyState);
            const actionDescription = parsedState.action || '未知操作';
            
            const historyItem = document.createElement('div');
            historyItem.style.cssText = `
                display: flex;
                align-items: center;
                padding: 5px 8px;
                cursor: pointer;
                background: ${originalIndex === historyIndex ? themeColors.btnActive : 'transparent'};
                color: ${themeColors.textColor};
                border: none;
                border-radius: 3px;
                transition: background-color 0.1s ease;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                font-size: 14px;
                min-height: 20px;
                line-height: 1.2;
                margin-bottom: 1px;
            `;
            
            // Add hover effect with improved event handling
            historyItem.addEventListener('mouseenter', (e) => {
                e.stopPropagation();
                if (originalIndex !== historyIndex) {
                    historyItem.style.background = themeColors.btnActive;
                    historyItem.style.opacity = '0.7';
                }
            });
            
            historyItem.addEventListener('mouseleave', (e) => {
                e.stopPropagation();
                if (originalIndex !== historyIndex) {
                    historyItem.style.background = 'transparent';
                    historyItem.style.opacity = '1';
                }
            });
            
            // Create number indicator
            const numberIndicator = document.createElement('span');
            numberIndicator.style.cssText = `
                min-width: 25px;
                margin-right: 6px;
                display: inline-block;
                text-align: left;
                font-size: 14px;
                flex-shrink: 0;
                font-weight: bold;
                color: ${themeColors.textColor};
            `;
            numberIndicator.textContent = `${originalIndex + 1}.`;
            
            // Create action text
            const actionText = document.createElement('span');
            actionText.style.cssText = `
                flex: 1;
                color: inherit;
                font-weight: normal;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            `;
            actionText.textContent = actionDescription;
            
            historyItem.appendChild(numberIndicator);
            historyItem.appendChild(actionText);
            
            // Add click event
            historyItem.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                jumpToHistoryState(originalIndex);
                // Hide the hover panel
                document.querySelector('.history-wrapper').classList.remove('active');
            });
            
            listContainer.appendChild(historyItem);
        });
        
        // Add "查看全部" link if there are more than 10 items
        if (history.length > 10) {
            const viewAllItem = document.createElement('div');
            viewAllItem.style.cssText = `
                display: flex;
                align-items: center;
                padding: 5px 8px;
                cursor: pointer;
                background: transparent;
                color: ${themeColors.textColor};
                border: none;
                border-radius: 3px;
                transition: background-color 0.1s ease;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                font-size: 14px;
                min-height: 20px;
                line-height: 1.2;
                margin-top: 4px;
                border-top: 1px solid ${themeColors.btnActive};
                font-style: italic;
                opacity: 0.8;
            `;
            
            viewAllItem.addEventListener('mouseenter', (e) => {
                e.stopPropagation();
                viewAllItem.style.background = themeColors.btnActive;
                viewAllItem.style.opacity = '1';
            });
            
            viewAllItem.addEventListener('mouseleave', (e) => {
                e.stopPropagation();
                viewAllItem.style.background = 'transparent';
                viewAllItem.style.opacity = '0.8';
            });
            
            viewAllItem.textContent = '查看全部历史记录...';
            
            viewAllItem.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                // Hide hover panel and show full modal
                document.querySelector('.history-wrapper').classList.remove('active');
                showHistorySnapshot();
            });
            
            listContainer.appendChild(viewAllItem);
        }
    }

    function generateNewHistoryList() {
        dom.newHistoryList.innerHTML = '';
        
        // Get current theme colors
        const themeColors = state.settings.themeColors || {
            menuBarBg: "#1E293B",
            textColor: "#E0E0E0",
            btnActive: "#334155"
        };
        
        // Update history title with statistics and theme colors
        const maxHistoryLength = 100;
        dom.newHistoryTitle.textContent = `历史记录（已记录${history.length}条，可记录${maxHistoryLength}条）`;
        dom.newHistoryTitle.style.color = themeColors.textColor;
        
        // Apply theme colors to modal
        if (dom.newHistoryModalContent) {
            dom.newHistoryModalContent.style.backgroundColor = themeColors.menuBarBg;
            dom.newHistoryModalContent.style.borderColor = themeColors.btnActive;
        }
        
        if (dom.newHistoryModalHeader) {
            dom.newHistoryModalHeader.style.backgroundColor = themeColors.btnActive;
            dom.newHistoryModalHeader.style.borderBottomColor = themeColors.btnActive;
        }
        
        if (dom.newHistoryModalCloseBtn) {
            dom.newHistoryModalCloseBtn.style.color = themeColors.textColor;
        }
        
        // Reverse the order - newest first
        const reversedHistory = [...history].reverse();
        
        reversedHistory.forEach((historyState, reverseIndex) => {
            const originalIndex = history.length - 1 - reverseIndex;
            const parsedState = JSON.parse(historyState);
            const actionDescription = parsedState.action || '未知操作';
            
            const historyItem = document.createElement('div');
            historyItem.className = 'new-history-item';
            historyItem.dataset.index = originalIndex;
            
            // Mark current history item
            if (originalIndex === historyIndex) {
                historyItem.classList.add('current');
            }
            
            // Create number indicator
            const numberIndicator = document.createElement('span');
            numberIndicator.className = 'new-history-item-number';
            numberIndicator.textContent = `${originalIndex + 1}.`;
            
            // Create action text
            const actionText = document.createElement('span');
            actionText.className = 'new-history-item-text';
            actionText.textContent = actionDescription;
            
            // Create current indicator as separate element
            const currentIndicator = document.createElement('span');
            currentIndicator.className = 'new-history-item-current';
            currentIndicator.textContent = '(当前)';
            currentIndicator.style.color = '#4CAF50';
            currentIndicator.style.marginLeft = 'auto';
            currentIndicator.style.fontSize = '12px';
            currentIndicator.style.fontWeight = 'bold';
            
            // Create content wrapper for flex layout
            const contentWrapper = document.createElement('div');
            contentWrapper.style.display = 'flex';
            contentWrapper.style.alignItems = 'center';
            contentWrapper.style.width = '100%';
            
            contentWrapper.appendChild(actionText);
            if (originalIndex === historyIndex) {
                contentWrapper.appendChild(currentIndicator);
            }
            
            historyItem.appendChild(numberIndicator);
            historyItem.appendChild(contentWrapper);
            
            // Add click event
            historyItem.addEventListener('click', () => {
                clearHistoryPreview(); // Clear any preview state
                jumpToHistoryState(originalIndex);
                selectedHistoryIndex = originalIndex;
                updateHistorySelection();
                // 不再自动关闭面板，让用户可以连续点击不同的历史记录条目
            });
            
            // Add hover preview event
            historyItem.addEventListener('mouseenter', () => {
                previewHistoryState(originalIndex);
            });
            
            historyItem.addEventListener('mouseleave', () => {
                clearHistoryPreview();
            });
            
            dom.newHistoryList.appendChild(historyItem);
        });
    }

    function jumpToHistoryState(index) {
        if (index >= 0 && index < history.length) {
            historyIndex = index;
            loadState(history[index]);
        }
    }
    
    function updateHistorySelection() {
        const items = dom.newHistoryList.querySelectorAll('.new-history-item');
        items.forEach(item => {
            const index = parseInt(item.dataset.index);
            item.classList.toggle('selected', index === selectedHistoryIndex);
            item.classList.toggle('current', index === historyIndex);
            
            // 更新"(当前)"标注 - 使用新的结构
            const contentWrapper = item.children[1]; // 第二个子元素是contentWrapper
            if (contentWrapper) {
                const existingCurrentIndicator = contentWrapper.querySelector('.new-history-item-current');
                
                if (index === historyIndex) {
                    // 如果是当前项且没有标注，添加标注
                    if (!existingCurrentIndicator) {
                        const currentIndicator = document.createElement('span');
                        currentIndicator.className = 'new-history-item-current';
                        currentIndicator.textContent = '(当前)';
                        currentIndicator.style.color = '#4CAF50';
                        currentIndicator.style.marginLeft = 'auto';
                        currentIndicator.style.fontSize = '12px';
                        currentIndicator.style.fontWeight = 'bold';
                        contentWrapper.appendChild(currentIndicator);
                    }
                } else {
                    // 如果不是当前项但有标注，移除标注
                    if (existingCurrentIndicator) {
                        existingCurrentIndicator.remove();
                    }
                }
            }
        });
    }
    
    function getCurrentState() {
        return {
            nodes: state.nodes.map(n => ({...n})), // Deep copy to preserve selection state
            groups: state.groups.map(g => ({...g})), // Deep copy to preserve selection state
            view: {...state.view},
            nodeSetNavigation: {...state.nodeSetNavigation}
        };
    }
    
    function previewHistoryState(index) {
        if (index >= 0 && index < history.length && index !== historyIndex) {
            // Store current state for restoration (similar to theme preview)
            if (!window.previewBackupState) {
                window.previewBackupState = getCurrentState();
                window.previewBackupHistoryIndex = historyIndex;
            }
            
            // Apply preview state without changing historyIndex (similar to theme preview)
            const previewState = JSON.parse(history[index]);
            // 使用全局的反序列化函数来确保节点和组的颜色正确应用
            state.nodes = previewState.nodes ? previewState.nodes.map(n => deserializeNode(n)) : [];
            state.groups = previewState.groups ? previewState.groups.map(g => deserializeGroup(g)) : [];
            // 不修改view字段，保持当前视图状态不变
            
            if (previewState.nodeSetNavigation) {
                state.nodeSetNavigation = {...previewState.nodeSetNavigation};
                updateBreadcrumbNavigation();
            }
            
            updateCanvasCountInfo();
            updateCanvasSelectionInfo();
            setStateDirty();
        }
    }
    
    function clearHistoryPreview() {
        if (window.previewBackupState) {
            // Restore original state (similar to theme preview restoration)
            // 使用全局的反序列化函数来确保节点和组的颜色正确应用
            state.nodes = window.previewBackupState.nodes ? window.previewBackupState.nodes.map(n => deserializeNode(n)) : [];
            state.groups = window.previewBackupState.groups ? window.previewBackupState.groups.map(g => deserializeGroup(g)) : [];
            // 不恢复view字段，保持当前视图状态不变
            state.nodeSetNavigation = {...window.previewBackupState.nodeSetNavigation};
            
            // Restore original historyIndex
            historyIndex = window.previewBackupHistoryIndex;
            
            updateBreadcrumbNavigation();
            updateCanvasCountInfo();
            updateCanvasSelectionInfo();
            setStateDirty();
            
            // Clear backup
            window.previewBackupState = null;
            window.previewBackupHistoryIndex = null;
        }
    }

    // ===================================================================================
    // Rendering Core
    // ===================================================================================
    // 添加渲染节流控制变量
    let lastRenderTime = 0;
    const MIN_RENDER_INTERVAL = 16; // 约60fps，减少渲染频率以节省内存
    let skipStateCheckCount = 0;
    const STATE_CHECK_INTERVAL = 5; // 每5帧进行一次完整状态检查
    
    function renderLoop(timestamp = 0) {
        // 节流渲染，限制渲染频率
        if (timestamp - lastRenderTime < MIN_RENDER_INTERVAL) {
            requestAnimationFrame(renderLoop);
            return;
        }
        
        const currentTime = Date.now();
        
        // 优化状态一致性检查频率
        skipStateCheckCount++;
        if (skipStateCheckCount >= STATE_CHECK_INTERVAL) {
            skipStateCheckCount = 0;
            
            // 状态一致性检查 - 防止状态卡死
            if ((state.interaction.isDragging || state.interaction.dragPrepared) && 
                (!state.interaction.draggedItems || state.interaction.draggedItems.length === 0 ||
                 (state.interaction.isDragging && !state.interaction.dragStart))) {
                resetInteractionState();
            }
            
            if ((state.interaction.isResizingNode && !state.interaction.resizeNode) ||
                (state.interaction.isResizingGroup && !state.interaction.resizeGroup)) {
                resetInteractionState();
            }
        }
        
        // 检查是否需要暂停动画（5分钟无操作）
        if (!state.animation.isPaused && 
            currentTime - state.animation.lastInteractionTime > state.animation.pauseTimeout) {
            state.animation.isPaused = true;
            // 释放一些内存
            if (state.animation.breathingNodes) {
                state.animation.breathingNodes.clear();
            }
        }
        
        // 如果动画未暂停，更新动画时间
        if (!state.animation.isPaused) {
            state.animation.time = currentTime;
        }
        
        // 优化：快速检查是否需要动画
        let needsAnimation = false;
        if (!state.animation.isPaused) {
            // 快速路径：如果有呼吸节点，直接需要动画
            if (state.animation.breathingNodes && state.animation.breathingNodes.size > 0) {
                needsAnimation = true;
            } else {
                // 只有在没有呼吸节点时才进行更详细的检查
                // 优化：缓存选中状态以减少重复计算
                if (!window._cachedSelectionState || timestamp % 100 === 0) {
                    window._cachedSelectionState = {
                        hasSelectedNodes: state.nodes.some(node => node.isSelected),
                        hasSearchResults: state.nodes.some(node => node.isSearchResult),
                        hasNodeSets: state.nodes.some(node => node.isNodeSet),
                        hasSelectedGroups: state.groups.some(group => group.isSelected)
                    };
                }
                needsAnimation = window._cachedSelectionState.hasSelectedNodes || 
                                window._cachedSelectionState.hasSearchResults || 
                                window._cachedSelectionState.hasNodeSets ||
                                window._cachedSelectionState.hasSelectedGroups;
            }
        }
        
        // 修复移动端编辑时画布内容消失问题
        // 但减少不必要的强制设置dirty
        if (!state.isDirty && state.editingItem && dom.textEditor && 
            dom.textEditor.style.display !== 'none' && 
            (state.animation.isPaused || !needsAnimation)) {
            state.isDirty = true;
        }
        
        // 优化：如果状态变化很小且不需要动画，可以降低渲染频率
        let shouldRender = state.isDirty || needsAnimation;
        if (state.isDirty && !needsAnimation && timestamp % 32 < 16) {
            // 对于简单状态变化，使用30fps渲染
            shouldRender = false;
        }
        
        // 如果有需要动画的元素或者状态发生变化，就渲染画布
        if (shouldRender) {
            try {
                renderCanvas();
                state.isDirty = false;
                lastRenderTime = timestamp;
            } catch (error) {
                console.error('渲染错误:', error);
                // 防止渲染错误导致整个应用崩溃
            }
        }
        
        // 内存优化：定期清理缓存
        if (timestamp % 10000 < 100) { // 每10秒清理一次
            if (window._cachedSelectionState) {
                window._cachedSelectionState = null;
            }
        }
        
        requestAnimationFrame(renderLoop);
    }
    
    // 恢复动画并更新最后交互时间
    function resumeAnimation() {
        const wasAnimationPaused = state.animation.isPaused;
        state.animation.isPaused = false;
        state.animation.lastInteractionTime = Date.now();
        
        if (wasAnimationPaused) {
            // 因用户交互恢复动画
            // 强制重新渲染
            state.isDirty = true;
        }
    }
    
    function renderCanvas() {
        try {
            // 优化：计算可见区域
            const visibleArea = {
                x: -state.view.panX / state.view.zoom,
                y: -state.view.panY / state.view.zoom,
                width: dom.canvas.width / state.view.zoom,
                height: dom.canvas.height / state.view.zoom
            };
            
            ctx.clearRect(0, 0, dom.canvas.width, dom.canvas.height);
            ctx.save();
            ctx.translate(state.view.panX, state.view.panY);
            ctx.scale(state.view.zoom, state.view.zoom);

            // 网格绘制优化：仅在画布较大或缩放级别较高时绘制
            if (state.settings.showGrid && (state.view.zoom > 0.3 || state.nodes.length < 1000)) {
                drawGrid();
            }
            
            // 磁吸高亮优化：仅在编辑模式且节点数量适中时绘制
            if (state.settings.magneticNodes && !state.animation.isPaused && state.nodes.length < 500) {
                drawMagneticHighlights();
            }
            
            // 获取当前层级的组和节点
            const currentGroups = getCurrentLevelGroups();
            const currentNodes = getCurrentLevelNodes();
            
            // 可见性过滤：只渲染可见区域内的元素
            const visibleGroups = currentGroups.filter(group => isElementVisible(group, visibleArea));
            const visibleNodes = currentNodes.filter(node => isElementVisible(node, visibleArea));
            
            // 绘制可见的组和节点
            visibleGroups.forEach(drawGroup);
            visibleNodes.forEach(drawNode);
            
            // 在最后绘制高层级描边（选中和搜索状态），确保不被遮挡
            drawHighPriorityBorders();
            
            // 绘制插入模式的高亮区域
            if (state.settings.insertMode && state.interaction.insertHighlightRegions) {
                drawInsertHighlights();
            }
            
            if (state.interaction.isMarquee && state.interaction.marqueeRect) {
                drawMarquee(state.interaction.marqueeRect);
            }

            ctx.restore();
        } catch (error) {
            console.error('渲染画布错误:', error);
            // 防止渲染错误导致应用崩溃
        }
    }
    
    // 检查元素是否在可见区域内
    function isElementVisible(element, visibleArea) {
        // 扩展可见区域边界，增加一些缓冲区
        const buffer = 50;
        const expandedArea = {
            x: visibleArea.x - buffer,
            y: visibleArea.y - buffer,
            width: visibleArea.width + buffer * 2,
            height: visibleArea.height + buffer * 2
        };
        
        // 检查元素是否与扩展后的可见区域有交集
        return !(element.x + element.width < expandedArea.x ||
                element.x > expandedArea.x + expandedArea.width ||
                element.y + element.height < expandedArea.y ||
                element.y > expandedArea.y + expandedArea.height);
    }

    function drawGrid() {
        const gridSize = state.settings.gridSize;
        const startX = Math.floor(-state.view.panX / state.view.zoom / gridSize) * gridSize;
        const startY = Math.floor(-state.view.panY / state.view.zoom / gridSize) * gridSize;
        const endX = startX + dom.canvas.width / state.view.zoom + gridSize;
        const endY = startY + dom.canvas.height / state.view.zoom + gridSize;
        
        ctx.beginPath();
        ctx.strokeStyle = state.settings.gridColor;
        ctx.lineWidth = 1 / state.view.zoom;
        for (let x = startX; x < endX; x += gridSize) { ctx.moveTo(x, startY); ctx.lineTo(x, endY); }
        for (let y = startY; y < endY; y += gridSize) { ctx.moveTo(startX, y); ctx.lineTo(endX, y); }
        ctx.stroke();
    }



    function drawMagneticHighlights() {
        // 获取当前画布的节点ID集合
        const currentLevelNodeIds = new Set(getCurrentLevelNodes().map(n => n.id));
        
        state.magneticGroups.forEach(cluster => {
            if (cluster.size < 2) return;
            
            // 过滤出属于当前画布的节点
            const nodesInCluster = Array.from(cluster)
                .map(id => state.nodes.find(n => n.id === id))
                .filter(node => node && (currentLevelNodeIds.has(node.id) || 
                                        (node.isStatusBlock && currentLevelNodeIds.has(node.targetNodeId))));
            
            if (nodesInCluster.length < 2) return;
            
            // 获取画布背景色的反转色
            const canvasColor = state.settings.themeColors ? state.settings.themeColors.canvas : '#0B1220';
            const inverseCanvasColor = getInverseColor(canvasColor);
            
            // 计算简单的边界矩形
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const margin = 5; // 保持与节点的距离
            
            nodesInCluster.forEach(node => {
                minX = Math.min(minX, node.x - margin);
                minY = Math.min(minY, node.y - margin);
                maxX = Math.max(maxX, node.x + node.width + margin);
                maxY = Math.max(maxY, node.y + node.height + margin);
            });
            
            // 绘制简单的矩形框
            ctx.save();
            ctx.strokeStyle = inverseCanvasColor;
            ctx.lineWidth = 2 / state.view.zoom;
            ctx.setLineDash([6 / state.view.zoom, 3 / state.view.zoom]);
            
            ctx.beginPath();
            ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
            
            ctx.restore();
        });
    }

    // 颜色反转函数
    function getInverseColor(color) {
        // 处理各种颜色格式
        let r, g, b;
        
        if (color.startsWith('#')) {
            // 十六进制格式
            const hex = color.slice(1);
            if (hex.length === 3) {
                r = parseInt(hex[0] + hex[0], 16);
                g = parseInt(hex[1] + hex[1], 16);
                b = parseInt(hex[2] + hex[2], 16);
            } else {
                r = parseInt(hex.slice(0, 2), 16);
                g = parseInt(hex.slice(2, 4), 16);
                b = parseInt(hex.slice(4, 6), 16);
            }
        } else if (color.startsWith('rgb')) {
            // RGB格式
            const match = color.match(/\d+/g);
            if (match && match.length >= 3) {
                r = parseInt(match[0]);
                g = parseInt(match[1]);
                b = parseInt(match[2]);
            }
        } else {
            // 默认返回白色
            return '#ffffff';
        }
        
        // 计算反转色
        const invR = 255 - r;
        const invG = 255 - g;
        const invB = 255 - b;
        
        // 转换为十六进制
        return `#${invR.toString(16).padStart(2, '0')}${invG.toString(16).padStart(2, '0')}${invB.toString(16).padStart(2, '0')}`;
    }

    // 颜色混合函数 - 计算两个颜色的中间值
    function blendColors(color1, color2, ratio = 0.5) {
        // 解析第一个颜色
        let r1, g1, b1;
        if (color1.startsWith('#')) {
            const hex = color1.slice(1);
            if (hex.length === 3) {
                r1 = parseInt(hex[0] + hex[0], 16);
                g1 = parseInt(hex[1] + hex[1], 16);
                b1 = parseInt(hex[2] + hex[2], 16);
            } else {
                r1 = parseInt(hex.slice(0, 2), 16);
                g1 = parseInt(hex.slice(2, 4), 16);
                b1 = parseInt(hex.slice(4, 6), 16);
            }
        } else if (color1.startsWith('rgb')) {
            const match = color1.match(/\d+/g);
            if (match && match.length >= 3) {
                r1 = parseInt(match[0]);
                g1 = parseInt(match[1]);
                b1 = parseInt(match[2]);
            }
        } else {
            r1 = g1 = b1 = 255;
        }

        // 解析第二个颜色
        let r2, g2, b2;
        if (color2.startsWith('#')) {
            const hex = color2.slice(1);
            if (hex.length === 3) {
                r2 = parseInt(hex[0] + hex[0], 16);
                g2 = parseInt(hex[1] + hex[1], 16);
                b2 = parseInt(hex[2] + hex[2], 16);
            } else {
                r2 = parseInt(hex.slice(0, 2), 16);
                g2 = parseInt(hex.slice(2, 4), 16);
                b2 = parseInt(hex.slice(4, 6), 16);
            }
        } else if (color2.startsWith('rgb')) {
            const match = color2.match(/\d+/g);
            if (match && match.length >= 3) {
                r2 = parseInt(match[0]);
                g2 = parseInt(match[1]);
                b2 = parseInt(match[2]);
            }
        } else {
            r2 = g2 = b2 = 0;
        }

        // 计算混合色
        const r = Math.round(r1 * (1 - ratio) + r2 * ratio);
        const g = Math.round(g1 * (1 - ratio) + g2 * ratio);
        const b = Math.round(b1 * (1 - ratio) + b2 * ratio);

        // 转换为十六进制
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    function drawNode(node) {
        // 为状态块使用更小的padding，确保文字能显示
        const PADDING = node.isStatusBlock ? 2 : 10;
        ctx.font = node.font;
        const fontSize = utils.getFontSize(node.font);
        
        const isHighlighting = state.interaction.magneticCluster.has(node.id);
        const isSelected = node.isSelected;
        const isSearchResult = node.isSearchResult;
        
        // 检查是否在插入模式下拖拽此节点
        const isDraggedInInsertMode = state.settings.insertMode && 
            state.interaction.isDragging && 
            state.interaction.draggedItems && 
            state.interaction.draggedItems.some(item => item.id === node.id);
        
        // 在插入模式下拖拽时设置透明度
        if (isDraggedInInsertMode) {
            ctx.globalAlpha = 0.4;
        }
        
        // 绘制正常背景
        ctx.fillStyle = node.backgroundColor;
        ctx.beginPath();
        ctx.roundRect(node.x, node.y, node.width, node.height, 8);
        ctx.fill();
        
        // 搜索结果节点将在后续绘制新的高亮效果

        // 绘制普通描边（非选中和非搜索状态）
        if (!isSelected && !isSearchResult) {
            const defaultBorderColor = activeTheme && activeTheme.colors.nodeBorder ? activeTheme.colors.nodeBorder : '#777';
            let strokeColor;
            if (isHighlighting) {
                strokeColor = '#eab308'; // 磁吸高亮保持原色
            } else {
                strokeColor = defaultBorderColor; // 默认颜色
            }
            
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = isHighlighting ? 2 / state.view.zoom : 1 / state.view.zoom;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.roundRect(node.x, node.y, node.width, node.height, 8);
            ctx.stroke();
        }

        // 检查并修复节点集状态不一致的问题
    const shouldBeNodeSet = node.nodeSetData && 
        (node.nodeSetData.childNodes.length > 0 || node.nodeSetData.childGroups.length > 0);
    
    // 如果节点有子内容但没有标记为节点集，自动修复
    if (shouldBeNodeSet && !node.isNodeSet) {
        node.isNodeSet = true;
        // 自动修复节点集状态
    }
    
    // 绘制节点集的圆点装饰效果（在文字之前绘制，确保文字在上层）
    if (node.isNodeSet || shouldBeNodeSet) {
        drawNodeSetDecoration(node);
    }

        // 绘制节点内容
        if (node.type === 'imageNode' && node.imageData) {
            drawImageContent(node, PADDING, fontSize);
        } else {
            // 为状态块强制设置文字颜色
            if (node.isStatusBlock) {
                const originalFillStyle = ctx.fillStyle;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                drawTextContent(node, PADDING, fontSize);
                ctx.fillStyle = originalFillStyle;
            } else {
                drawTextContent(node, PADDING, fontSize);
            }
        }

        // 绘制选择UI
        if (isSelected) {
            drawNodeSelectionUI(node);
        }
        
        // 恢复透明度
        if (isDraggedInInsertMode) {
            ctx.globalAlpha = 1.0;
        }
    }

    // 新增函数：绘制选中节点双层描边（仅选中状态，搜索状态改为呼吸灯）
    function drawHighPriorityBorders() {
        state.nodes.forEach(node => {
            const isSelected = node.isSelected;
            const isSearchResult = node.isSearchResult;
            
            // 绘制选中节点的反色流动虚线描边
            if (isSelected) {
                // 获取节点背景色的反色
                function getInverseColor(color) {
                    // 解析颜色值
                    let r, g, b;
                    
                    // 添加空值检查，避免TypeError
                    if (!color) {
                        return '#ffffff'; // 默认返回白色
                    }
                    
                    if (color.startsWith('#')) {
                        // HEX格式
                        const hex = color.slice(1);
                        r = parseInt(hex.substr(0, 2), 16);
                        g = parseInt(hex.substr(2, 2), 16);
                        b = parseInt(hex.substr(4, 2), 16);
                    } else if (color.startsWith('rgb')) {
                        // RGB格式
                        const match = color.match(/\d+/g);
                        r = parseInt(match[0]);
                        g = parseInt(match[1]);
                        b = parseInt(match[2]);
                    } else if (color.startsWith('hsl')) {
                        // HSL格式 - 转换为RGB
                        const match = color.match(/\d+/g);
                        const h = parseInt(match[0]) / 360;
                        const s = parseInt(match[1]) / 100;
                        const l = parseInt(match[2]) / 100;
                        
                        const a = s * Math.min(l, 1 - l);
                        const f = n => {
                            const k = (n + h / (1/12)) % 12;
                            return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                        };
                        
                        r = Math.round(f(0) * 255);
                        g = Math.round(f(8) * 255);
                        b = Math.round(f(4) * 255);
                    } else {
                        // 默认为白色
                        r = 255; g = 255; b = 255;
                    }
                    
                    // 计算反色
                    const invR = 255 - r;
                    const invG = 255 - g;
                    const invB = 255 - b;
                    
                    // 确保对比度足够，如果反色太接近原色，则使用黑色或白色
                    const brightness = (r * 299 + g * 587 + b * 114) / 1000;
                    if (Math.abs(brightness - (invR * 299 + invG * 587 + invB * 114) / 1000) < 100) {
                        return brightness > 128 ? '#000000' : '#ffffff';
                    }
                    
                    return `rgb(${invR}, ${invG}, ${invB})`;
                }
                
                // 获取反色
                const inverseColor = getInverseColor(node.backgroundColor);
                
                // 创建流动虚线效果，保持慢速动画
                const time = state.animation.time * 0.00125; // 保持1/4速度
                const dashLength = 8; // 虚线段长度
                const gapLength = 6; // 虚线间隙长度
                const offset = (time * 20) % (dashLength + gapLength); // 流动偏移
                
                // 设置3px描边和虚线样式
                ctx.lineWidth = 3 / state.view.zoom;
                ctx.strokeStyle = inverseColor;
                ctx.setLineDash([dashLength / state.view.zoom, gapLength / state.view.zoom]);
                ctx.lineDashOffset = -offset / state.view.zoom; // 负值使虚线向前流动
                
                // 绘制反色虚线描边
                ctx.beginPath();
                ctx.roundRect(
                    node.x, 
                    node.y, 
                    node.width, 
                    node.height, 
                    8
                );
                ctx.stroke();
                
                // 重置虚线设置
                ctx.setLineDash([]);
                ctx.lineDashOffset = 0;
            }
            
            // 绘制搜索结果的彩虹描边效果和序号标签
            // 判断是否应该显示搜索结果高亮
            const shouldShowSearchHighlight = isSearchResult && (
                state.interaction.searchScope === 'current' || // 当前层级搜索总是显示
                !state.interaction.isNavigatingResults || // 初始搜索时显示所有结果
                (node.parentNodeSetId || null) === state.nodeSetNavigation.currentNodeSetId // 导航时显示当前画布的结果
            );
            
            if (shouldShowSearchHighlight) {
                // 创建动态彩虹渐变效果
                const time = state.animation.time * 0.005; // 控制动画速度
                const gradient = ctx.createLinearGradient(
                    node.x, node.y, 
                    node.x + node.width, node.y + node.height
                );
                
                // 生成彩虹色彩，基于时间偏移
                for (let i = 0; i <= 6; i++) {
                    const hue = ((i * 60 + time * 50) % 360); // 彩虹色相循环
                    const color = `hsl(${hue}, 100%, 60%)`;
                    gradient.addColorStop(i / 6, color);
                }
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = isSelected ? 4 / state.view.zoom : 3 / state.view.zoom; // 选中时稍微加粗
                ctx.setLineDash([]);
                
                // 绘制彩虹描边，紧贴节点边界
                ctx.beginPath();
                ctx.roundRect(
                    node.x, 
                    node.y, 
                    node.width, 
                    node.height, 
                    8
                );
                ctx.stroke();
                

            }
        });
        
        // 绘制搜索序号标签（重新实现）
        if (state.interaction.searchResults && state.interaction.searchResults.length > 0) {
            state.interaction.searchResults.forEach((item, index) => {
                if (item.type === 'node' && item.parentNodeSetId === state.nodeSetNavigation.currentNodeSetId) {
                    const node = getCurrentLevelNodes().find(n => n.id === item.id);
                    if (node) {
                        const labelNumber = index + 1;
                        
                        // 使用固定的缩放逻辑 - 圆形和文字使用相同的基础尺寸
                        const baseSize = 20; // 基础尺寸
                        const scaledSize = baseSize / state.view.zoom; // 统一缩放
                        const circleRadius = scaledSize / 2; // 圆形半径
                        const fontSize = scaledSize * 0.6; // 文字大小为圆形的60%
                        
                        // 标签位置（节点左上角）
                        const labelX = node.x - circleRadius;
                        const labelY = node.y - circleRadius;
                        
                        // 绘制圆形背景
                        ctx.fillStyle = node.isSelected ? '#ffeb3b' : '#ffffff';
                        ctx.strokeStyle = node.isSelected ? '#f57c00' : '#333333';
                        ctx.lineWidth = 1.5 / state.view.zoom;
                        ctx.beginPath();
                        ctx.arc(labelX, labelY, circleRadius, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        
                        // 绘制序号文字
                        ctx.fillStyle = node.isSelected ? '#e65100' : '#333333';
                        ctx.font = `bold ${fontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(labelNumber.toString(), labelX, labelY);
                        
                        // 搜索标签节点信息
                    }
                }
            });
        }
    }

    function drawTextContent(node, padding, fontSize) {
        // 编辑状态检查：如果当前节点正在被编辑，不显示文字内容，避免与编辑框重叠
        if (state.editingItem && state.editingItem.id === node.id) {
            return; // 直接返回，不绘制文字
        }
        
        // 使用缓存优化文字行计算
        const maxWidth = node.width - padding * 2;
        let lines;
        
        if (node.textLines && node.textLines.length > 0) {
            lines = node.textLines;
        } else {
            // 尝试从缓存获取
            const cachedLines = getCachedTextLines(node.text, fontSize, maxWidth);
            if (cachedLines) {
                lines = cachedLines;
            } else {
                // 计算并缓存文字行
                lines = utils.getWrappedTextLines(node.text, maxWidth, fontSize);
                setCachedTextLines(node.text, fontSize, maxWidth, lines);
            }
        }
        
        // 批量设置绘图属性以减少状态变更
        // 为状态块强制使用70%亮度的白色文字
        ctx.fillStyle = node.isStatusBlock ? 'rgba(255, 255, 255, 0.7)' : node.color;
        const textAlign = node.textAlign || 'center';
        ctx.textAlign = textAlign;
        ctx.textBaseline = 'middle';
        
        const lineHeight = fontSize * 1.2;
        const totalTextHeight = lines.length * lineHeight;
        const availableHeight = node.height - padding * 2;
        
        // 如果文本高度小于可用高度，则垂直居中
        let startY;
        if (totalTextHeight <= availableHeight) {
            startY = node.y + node.height / 2 - (totalTextHeight / 2) + lineHeight / 2;
        } else {
            // 如果文本高度超过可用高度，则从顶部开始
            startY = node.y + padding + lineHeight / 2;
        }
        
        lines.forEach((line, i) => {
            const currentY = startY + i * lineHeight;
            // 只绘制在节点范围内的文本行
            if (currentY >= node.y + padding && currentY <= node.y + node.height - padding) {
                // 根据对齐方式计算X坐标
                let textX;
                switch (textAlign) {
                    case 'left':
                        textX = node.x + padding;
                        break;
                    case 'right':
                        textX = node.x + node.width - padding;
                        break;
                    case 'center':
                    default:
                        textX = node.x + node.width / 2;
                        break;
                }
                ctx.fillText(line, textX, currentY);
            }
        });
        
        // 如果是多行文字且启用了换行，添加调试信息（可选）
        if (node.wordWrap && lines.length > 1) {
            // 可以在这里添加一些视觉提示，比如在节点角落显示换行图标
            // 这里暂时不添加，保持界面简洁
        }
    }

    function drawImageContent(node, padding, fontSize) {
        const img = new Image();
        img.src = node.imageData;
        if (!img.complete) {
            img.onload = () => setStateDirty();
        }

        const lines = utils.getWrappedTextLines(node.text, node.width - padding * 2);
        const textAreaHeight = node.text.trim() ? Math.max(padding * 2, lines.length * fontSize * 1.2) : 0;
        const imageAreaHeight = node.height - textAreaHeight;
        
        ctx.save();
        ctx.beginPath();
        ctx.roundRect(node.x + padding, node.y + padding, node.width - padding * 2, imageAreaHeight - padding * 2, 4);
        ctx.clip();
        
        const availableWidth = node.width - padding * 2;
        const availableHeight = imageAreaHeight - padding * 2;
        if (availableWidth > 0 && availableHeight > 0 && img.width > 0 && img.height > 0) {
            const imgAspectRatio = img.width / img.height;
            const containerAspectRatio = availableWidth / availableHeight;
            let dw, dh, dx, dy;
            if (imgAspectRatio > containerAspectRatio) {
                dw = availableWidth;
                dh = dw / imgAspectRatio;
            } else {
                dh = availableHeight;
                dw = dh * imgAspectRatio;
            }
            dx = node.x + padding + (availableWidth - dw) / 2;
            dy = node.y + padding + (availableHeight - dh) / 2;
            ctx.drawImage(img, dx, dy, dw, dh);
        }
        ctx.restore();

        if (textAreaHeight > 0) {
            ctx.fillStyle = node.color;
            
            // 设置文字对齐方式，默认为居中
            const textAlign = node.textAlign || 'center';
            ctx.textAlign = textAlign;
            ctx.textBaseline = 'middle';
            
            const textStartY = node.y + imageAreaHeight + textAreaHeight / 2;
            const textLineHeight = Math.min(fontSize * 1.2, textAreaHeight / lines.length);
            lines.forEach((line, i) => {
                if (i * textLineHeight < textAreaHeight) {
                    // 根据对齐方式计算X坐标
                    let textX;
                    switch (textAlign) {
                        case 'left':
                            textX = node.x + padding;
                            break;
                        case 'right':
                            textX = node.x + node.width - padding;
                            break;
                        case 'center':
                        default:
                            textX = node.x + node.width / 2;
                            break;
                    }
                    ctx.fillText(line, textX, textStartY + (i - (lines.length - 1) / 2) * textLineHeight);
                }
            });
        }
    }

    function drawNodeSelectionUI(node) {
        const handleSize = 8 / state.view.zoom;
        ctx.fillStyle = '#0ea5e9';
        
        if (node.type === 'imageNode') {
            // 图片节点只在右下角显示调节手柄
            ctx.fillRect(node.x + node.width - handleSize / 2, node.y + node.height - handleSize / 2, handleSize, handleSize);
        } else {
            // 文本节点显示四个调节手柄
            // 右侧调节手柄（宽度）
            ctx.fillRect(node.x + node.width - handleSize / 2, node.y + node.height / 2 - handleSize / 2, handleSize, handleSize);
            
            // 左侧调节手柄（宽度）
            ctx.fillRect(node.x - handleSize / 2, node.y + node.height / 2 - handleSize / 2, handleSize, handleSize);
            
            // 上侧调节手柄（高度）
            ctx.fillRect(node.x + node.width / 2 - handleSize / 2, node.y - handleSize / 2, handleSize, handleSize);
            
            // 下侧调节手柄（高度）
            ctx.fillRect(node.x + node.width / 2 - handleSize / 2, node.y + node.height - handleSize / 2, handleSize, handleSize);
        }
    }

    function drawNodeSetDecoration(node) {
        // 节点集视觉标识：右上角无穷符号∞
        
        // 保存当前绘图状态
        ctx.save();
        
        // 绘制右上角无穷符号∞
        const symbolSize = 25; // 符号大小（放大1.5倍：16px → 24px）
        const symbolX = node.x + node.width - symbolSize + 3; // 距离右边缘-2px（更靠近右边缘）
        const symbolY = node.y - 3; // 距离上边缘-2px（更靠近上边缘）
        
        // 创建动态彩虹渐变效果（与搜索高亮相同）
        const time = state.animation.time * 0.005; // 控制动画速度
        const gradient = ctx.createLinearGradient(
            symbolX, symbolY, 
            symbolX + symbolSize, symbolY + symbolSize
        );
        
        // 生成彩虹色彩，基于时间偏移
        for (let i = 0; i <= 6; i++) {
            const hue = ((i * 60 + time * 50) % 360); // 彩虹色相循环
            const color = `hsl(${hue}, 100%, 60%)`;
            gradient.addColorStop(i / 6, color);
        }
        
        // 设置字体和彩虹渐变颜色
        ctx.fillStyle = gradient;
        ctx.font = `bold ${symbolSize}px Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // 绘制无穷符号∞
        ctx.fillText('∞', symbolX + symbolSize / 2, symbolY + symbolSize / 2);
        
        // 恢复绘图状态
        ctx.restore();
    }

    function drawGroup(group) {
        const TITLE_HEIGHT = state.settings.gridSize;
        const PADDING = state.settings.gridSize / 2;
        
        const fullRect = {
            x: group.x - PADDING,
            y: group.y - PADDING - TITLE_HEIGHT,
            width: group.width + 2 * PADDING,
            height: group.height + 2 * PADDING + TITLE_HEIGHT
        };
        
        group.titleBar = { 
            x: fullRect.x, 
            y: fullRect.y, 
            width: fullRect.width, 
            height: TITLE_HEIGHT 
        };
        
        ctx.fillStyle = utils.colorToRgba(group.color, 0.2);
        
        // 判断是否应该显示组搜索结果样式
        const shouldShowGroupSearchStyle = group.isSearchResult && (
            state.interaction.searchScope === 'current' || // 当前层级搜索总是显示
            !state.interaction.isNavigatingResults || // 初始搜索时显示所有结果
            (group.parentNodeSetId || null) === state.nodeSetNavigation.currentNodeSetId // 导航时只显示当前画布的结果
        );
        
        ctx.strokeStyle = shouldShowGroupSearchStyle ? '#facc15' : (group.isSelected ? '#0ea5e9' : group.color);
        
        let finalLineWidth = 1 / state.view.zoom;
        if (group.isSelected) finalLineWidth = 2 / state.view.zoom;
        if (shouldShowGroupSearchStyle) finalLineWidth = 4 / state.view.zoom;
        ctx.lineWidth = finalLineWidth;


        ctx.beginPath();
        ctx.rect(fullRect.x, fullRect.y, fullRect.width, fullRect.height);
        ctx.fill();
        
        ctx.fillStyle = utils.colorToRgba(group.color, 0.5);
        ctx.fillRect(group.titleBar.x, group.titleBar.y, group.titleBar.width, group.titleBar.height);

        ctx.strokeRect(fullRect.x, fullRect.y, fullRect.width, fullRect.height);
        
        // 绘制组搜索结果序号标签
        // 判断是否应该显示组搜索结果高亮
        const shouldShowGroupSearchHighlight = group.isSearchResult && (
            state.interaction.searchScope === 'current' || // 当前层级搜索总是显示
            !state.interaction.isNavigatingResults || // 初始搜索时显示所有结果
            (group.parentNodeSetId || null) === state.nodeSetNavigation.currentNodeSetId // 导航时显示当前画布的结果
        );
        

        
        ctx.fillStyle = state.settings.themeColors ? state.settings.themeColors.textColor : '#f0f0f0';
        ctx.font = `bold 16px sans-serif`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(group.title, group.titleBar.x + 10, group.titleBar.y + TITLE_HEIGHT / 2);
        
        if (group.isSelected) {
            const handleSize = 10 / state.view.zoom;
            group.resizeHandle = { 
                x: group.x + group.width + PADDING - handleSize / 2, 
                y: group.y + group.height + PADDING - handleSize / 2, 
                size: handleSize 
            };
            ctx.fillStyle = '#0ea5e9';
            ctx.fillRect(group.resizeHandle.x, group.resizeHandle.y, group.resizeHandle.size, group.resizeHandle.size);
        }
        
        // 绘制组搜索序号标签（重新实现）
        if (shouldShowGroupSearchHighlight && state.interaction.searchResults) {
            const searchIndex = state.interaction.searchResults.findIndex(item => 
                item.type === 'group' && item.id === group.id
            );
            if (searchIndex >= 0) {
                const labelNumber = searchIndex + 1;
                
                // 使用与节点相同的固定缩放逻辑
                const baseSize = 20; // 基础尺寸
                const scaledSize = baseSize / state.view.zoom; // 统一缩放
                const circleRadius = scaledSize / 2; // 圆形半径
                const fontSize = scaledSize * 0.6; // 文字大小为圆形的60%
                
                // 标签位置（组左上角）
                const labelX = fullRect.x - circleRadius;
                const labelY = fullRect.y - circleRadius;
                
                // 绘制圆形背景
                ctx.fillStyle = group.isSelected ? '#ffeb3b' : '#ffffff';
                ctx.strokeStyle = group.isSelected ? '#f57c00' : '#333333';
                ctx.lineWidth = 1.5 / state.view.zoom;
                ctx.beginPath();
                ctx.arc(labelX, labelY, circleRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // 绘制序号文字
                ctx.fillStyle = group.isSelected ? '#e65100' : '#333333';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(labelNumber.toString(), labelX, labelY);
                
                // 搜索标签组信息
            }
        }
    }

    function drawMarquee(rect) {
        ctx.fillStyle = 'rgba(14, 165, 233, 0.2)';
        ctx.strokeStyle = 'rgba(14, 165, 233, 0.8)';
        ctx.lineWidth = 1 / state.view.zoom;
        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
    }

    function drawInsertHighlights() {
        if (!state.interaction.insertHighlightRegions || state.interaction.insertHighlightRegions.length === 0) {
            return;
        }
        
        ctx.save();
        
        state.interaction.insertHighlightRegions.forEach(region => {
            if (region.type === 'triangle' && region.points && region.points.length === 3) {
                // 绘制三角形高亮区域
                ctx.fillStyle = 'rgba(34, 197, 94, 0.6)'; // 绿色半透明
                ctx.strokeStyle = 'rgba(34, 197, 94, 1)'; // 绿色边框
                ctx.lineWidth = 2 / state.view.zoom;
                
                ctx.beginPath();
                ctx.moveTo(region.points[0].x, region.points[0].y);
                ctx.lineTo(region.points[1].x, region.points[1].y);
                ctx.lineTo(region.points[2].x, region.points[2].y);
                ctx.closePath();
                
                ctx.fill();
                ctx.stroke();
            }
        });
        
        ctx.restore();
    }

    function executeChainInsertion() {
        const insertTarget = state.interaction.insertTarget;
        const insertDirection = state.interaction.insertDirection;
        const draggedItems = state.interaction.draggedItems;
        
        if (!insertTarget || !insertDirection || draggedItems.length === 0) return;
        
        // 计算被拖拽节点的边界
        let draggedMinX = Infinity, draggedMinY = Infinity;
        let draggedMaxX = -Infinity, draggedMaxY = -Infinity;
        
        draggedItems.forEach(item => {
            draggedMinX = Math.min(draggedMinX, item.x);
            draggedMinY = Math.min(draggedMinY, item.y);
            draggedMaxX = Math.max(draggedMaxX, item.x + item.width);
            draggedMaxY = Math.max(draggedMaxY, item.y + item.height);
        });
        
        const draggedWidth = draggedMaxX - draggedMinX;
        const draggedHeight = draggedMaxY - draggedMinY;
        
        // 计算需要移动的距离
        let moveDistance;
        switch (insertDirection) {
            case 'top':
            case 'bottom':
                moveDistance = draggedHeight;
                break;
            case 'left':
            case 'right':
                moveDistance = draggedWidth;
                break;
        }
        
        // 步骤1&2：先执行连锁反应（位移和拉伸），为镶嵌腾出空间
        executeChainReaction(insertTarget, insertDirection, moveDistance);
        
        // 步骤3：计算镶嵌位置并移动被拖拽的节点
        let insertX, insertY;
        
        switch (insertDirection) {
            case 'top':
                insertX = insertTarget.x;
                insertY = insertTarget.y - draggedHeight;
                break;
            case 'bottom':
                insertX = insertTarget.x;
                insertY = insertTarget.y + insertTarget.height;
                break;
            case 'left':
                insertX = insertTarget.x - draggedWidth;
                insertY = insertTarget.y;
                break;
            case 'right':
                insertX = insertTarget.x + insertTarget.width;
                insertY = insertTarget.y;
                break;
        }
        
        // 移动被拖拽的节点到插入位置（镶嵌）
        const deltaX = insertX - draggedMinX;
        const deltaY = insertY - draggedMinY;
        
        draggedItems.forEach(item => {
            item.x += deltaX;
            item.y += deltaY;
        });
        
        // 镶嵌完成，节点移动
    }
    
    function executeChainReaction(insertTarget, direction, moveDistance) {
        const proximity = 1; // 使用与磁吸功能相同的紧贴判定距离
        const currentLevelNodes = getCurrentLevelNodes();
        
        // 首先找到与目标节点紧贴连接的节点块（连通块）
        const connectedCluster = findConnectedNodeCluster(insertTarget, currentLevelNodes, proximity);
        
        // 三步骤插入逻辑：位移、拉伸、镶嵌（只在连通块内进行）
        // 开始执行三步骤插入逻辑
        
        // 步骤1：位移 - 识别目标节点上方/下方/左侧/右侧的所有磁吸状态节点（限制在连通块内）
        const nodesToMove = findMagneticNodesForDisplacement(insertTarget, direction, proximity, connectedCluster);
        // 步骤1 - 位移节点
        
        // 步骤2：拉伸 - 识别目标节点左侧/右侧/上方/下方的紧贴链条（限制在连通块内）
        const nodesToStretch = findAdjacentChainForStretching(insertTarget, direction, proximity, connectedCluster);
        // 步骤2 - 拉伸节点
        
        // 执行位移操作
        nodesToMove.forEach(node => {
            switch (direction) {
                case 'top':
                    node.y -= moveDistance;
                    // 向上位移节点
                    break;
                case 'bottom':
                    node.y += moveDistance;
                    // 向下位移节点
                    break;
                case 'left':
                    node.x -= moveDistance;
                    // 向左位移节点
                    break;
                case 'right':
                    node.x += moveDistance;
                    // 向右位移节点
                    break;
            }
        });
        
        // 执行拉伸操作
        nodesToStretch.forEach(node => {
            switch (direction) {
                case 'top':
                    // 向上拉伸：保持底部不变，减少y坐标，增加高度
                    node.y -= moveDistance;
                    node.height += moveDistance;
                    // 向上拉伸节点
                    break;
                case 'bottom':
                    // 向下拉伸：保持顶部不变，增加高度
                    node.height += moveDistance;
                    // 向下拉伸节点
                    break;
                case 'left':
                    // 向左拉伸：保持右边不变，减少x坐标，增加宽度
                    node.x -= moveDistance;
                    node.width += moveDistance;
                    // 向左拉伸节点
                    break;
                case 'right':
                    // 向右拉伸：保持左边不变，增加宽度
                    node.width += moveDistance;
                    // 向右拉伸节点
                    break;
            }
        });
        
        // 三步骤插入逻辑执行完成
    }
    
    // 查找与目标节点紧贴连接的节点块（连通块）
    function findConnectedNodeCluster(targetNode, allNodes, proximity = 1) {
        const connectedNodes = new Set();
        const visited = new Set();
        
        // 递归查找紧贴连接的节点
        function findConnectedRecursive(node) {
            if (visited.has(node.id)) return;
            visited.add(node.id);
            connectedNodes.add(node);
            
            // 查找与当前节点紧贴的所有节点
            allNodes.forEach(otherNode => {
                if (otherNode.id === node.id || visited.has(otherNode.id)) return;
                
                // 检查是否紧贴（使用磁吸距离判定）
                const isAdjacent = (
                    // 水平紧贴：左右相邻
                    (Math.abs((node.x + node.width) - otherNode.x) <= proximity || 
                     Math.abs((otherNode.x + otherNode.width) - node.x) <= proximity) &&
                    // 垂直重叠或紧贴
                    !(node.y + node.height <= otherNode.y - proximity || 
                      node.y >= otherNode.y + otherNode.height + proximity)
                ) || (
                    // 垂直紧贴：上下相邻
                    (Math.abs((node.y + node.height) - otherNode.y) <= proximity || 
                     Math.abs((otherNode.y + otherNode.height) - node.y) <= proximity) &&
                    // 水平重叠或紧贴
                    !(node.x + node.width <= otherNode.x - proximity || 
                      node.x >= otherNode.x + otherNode.width + proximity)
                );
                
                if (isAdjacent) {
                    findConnectedRecursive(otherNode);
                }
            });
        }
        
        // 从目标节点开始递归查找
        findConnectedRecursive(targetNode);
        
        // 智能插入连通块检测
        
        return Array.from(connectedNodes);
    }
    
    // 步骤1：查找需要位移的节点（目标节点指定方向上的所有节点）
    function findMagneticNodesForDisplacement(insertTarget, direction, proximity, allNodes) {
        const nodesToMove = [];
        
        allNodes.forEach(node => {
            if (node.id === insertTarget.id) return;
            
            let shouldMove = false;
            
            switch (direction) {
                case 'top':
                    // 向上插入：所有在目标节点上方的节点都需要向上位移
                    if (node.y + node.height <= insertTarget.y + proximity) {
                        shouldMove = true;
                    }
                    break;
                case 'bottom':
                    // 向下插入：所有在目标节点下方的节点都需要向下位移
                    if (node.y >= insertTarget.y + insertTarget.height - proximity) {
                        shouldMove = true;
                    }
                    break;
                case 'left':
                    // 向左插入：所有在目标节点左侧的节点都需要向左位移
                    if (node.x + node.width <= insertTarget.x + proximity) {
                        shouldMove = true;
                    }
                    break;
                case 'right':
                    // 向右插入：所有在目标节点右侧的节点都需要向右位移
                    if (node.x >= insertTarget.x + insertTarget.width - proximity) {
                        shouldMove = true;
                    }
                    break;
            }
            
            if (shouldMove) {
                nodesToMove.push(node);
            }
        });
        
        return nodesToMove;
    }
    
    // 步骤2：查找需要拉伸的紧贴链条
    function findAdjacentChainForStretching(insertTarget, direction, proximity, allNodes) {
        const nodesToStretch = [];
        
        switch (direction) {
            case 'top':
                // 向上插入：查找目标节点左侧的紧贴链条，这些节点需要向上拉伸
                nodesToStretch.push(...findLeftAdjacentChain(insertTarget, proximity, allNodes));
                break;
            case 'bottom':
                // 向下插入：查找目标节点左侧的紧贴链条，这些节点需要向下拉伸
                nodesToStretch.push(...findLeftAdjacentChain(insertTarget, proximity, allNodes));
                break;
            case 'left':
                // 向左插入：查找目标节点上方的紧贴链条，这些节点需要向左拉伸
                nodesToStretch.push(...findTopAdjacentChain(insertTarget, proximity, allNodes));
                break;
            case 'right':
                // 向右插入：查找目标节点上方的紧贴链条，这些节点需要向右拉伸
                nodesToStretch.push(...findTopAdjacentChain(insertTarget, proximity, allNodes));
                break;
        }
        
        return nodesToStretch;
    }
    
    // 查找目标节点左侧的紧贴链条
    function findLeftAdjacentChain(insertTarget, proximity, allNodes) {
        const leftChain = [];
        
        // 首先找到直接紧贴目标节点左侧的节点
        const directLeftNodes = allNodes.filter(node => {
            if (node.id === insertTarget.id) return false;
            
            // 检查是否紧贴目标节点的左边缘
            const isAdjacentLeft = Math.abs((node.x + node.width) - insertTarget.x) <= proximity;
            
            // 检查垂直重叠或紧贴
            const hasVerticalOverlap = !(node.y + node.height <= insertTarget.y || node.y >= insertTarget.y + insertTarget.height);
            
            return isAdjacentLeft && hasVerticalOverlap;
        });
        
        leftChain.push(...directLeftNodes);
        
        // 递归查找这些节点左侧的紧贴链条
        directLeftNodes.forEach(node => {
            leftChain.push(...findLeftAdjacentChain(node, proximity, allNodes.filter(n => !leftChain.includes(n) && n.id !== insertTarget.id)));
        });
        
        return leftChain;
    }
    
    // 查找目标节点上方的紧贴链条
    function findTopAdjacentChain(insertTarget, proximity, allNodes) {
        const topChain = [];
        
        // 首先找到直接紧贴目标节点上方的节点
        const directTopNodes = allNodes.filter(node => {
            if (node.id === insertTarget.id) return false;
            
            // 检查是否紧贴目标节点的上边缘
            const isAdjacentTop = Math.abs((node.y + node.height) - insertTarget.y) <= proximity;
            
            // 检查水平重叠或紧贴
            const hasHorizontalOverlap = !(node.x + node.width <= insertTarget.x || node.x >= insertTarget.x + insertTarget.width);
            
            return isAdjacentTop && hasHorizontalOverlap;
        });
        
        topChain.push(...directTopNodes);
        
        // 递归查找这些节点上方的紧贴链条
        directTopNodes.forEach(node => {
            topChain.push(...findTopAdjacentChain(node, proximity, allNodes.filter(n => !topChain.includes(n) && n.id !== insertTarget.id)));
        });
        
        return topChain;
    }

    // ===================================================================================
    // Core Logic & Actions
    // ===================================================================================
    const getSelectedNodes = () => getCurrentLevelNodes().filter(n => n.isSelected);
    const getSelectedGroups = () => getCurrentLevelGroups().filter(g => g.isSelected);
    
    function getGroupAt(x, y) {
        const currentGroups = getCurrentLevelGroups();
        for (let i = currentGroups.length - 1; i >= 0; i--) {
            const g = currentGroups[i];
            // 只检查标题栏区域，不检查组的主体区域
            if (utils.isPointInGroupTitle(x, y, g)) {
                return g;
            }
        }
        return null;
    }
    
    function getNodeAt(x, y) {
        const currentNodes = getCurrentLevelNodes();
        for (let i = currentNodes.length - 1; i >= 0; i--) {
            const node = currentNodes[i];
            if (utils.isPointInNode(x, y, node)) {
                return node;
            }
        }
        return null;
    }
    
    function getItemAt(x, y) {
        // 先检查节点（节点在组的上层）
        const node = getNodeAt(x, y);
        if (node) return node;
        
        // 再检查组
        const group = getGroupAt(x, y);
        if (group) return group;
        
        return null;
    }
    
    function updateNodeHeight(node) {
        if (node.type === 'imageNode') return;
        const lines = utils.getWrappedTextLines(node.text, node.width - 20); // 20 is padding
        
        // 高度处理规则：n行文字 = n+1 个网格高度
        const lineCount = lines.length;
        const requiredGridHeight = lineCount + 1;
        
        // 最小高度为2个网格
        const finalGridHeight = Math.max(2, requiredGridHeight);
        node.height = finalGridHeight * state.settings.gridSize;
    }
    
    // 智能高度更新函数 - 考虑手动调节高度的状态
    function updateNodeHeightSmart(node) {
        if (node.type === 'imageNode') return;
        
        // 计算可用宽度（减去左右各12px的padding，总共24px）
        const availableWidth = node.width - 24;
        
        // 无论高度是否被手动调节，都重新计算文本换行并更新文本行数据
        const lines = utils.getWrappedTextLines(node.text, availableWidth);
        const lineCount = lines.length;
        
        // 强制更新节点的文本行数据，确保渲染时使用正确的内容
        node.textLines = lines;
        node.lineCount = lineCount;
        
        // 只有在wordWrap属性未定义时，才根据文本行数自动设置
        if (node.wordWrap === undefined) {
            node.wordWrap = lineCount > 1;
        }
        
        // 计算所需高度
        const requiredGridHeight = lineCount + 1;  // n行文字需要n+1个网格高度，确保有足够空间显示
        const minGridHeight = 2;
        const requiredHeight = Math.max(minGridHeight, requiredGridHeight) * state.settings.gridSize;
        
        // 如果节点高度被手动调节过
        if (node.manuallyAdjustedHeight) {
            // 只在文字溢出时增加高度，不减少高度
            if (requiredHeight > node.height) {
                node.height = requiredHeight;
            }
            // 如果当前高度足够显示文字，保持不变
        } else {
            // 如果没有被手动调节过，使用原有的自适应逻辑
            node.height = requiredHeight;
        }
    }
    
    function updateNodeDimensionsSmart(node) {
        if (node.type === 'imageNode') return;
        
        // 检查节点是否有自动换行功能
        // 如果节点有wordWrap属性且为true，或者文本行数大于1，说明有自动换行
        const hasWordWrap = node.wordWrap || (node.lineCount && node.lineCount > 1);
        
        if (hasWordWrap) {
            // 有自动换行：只调整高度，保持宽度不变
            updateNodeHeightSmart(node);
        } else {
            // 没有自动换行：正常调整宽度和高度
            updateNodeDimensions(node);
        }
    }

    function updateNodeDimensions(node) {
        if (node.type === 'imageNode') return;
        
        // 使用新规则计算文本所需宽度
        const requiredWidth = utils.getTextRequiredWidth(node.text, node.font);
        
        // 确保最小宽度为2个网格
        const minWidth = state.settings.gridSize * 2;
        
        // 智能宽度更新：考虑手动调整标记
        if (node.manuallyAdjustedWidth) {
            // 如果宽度被手动调整过，只在文本溢出时增加宽度，不减少宽度
            if (requiredWidth > node.width) {
                node.width = Math.max(requiredWidth, minWidth);
            } else {
                // 确保宽度至少为最小宽度
                node.width = Math.max(node.width, minWidth);
            }
        } else {
            // 如果没有被手动调整过，使用原有的自适应逻辑
            // 只有当前宽度小于所需宽度时才自动调整宽度
            // 这允许手动调整为比需要的更宽，但防止文本溢出
            if (node.width < requiredWidth) {
                node.width = Math.max(requiredWidth, minWidth);
            } else {
                // 确保宽度至少为最小宽度
                node.width = Math.max(node.width, minWidth);
            }
        }
        
        // 根据当前宽度智能更新高度（考虑换行和新的高度规则）
        updateNodeHeightSmart(node);
    }
    
    function createNode(x, y, text = "新节点", type = 'node', imageData = null, parentNodeSetId = null, skipSaveState = false) {
        const snappedX = utils.snap(x);
        const snappedY = utils.snap(y);
        
        // 如果没有指定父节点集ID，使用当前层级的节点集ID
        if (parentNodeSetId === null) {
            parentNodeSetId = state.nodeSetNavigation.currentNodeSetId;
        }
        
        // 使用当前主题的默认颜色，而不是从颜色选择器获取
        let backgroundColor = '#ffffff';
        let fontColor = '#000000';
        
        // 获取当前主题颜色
        const currentThemeColors = state.settings.themeColors;
        if (currentThemeColors) {
            backgroundColor = currentThemeColors.nodeBg;
            fontColor = currentThemeColors.nodeText;
        }
        
        // 计算正确的初始宽度
        const initialWidth = utils.getTextRequiredWidth(text, 'bold 16px sans-serif');
        
        const newNode = { 
            id: utils.generateId(), x: snappedX, y: snappedY, width: initialWidth, height: 40, text, 
            backgroundColor: backgroundColor, 
            color: fontColor, 
            font: 'bold 16px sans-serif', 
            isSelected: false, groupId: null, type, imageData, imageAspectRatio: 1,
            hasCustomStyle: false,
            // 高度调节状态跟踪
            manuallyAdjustedHeight: false,       // 是否被手动调节过高度
            manuallyAdjustedWidth: false,        // 是否被手动调节过宽度
            isCreatedByUser: false,              // 标记是否为新创建的节点
            // 节点集相关属性
            isNodeSet: false,                    // 是否为节点集
            parentNodeSetId: parentNodeSetId,    // 父节点集ID
            nodeSetData: {                       // 节点集数据
                childNodes: [],                  // 子节点列表
                childGroups: [],                 // 子分组列表
                view: { panX: 0, panY: 0, zoom: 1 } // 节点集内部视图状态
            }
        };
        updateNodeDimensions(newNode); // Use new function for both width and height
        state.nodes.push(newNode);
        
        // 如果在节点集内创建节点，需要将节点ID添加到父节点集的子节点列表中
        if (parentNodeSetId) {
            const parentNodeSet = state.nodes.find(n => n.id === parentNodeSetId && n.isNodeSet);
            if (parentNodeSet && parentNodeSet.nodeSetData) {
                parentNodeSet.nodeSetData.childNodes.push(newNode.id);
            }
        }
        

        updateCanvasCountInfo();
        if (!skipSaveState) {
            saveState('创建节点');
        }
        setStateDirty();
        return newNode;
    }

    function createGroup(nodes, title = "新分组") {
        if (!nodes || nodes.length === 0) {
            return null;
        }
        
        const xCoords = nodes.map(n => n.x);
        const yCoords = nodes.map(n => n.y);
        const rightCoords = nodes.map(n => n.x + n.width);
        const bottomCoords = nodes.map(n => n.y + n.height);
        
        // 获取当前节点集ID
        const currentNodeSetId = state.nodeSetNavigation.currentNodeSetId;
        
        // 使用当前主题的默认组颜色
        let groupColor = '#3b82f6'; // 默认蓝色
        const currentThemeColors = state.settings.themeColors;
        if (currentThemeColors) {
            groupColor = currentThemeColors.group;
        }
        
        const newGroup = { 
            id: utils.generateId(), 
            nodeIds: nodes.map(n => n.id), 
            color: groupColor,
            title, isSelected: true, type: 'group',
            x: Math.min(...xCoords),
            y: Math.min(...yCoords),
            width: Math.max(...rightCoords) - Math.min(...xCoords),
            height: Math.max(...bottomCoords) - Math.min(...yCoords),
            hasCustomStyle: false,
            // 节点集相关属性
            parentNodeSetId: currentNodeSetId  // 设置父节点集ID
        };
        
        state.groups.push(newGroup);
        nodes.forEach(node => {
            node.groupId = newGroup.id;
            node.isSelected = false;
        });
        
        // 如果在节点集内创建分组，需要将分组ID添加到父节点集的子分组列表中
        if (currentNodeSetId) {
            const parentNodeSet = state.nodes.find(n => n.id === currentNodeSetId && n.isNodeSet);
            if (parentNodeSet && parentNodeSet.nodeSetData) {
                parentNodeSet.nodeSetData.childGroups.push(newGroup.id);
            }
        }
        
        updateCanvasCountInfo();
        saveState('创建组');
        setStateDirty();
        return newGroup;
    }

    function startEditing(item) {
        // 开始编辑项目
        state.editingItem = item;
        // 设置编辑项目状态
        const isNode = item.type === 'node' || item.type === 'imageNode';
        
        // 保存原始文本和尺寸，用于后续比较
        if (isNode) {
            state.originalEditingText = item.text;
            state.originalEditingWidth = item.width;
            state.originalEditingHeight = item.height;
            // 节点编辑：使用思维导图式内联编辑
            setupInlineNodeEditing(item);
        } else {
            state.originalEditingText = item.title;
            // 组标题编辑：保持原有逻辑
            const rect = {x: item.titleBar.x, y: item.titleBar.y, w: item.titleBar.width, h: item.titleBar.height};
            const screenPos = utils.worldToScreen(rect.x, rect.y);
            
            Object.assign(dom.textEditor.style, {
                display: 'block',
                left: `${screenPos.x}px`,
                top: `${screenPos.y}px`,
                width: `${rect.w * state.view.zoom}px`,
                height: `${rect.h * state.view.zoom}px`,
                backgroundColor: item.titleBar.backgroundColor || '#3a3a3a',
                color: item.titleBar.color || '#f0f0f0',
            });
            dom.textEditor.value = item.title;
        }
        
        dom.textEditor.focus();
        dom.textEditor.select();
    }
    
    function setupInlineNodeEditing(node) {
        // 计算编辑框的精确位置和尺寸，与节点渲染完全一致
        let editX = node.x;
        let editY = node.y;
        let editWidth = node.width;
        let editHeight = node.height;
        
        // 对于图片节点，需要计算文本区域的位置
        if (node.type === 'imageNode' && node.text.trim()) {
            const lines = utils.getWrappedTextLines(node.text, node.width - 20); // 20 is padding * 2
            const textAreaHeight = Math.max(20, lines.length * 16 * 1.2); // fontSize * lineHeight
            const imageAreaHeight = node.height - textAreaHeight;
            
            // 文本区域在图片下方
            editY = node.y + imageAreaHeight;
            editHeight = textAreaHeight;
        } else if (node.type === 'node') {
            // 对于普通文本节点，计算文本的实际渲染区域
            // 使用与 drawTextContent 相同的逻辑
            const padding = 10;
            const fontSize = 16;
            const lineHeight = fontSize * 1.2;
            const lines = utils.getWrappedTextLines(node.text, node.width - padding * 2);
            const totalTextHeight = lines.length * lineHeight;
            const availableHeight = node.height - padding * 2;
            
            // 计算文本的实际渲染位置和高度
            if (totalTextHeight <= availableHeight) {
                // 文本垂直居中的情况
                const textStartY = node.y + node.height / 2 - (totalTextHeight / 2);
                editY = textStartY - padding; // 减去padding，因为编辑框会添加padding
                editHeight = totalTextHeight + padding * 2; // 加上上下padding
            } else {
                // 文本从顶部开始的情况
                editY = node.y;
                editHeight = node.height;
            }
            
            editX = node.x;
            editWidth = node.width;
        }
        
        // 使用worldToScreen进行坐标转换，它已经包含了缩放和画布偏移处理
        const screenPos = utils.worldToScreen(editX, editY);
        let screenWidth = editWidth * state.view.zoom;
        let screenHeight = editHeight * state.view.zoom;
        
        // 记录原始编辑框尺寸，用于判断节点类型
        const originalEditWidth = screenWidth;
        const originalEditHeight = screenHeight;
        // 记录节点原始尺寸
        
        // 智能的四方向屏幕边界检查和位置调整，确保编辑框始终可见
        let finalScreenX = screenPos.x;
        let finalScreenY = screenPos.y;
        
        // 获取工具栏高度，确保编辑框不会被工具栏遮挡
        const toolbar = document.getElementById('toolbar');
        const toolbarHeight = toolbar ? toolbar.offsetHeight : 50; // 默认50px
        const safeMargin = 10; // 安全边距
        
        // 定义可用的屏幕区域边界
        const minX = safeMargin;
        const maxX = window.innerWidth - safeMargin;
        const minY = toolbarHeight + safeMargin;
        const maxY = window.innerHeight - safeMargin;
        
        // 计算可用的最大尺寸
        const maxAvailableWidth = maxX - minX;
        const maxAvailableHeight = maxY - minY;
        
        // 定义最小可见尺寸，确保编辑框始终可用
        const minVisibleWidth = Math.min(200, maxAvailableWidth * 0.3);
        const minVisibleHeight = Math.min(100, maxAvailableHeight * 0.2);
        
        // 判断节点类型：正常节点 vs 超大节点
        const isLargeNode = originalEditWidth > maxAvailableWidth * 0.8 || originalEditHeight > maxAvailableHeight * 0.8;
        const isNormalNode = !isLargeNode;
        
        if (isNormalNode) {
            // 检测到正常大小节点
        } else {
            // 检测到超大节点，应用智能尺寸调整
        }
        
        // 记录原始位置和尺寸，用于检测是否需要自动滚动
        const originalScreenX = finalScreenX;
        const originalScreenY = finalScreenY;
        const originalScreenWidth = screenWidth;
        const originalScreenHeight = screenHeight;
        
        // 1. 智能尺寸限制：只有当编辑框尺寸超过屏幕时才进行调整
        let widthAdjusted = false;
        let heightAdjusted = false;
        
        if (screenWidth > maxAvailableWidth) {
            screenWidth = maxAvailableWidth;
            widthAdjusted = true;
            // 调整编辑框宽度
        }
        
        if (screenHeight > maxAvailableHeight) {
            screenHeight = maxAvailableHeight;
            heightAdjusted = true;
            // 调整编辑框高度
        }
        
        // 2. 左侧边界检查：如果编辑框超出屏幕左侧，向右调整位置
        if (finalScreenX < minX) {
            finalScreenX = minX;
            // 向右调整编辑框位置
        }
        
        // 3. 右侧边界检查：如果编辑框超出屏幕右侧，向左调整位置
        if (finalScreenX + screenWidth > maxX) {
            finalScreenX = maxX - screenWidth;
            // 确保调整后不会超出左边界
            if (finalScreenX < minX) {
                finalScreenX = minX;
                // 如果宽度仍然超出可用空间，进一步限制编辑框宽度
                if (screenWidth > maxAvailableWidth) {
                    screenWidth = maxAvailableWidth;
                }
            }
            // 向左调整编辑框位置
        }
        
        // 4. 上方边界检查：如果编辑框超出屏幕上方（工具栏下方），向下调整位置
        if (finalScreenY < minY) {
            finalScreenY = minY;
            // 向下调整编辑框位置
        }
        
        // 5. 下方边界检查：如果编辑框超出屏幕下方，向上调整位置
        if (finalScreenY + screenHeight > maxY) {
            finalScreenY = maxY - screenHeight;
            // 确保调整后不会超出上边界
            if (finalScreenY < minY) {
                finalScreenY = minY;
                // 如果高度仍然超出可用空间，进一步限制编辑框高度
                if (screenHeight > maxAvailableHeight) {
                    screenHeight = maxAvailableHeight;
                }
            }
            // 向上调整编辑框位置
        }
        
        // 6. 智能最终可见性保证：只在编辑框被大幅缩小时应用最小尺寸
        // 定义过小的阈值（比最小可见尺寸更小）
        const tooSmallWidth = 50;
        const tooSmallHeight = 30;
        
        // 确保编辑框位置在可见区域内
        finalScreenX = Math.max(minX, Math.min(finalScreenX, maxX - screenWidth));
        finalScreenY = Math.max(minY, Math.min(finalScreenY, maxY - screenHeight));
        
        // 智能最小尺寸应用：只对超大节点或被严重压缩的节点应用最小尺寸保证
        if (screenWidth < tooSmallWidth && (isLargeNode || widthAdjusted || finalScreenX !== originalScreenX)) {
            screenWidth = Math.min(minVisibleWidth, maxX - finalScreenX);
            // 应用最小可见宽度
        } else if (isNormalNode && screenWidth !== originalEditWidth) {
            // 保持原始宽度
        }
        
        if (screenHeight < tooSmallHeight && (isLargeNode || heightAdjusted || finalScreenY !== originalScreenY)) {
            screenHeight = Math.min(minVisibleHeight, maxY - finalScreenY);
            // 应用最小可见高度
        } else if (isNormalNode && screenHeight !== originalEditHeight) {
            // 保持原始高度
        }
        
        // 最终确保编辑框完全在可见区域内
        screenWidth = Math.min(screenWidth, maxX - finalScreenX);
        screenHeight = Math.min(screenHeight, maxY - finalScreenY);
        
        // 7. 检测是否需要自动滚动到编辑框位置
        const positionAdjustmentX = Math.abs(finalScreenX - originalScreenX);
        const positionAdjustmentY = Math.abs(finalScreenY - originalScreenY);
        const sizeAdjustmentW = Math.abs(screenWidth - originalScreenWidth);
        const sizeAdjustmentH = Math.abs(screenHeight - originalScreenHeight);
        
        // 如果位置或尺寸有显著调整，则认为需要自动滚动
        const significantAdjustment = positionAdjustmentX > 50 || positionAdjustmentY > 50 || 
                                    sizeAdjustmentW > 100 || sizeAdjustmentH > 100;
        
        if (significantAdjustment) {
            // 自动滚动到编辑框位置
        }
        
        // 设置编辑框样式，与节点样式完全一致
        // 由于我们已经精确计算了文本的渲染区域，编辑框应该完全匹配这个区域
        // 因此不需要额外的 padding，避免双重 padding 问题
        Object.assign(dom.textEditor.style, {
            display: 'block',
            left: `${finalScreenX}px`,
            top: `${finalScreenY}px`,
            width: `${screenWidth}px`,
            height: `${screenHeight}px`,
            backgroundColor: node.backgroundColor,
            color: node.color,
            fontSize: `${16 * state.view.zoom}px`, // 字体大小需要根据缩放调整以保持可读性
            padding: `${10 * state.view.zoom}px`, // 根据缩放比例调整padding
            borderRadius: `${8 * state.view.zoom}px`, // 圆角需要根据缩放调整以保持比例
            overflow: 'hidden', // 先设置为hidden，稍后根据内容决定是否需要滚动条
            resize: 'none', // 禁用手动调整大小
            wordWrap: 'break-word', // 自动换行
            whiteSpace: 'pre-wrap', // 保持换行符和空格
            boxSizing: 'border-box', // 确保padding不会影响总尺寸
        });
        
        dom.textEditor.value = node.text;
        
        // 检查是否需要滚动条 - 使用更精确的判断条件和更大的容忍度
        setTimeout(() => {
            const heightDiff = dom.textEditor.scrollHeight - dom.textEditor.clientHeight;
            const widthDiff = dom.textEditor.scrollWidth - dom.textEditor.clientWidth;
            
            // 只有当内容明显超出时才显示滚动条（容忍5像素的误差，以忽略浏览器渲染差异）
            if (heightDiff > 5 || widthDiff > 5) {
                dom.textEditor.style.overflow = 'auto';
                // 内容超出，显示滚动条
            } else {
                dom.textEditor.style.overflow = 'hidden';
                // 内容适合，隐藏滚动条
            }
        }, 10);
        
        // 8. 如果有显著调整，执行自动滚动和焦点恢复
        if (significantAdjustment) {
            // 延迟执行，确保编辑框已经显示
            setTimeout(() => {
                // 聚焦编辑框
                dom.textEditor.focus();
                
                // 将光标移动到文本末尾
                const textLength = dom.textEditor.value.length;
                dom.textEditor.setSelectionRange(textLength, textLength);
                
                // 滚动到编辑框位置（如果需要）
                const editorRect = dom.textEditor.getBoundingClientRect();
                const isVisible = editorRect.top >= 0 && 
                                editorRect.left >= 0 && 
                                editorRect.bottom <= window.innerHeight && 
                                editorRect.right <= window.innerWidth;
                
                if (!isVisible) {
                    dom.textEditor.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center', 
                        inline: 'center' 
                    });
                }
                
                // 自动滚动到编辑框并恢复焦点
            }, 50);
        }
        
        // 添加实时尺寸更新监听器
        setupRealtimeUpdateListener(node);
    }
    
    function setupRealtimeUpdateListener(node) {
        // 移除之前的监听器
        dom.textEditor.removeEventListener('input', state.realtimeUpdateHandler);
        dom.textEditor.removeEventListener('keydown', state.shiftEnterHandler);
        if (state.compositionStartHandler) {
            dom.textEditor.removeEventListener('compositionstart', state.compositionStartHandler);
        }
        if (state.compositionEndHandler) {
            dom.textEditor.removeEventListener('compositionend', state.compositionEndHandler);
        }
        
        // 创建实时更新处理器
        state.realtimeUpdateHandler = function(event) {
            updateNodeDimensionsRealtime(node, dom.textEditor.value);
        };
        
        // 创建Shift+Enter处理器
        state.shiftEnterHandler = function(event) {
            if (event.shiftKey && event.key === 'Enter') {
                event.preventDefault();
                // 在光标位置插入换行符
                const start = dom.textEditor.selectionStart;
                const end = dom.textEditor.selectionEnd;
                const value = dom.textEditor.value;
                dom.textEditor.value = value.substring(0, start) + '\n' + value.substring(end);
                dom.textEditor.selectionStart = dom.textEditor.selectionEnd = start + 1;
                
                // 触发实时更新
                updateNodeDimensionsRealtime(node, dom.textEditor.value);
            }
        };
        
        // 输入法事件处理器
        state.compositionStartHandler = () => {
            state.interaction.isComposing = true;
        };
        
        state.compositionEndHandler = () => {
            state.interaction.isComposing = false;
            // 输入法输入结束后，重新计算并调整节点尺寸
            updateNodeDimensionsRealtime(node, dom.textEditor.value);
        };
        
        // 添加监听器
        dom.textEditor.addEventListener('input', state.realtimeUpdateHandler);
        dom.textEditor.addEventListener('keydown', state.shiftEnterHandler);
        dom.textEditor.addEventListener('compositionstart', state.compositionStartHandler);
        dom.textEditor.addEventListener('compositionend', state.compositionEndHandler);
    }
    
    function updateNodeDimensionsRealtime(node, newText) {
        // 如果正在进行输入法输入（拼音等），不调整节点尺寸
        if (state.interaction.isComposing) {
            // 只更新文本内容，不调整尺寸
            node.text = newText;
            return;
        }
        
        // 临时更新节点文本以计算新尺寸
        const originalText = node.text;
        
        // 清除旧文本的缓存
        if (originalText !== newText) {
            const maxWidth = node.width - 20; // 假设padding为10
            const fontSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--font-size')) || 16;
            const oldCacheKey = getTextCacheKey(originalText, fontSize, maxWidth);
            textLineCache.delete(oldCacheKey);
            
            // 保留手动调整标记，不再在编辑文本时重置
            // 这样可以确保编辑节点文字内容时，保持节点原有的宽度和高度属性不发生改变
            // 原代码：
            // if (node.isCreatedByUser !== false) {
            //     node.manuallyAdjustedWidth = false;
            //     node.manuallyAdjustedHeight = false;
            // }
        }
        
        node.text = newText;
        
        // 智能尺寸调整：根据节点是否有自动换行来决定调整策略
        updateNodeDimensionsSmart(node);
        
        // 但仍然需要更新文本行缓存，以确保文本正确显示
        if (node.type !== 'imageNode') {
            // 计算可用宽度（减去左右各12px的padding，总共24px）
            const availableWidth = node.width - 24;
            
            // 重新计算文本换行并更新文本行数据
            const lines = utils.getWrappedTextLines(node.text, availableWidth);
            node.textLines = lines;
            node.lineCount = lines.length;
        }
        
        // 计算编辑框的位置和尺寸
        let editX = node.x;
        let editY = node.y;
        let editWidth = node.width;
        let editHeight = node.height;
        
        // 对于图片节点，需要重新计算文本区域的位置
        if (node.type === 'imageNode' && node.text.trim()) {
            const lines = utils.getWrappedTextLines(node.text, node.width - 20); // 20 is padding * 2
            const textAreaHeight = Math.max(20, lines.length * 16 * 1.2); // fontSize * lineHeight
            const imageAreaHeight = node.height - textAreaHeight;
            
            // 文本区域在图片下方
            editY = node.y + imageAreaHeight;
            editHeight = textAreaHeight;
        } else if (node.type === 'node') {
            // 对于普通文本节点，计算文本的实际渲染区域
            // 使用与 drawTextContent 和 setupInlineNodeEditing 相同的逻辑
            const padding = 10; // 基础padding值，与drawTextContent保持一致
            const fontSize = 16;
            const lineHeight = fontSize * 1.2;
            const lines = utils.getWrappedTextLines(node.text, node.width - padding * 2);
            const totalTextHeight = lines.length * lineHeight;
            const availableHeight = node.height - padding * 2;
            
            // 计算文本的实际渲染位置和高度
            if (totalTextHeight <= availableHeight) {
                // 文本垂直居中的情况
                const textStartY = node.y + node.height / 2 - (totalTextHeight / 2);
                editY = textStartY - padding; // 减去padding，因为编辑框会添加padding
                editHeight = totalTextHeight + padding * 2; // 加上上下padding
            } else {
                // 文本从顶部开始的情况
                editY = node.y;
                editHeight = node.height;
            }
            
            editX = node.x;
            editWidth = node.width;
        }
        
        // 更新编辑框尺寸以匹配新的节点尺寸
        // 使用worldToScreen进行坐标转换，它已经包含了缩放和画布偏移处理
        const screenPos = utils.worldToScreen(editX, editY);
        let screenWidth = editWidth * state.view.zoom;
        let screenHeight = editHeight * state.view.zoom;
        
        // 智能的四方向屏幕边界检查和位置调整，解决大文本编辑框定位问题
        let finalScreenX = screenPos.x;
        let finalScreenY = screenPos.y;
        
        // 获取工具栏高度，确保编辑框不会被工具栏遮挡
        const toolbar = document.getElementById('toolbar');
        const toolbarHeight = toolbar ? toolbar.offsetHeight : 50; // 默认50px
        const safeMargin = 10; // 安全边距
        
        // 定义可用的屏幕区域边界
        const minX = safeMargin;
        const maxX = window.innerWidth - safeMargin;
        const minY = toolbarHeight + safeMargin;
        const maxY = window.innerHeight - safeMargin;
        
        // 计算可用的最大尺寸
        const maxAvailableWidth = maxX - minX;
        const maxAvailableHeight = maxY - minY;
        
        // 1. 智能尺寸限制：如果编辑框尺寸超过屏幕，进行智能调整
        if (screenWidth > maxAvailableWidth) {
            screenWidth = maxAvailableWidth;
            // 调整编辑框宽度
        }
        
        if (screenHeight > maxAvailableHeight) {
            screenHeight = maxAvailableHeight;
            // 调整编辑框高度
        }
        
        // 2. 左侧边界检查：如果编辑框超出屏幕左侧，向右调整位置
        if (finalScreenX < minX) {
            finalScreenX = minX;
            // 向右调整编辑框位置
        }
        
        // 3. 右侧边界检查：如果编辑框超出屏幕右侧，向左调整位置
        if (finalScreenX + screenWidth > maxX) {
            finalScreenX = maxX - screenWidth;
            // 确保调整后不会超出左边界
            if (finalScreenX < minX) {
                finalScreenX = minX;
                // 如果仍然超出，进一步限制宽度
                if (finalScreenX + screenWidth > maxX) {
                    screenWidth = maxX - finalScreenX;
                    screenWidth = Math.max(minVisibleWidth, screenWidth);
                }
            }
            // 向左调整编辑框位置
        }
        
        // 4. 上方边界检查：如果编辑框超出屏幕上方（工具栏下方），向下调整位置
        if (finalScreenY < minY) {
            finalScreenY = minY;
            // 向下调整编辑框位置
        }
        
        // 5. 下方边界检查：如果编辑框超出屏幕下方，向上调整位置
        if (finalScreenY + screenHeight > maxY) {
            finalScreenY = maxY - screenHeight;
            // 确保调整后不会超出上边界
            if (finalScreenY < minY) {
                finalScreenY = minY;
                // 如果仍然超出，进一步限制高度
                if (finalScreenY + screenHeight > maxY) {
                    screenHeight = maxY - finalScreenY;
                    screenHeight = Math.max(minVisibleHeight, screenHeight);
                }
            }
            // 向上调整编辑框位置
        }
        
        // 6. 最终可见性保证：确保编辑框在可见区域内
        const originalScreenX = finalScreenX;
        const originalScreenY = finalScreenY;
        const originalScreenWidth = screenWidth;
        const originalScreenHeight = screenHeight;
        
        // 不再设置最小可见尺寸，让编辑框大小完全基于节点实际尺寸
        finalScreenX = Math.max(minX, Math.min(finalScreenX, maxX - screenWidth));
        finalScreenY = Math.max(minY, Math.min(finalScreenY, maxY - screenHeight));
        screenWidth = Math.min(screenWidth, maxX - finalScreenX);
        screenHeight = Math.min(screenHeight, maxY - finalScreenY);
        
        // 7. 改进用户体验：检测是否发生了大幅调整，如果是则自动滚动到编辑框
        const positionAdjustmentX = Math.abs(finalScreenX - originalScreenX);
        const positionAdjustmentY = Math.abs(finalScreenY - originalScreenY);
        const sizeAdjustmentW = Math.abs(screenWidth - originalScreenWidth);
        const sizeAdjustmentH = Math.abs(screenHeight - originalScreenHeight);
        
        const significantAdjustment = positionAdjustmentX > 50 || positionAdjustmentY > 50 || 
                                    sizeAdjustmentW > 100 || sizeAdjustmentH > 100;
        
        Object.assign(dom.textEditor.style, {
            left: `${finalScreenX}px`,
            top: `${finalScreenY}px`,
            width: `${screenWidth}px`,
            height: `${screenHeight}px`,
            fontSize: `${16 * state.view.zoom}px`,
            padding: `${10 * state.view.zoom}px`, // 根据缩放比例调整padding
            borderRadius: `${8 * state.view.zoom}px`,
            overflow: 'hidden', // 先设置为hidden，稍后根据内容决定是否需要滚动条
            resize: 'none', // 禁用手动调整大小
            wordWrap: 'break-word', // 自动换行
            whiteSpace: 'pre-wrap', // 保持换行符和空格
            boxSizing: 'border-box', // 确保padding不会影响总尺寸
        });
        
        // 检查是否需要滚动条 - 使用更精确的判断条件
        setTimeout(() => {
            const heightDiff = dom.textEditor.scrollHeight - dom.textEditor.clientHeight;
            const widthDiff = dom.textEditor.scrollWidth - dom.textEditor.clientWidth;
            
            // 只有当内容明显超出时才显示滚动条（容忍1-2像素的误差）
            if (heightDiff > 2 || widthDiff > 2) {
                dom.textEditor.style.overflow = 'auto';
                // 内容超出，显示滚动条
            } else {
                dom.textEditor.style.overflow = 'hidden';
                // 内容适合，隐藏滚动条
            }
        }, 10);
        
        // 如果发生了显著调整，确保编辑框在可见区域内并给用户反馈
        if (significantAdjustment) {
            // 确保编辑框可见性
            
            // 确保编辑框获得焦点，让用户知道它在哪里
            setTimeout(() => {
                if (dom.textEditor.style.display !== 'none') {
                    dom.textEditor.focus();
                    // 将光标移到文本末尾
                    const textLength = dom.textEditor.value.length;
                    dom.textEditor.setSelectionRange(textLength, textLength);
                }
            }, 50);
        }
        
        // 触发重绘
        setStateDirty();
    }

    function stopEditing() {
        if (!state.editingItem) return;
        
        // 移除实时更新监听器
        if (state.realtimeUpdateHandler) {
            dom.textEditor.removeEventListener('input', state.realtimeUpdateHandler);
            state.realtimeUpdateHandler = null;
        }
        if (state.shiftEnterHandler) {
            dom.textEditor.removeEventListener('keydown', state.shiftEnterHandler);
            state.shiftEnterHandler = null;
        }
        if (state.compositionStartHandler) {
            dom.textEditor.removeEventListener('compositionstart', state.compositionStartHandler);
            state.compositionStartHandler = null;
        }
        if (state.compositionEndHandler) {
            dom.textEditor.removeEventListener('compositionend', state.compositionEndHandler);
            state.compositionEndHandler = null;
        }
        
        // 只在当前层级查找编辑项目
        const currentLevelNodes = getCurrentLevelNodes();
        const currentLevelGroups = getCurrentLevelGroups();
        const item = currentLevelNodes.find(n => n.id === state.editingItem.id) || currentLevelGroups.find(g => g.id === state.editingItem.id);
        
        // 增强文字保护机制：确保文字不会丢失
        let newText = '';
        let textChanged = false;
        
        try {
            // 安全获取编辑框内容
            newText = dom.textEditor.value || '';
            
            // 如果编辑框为空但原始文本不为空，使用原始文本作为保护
            if (!newText.trim() && state.originalEditingText && state.originalEditingText.trim()) {
                // 文字保护机制
                newText = state.originalEditingText;
                textChanged = false; // 标记为未改变，避免不必要的更新
            } else {
                textChanged = newText !== state.originalEditingText;
            }
        } catch (error) {
            // 处理编辑框内容获取错误
            // 出错时使用原始文本作为保护
            newText = state.originalEditingText || '';
            textChanged = false;
        }
        
        if (item) {
            // 编辑项目所在层级
            if (item.type === 'node' || item.type === 'imageNode') {
                // 文字保护：确保节点文字不会意外丢失
                if (newText.trim() || !item.text) {
                    item.text = newText;
                } else {
                    // 保持原有文字
                    textChanged = false;
                }
                
                // 智能尺寸更新逻辑
                if (!textChanged) {
                    // 文本没有变化，不更新尺寸
                    // 文本未改变，保持尺寸
                } else {
                    // 文本有变化，需要智能更新尺寸
                    const wasManuallyAdjusted = item.manuallyAdjustedWidth || item.manuallyAdjustedHeight;
                    
                    if (wasManuallyAdjusted) {
                        // 如果节点被手动调整过，保持当前宽度，只更新高度
                        // 文本已改变，保持手动宽度，更新高度
                        updateNodeHeightSmart(item);
                    } else {
                        // 如果节点没有被手动调整过，使用智能更新尺寸
                        // 文本已改变，智能更新尺寸
                        updateNodeDimensionsSmart(item);
                    }
                }
            } else {
                // 组标题的文字保护
                if (newText.trim() || !item.title) {
                    item.title = newText;
                    textChanged = newText !== state.originalEditingText;
                } else {
                    // 保持原有标题
                    textChanged = false;
                }
                
                // 对于组标题，如果没有变化就不保存状态
                if (!textChanged) {
                    // 标题未改变
                }
            }
        } else {
            // 未找到编辑项目
        }
        
        // 清理编辑状态
        // textChanged 变量已在上面定义，这里不需要重复声明
            
        // 清除编辑项目状态
        state.editingItem = null;
        // 编辑项目状态已清除
        state.originalEditingText = null;
        state.originalEditingWidth = null;
        state.originalEditingHeight = null;
        
        dom.textEditor.style.display = 'none';
        
        // 重置编辑框样式为默认值
        Object.assign(dom.textEditor.style, {
            backgroundColor: 'transparent',
            color: 'inherit',
            fontSize: '16px',
            padding: '10px',
            borderRadius: '8px',
        });
        
        // 只有在文本真正改变时才保存状态
        if (textChanged) {
            // 检查并更新新节点标记
            if (item && (item.type === 'node' || item.type === 'imageNode') && item.isCreatedByUser === false) {
                item.isCreatedByUser = true; // 标记节点已经完成首次编辑
                // 节点完成首次编辑
            }
            saveState('编辑文本');
        }
        setStateDirty();
    }

    function deleteSelection() {
        const selectedNodeIds = new Set(getSelectedNodes().map(n => n.id));
        const selectedGroupIds = new Set(getSelectedGroups().map(g => g.id));
        
        if (selectedNodeIds.size === 0 && selectedGroupIds.size === 0) return;
        
        // 找出所有与选中节点关联的状态块ID
        const statusBlockIds = new Set();
        state.nodes.forEach(node => {
            if (node.isStatusBlock && selectedNodeIds.has(node.targetNodeId)) {
                statusBlockIds.add(node.id);
            }
        });

        // 从父节点集中移除被删除的节点
        selectedNodeIds.forEach(nodeId => {
            const node = state.nodes.find(n => n.id === nodeId);
            if (node && node.parentNodeSetId) {
                const parentNodeSet = state.nodes.find(n => n.id === node.parentNodeSetId && n.isNodeSet);
                if (parentNodeSet && parentNodeSet.nodeSetData && parentNodeSet.nodeSetData.childNodes) {
                    const index = parentNodeSet.nodeSetData.childNodes.indexOf(nodeId);
                    if (index > -1) {
                        parentNodeSet.nodeSetData.childNodes.splice(index, 1);
                    }
                }
            }
        });

        // 从父节点集中移除被删除的分组
        selectedGroupIds.forEach(groupId => {
            const group = state.groups.find(g => g.id === groupId);
            if (group && group.parentNodeSetId) {
                const parentNodeSet = state.nodes.find(n => n.id === group.parentNodeSetId && n.isNodeSet);
                if (parentNodeSet && parentNodeSet.nodeSetData && parentNodeSet.nodeSetData.childGroups) {
                    const index = parentNodeSet.nodeSetData.childGroups.indexOf(groupId);
                    if (index > -1) {
                        parentNodeSet.nodeSetData.childGroups.splice(index, 1);
                    }
                }
            }
        });

        // 同时删除选中的节点和关联的状态块
        state.nodes = state.nodes.filter(n => !selectedNodeIds.has(n.id) && !statusBlockIds.has(n.id));

        selectedGroupIds.forEach(groupId => {
            state.nodes.forEach(node => {
                if (node.groupId === groupId) node.groupId = null;
            });
        });
        state.groups = state.groups.filter(g => !selectedGroupIds.has(g.id));

        state.groups.forEach(group => {
            group.nodeIds = group.nodeIds.filter(id => !selectedNodeIds.has(id));
        });
        
        updateMagneticGroups();
        updateCanvasCountInfo();
        saveState('删除选中项');
        setStateDirty();
    }
    
    function copyToClipboard() {
        const selectedNodes = getSelectedNodes();
        const selectedGroups = getSelectedGroups();
        if (selectedNodes.length === 0 && selectedGroups.length === 0) return;

        const nodesToCopy = new Set(selectedNodes);
        selectedGroups.forEach(g => {
            state.nodes.filter(n => n.groupId === g.id).forEach(n => nodesToCopy.add(n));
        });

        // 收集节点集的嵌套内容
        const collectNodeSetContent = (nodeSetId, collectedNodes = new Set(), collectedGroups = new Set()) => {
            const nodeSet = state.nodes.find(n => n.id === nodeSetId && n.isNodeSet);
            if (!nodeSet || !nodeSet.nodeSetData) return;

            // 收集子节点
            if (nodeSet.nodeSetData.childNodes) {
                nodeSet.nodeSetData.childNodes.forEach(childNodeId => {
                    const childNode = state.nodes.find(n => n.id === childNodeId);
                    if (childNode) {
                        collectedNodes.add(childNode);
                        // 如果子节点也是节点集，递归收集其内容
                        if (childNode.isNodeSet) {
                            collectNodeSetContent(childNode.id, collectedNodes, collectedGroups);
                        }
                        // 收集与节点关联的状态块
                        if (!childNode.isStatusBlock) {
                            state.nodes
                                .filter(n => n.isStatusBlock && n.targetNodeId === childNode.id)
                                .forEach(statusBlock => collectedNodes.add(statusBlock));
                        }
                    }
                });
            }

            // 收集子组
            if (nodeSet.nodeSetData.childGroups) {
                nodeSet.nodeSetData.childGroups.forEach(childGroupId => {
                    const childGroup = state.groups.find(g => g.id === childGroupId);
                    if (childGroup) {
                        collectedGroups.add(childGroup);
                        // 收集组内的节点
                        state.nodes.filter(n => n.groupId === childGroup.id).forEach(n => {
                            collectedNodes.add(n);
                            // 如果组内节点也是节点集，递归收集其内容
                            if (n.isNodeSet) {
                                collectNodeSetContent(n.id, collectedNodes, collectedGroups);
                            }
                            // 收集与组内节点关联的状态块
                            if (!n.isStatusBlock) {
                                state.nodes
                                    .filter(s => s.isStatusBlock && s.targetNodeId === n.id)
                                    .forEach(statusBlock => collectedNodes.add(statusBlock));
                            }
                        });
                    }
                });
            }
        };

        // 对于选中的节点集，收集其嵌套内容
        const additionalNodes = new Set();
        const additionalGroups = new Set();
        selectedNodes.forEach(node => {
            if (node.isNodeSet) {
                collectNodeSetContent(node.id, additionalNodes, additionalGroups);
            }
            // 收集与选中节点关联的状态块
            if (!node.isStatusBlock) {
                state.nodes
                    .filter(n => n.isStatusBlock && n.targetNodeId === node.id)
                    .forEach(statusBlock => additionalNodes.add(statusBlock));
            }
        });

        // 收集与选中组内节点关联的状态块
        selectedGroups.forEach(group => {
            state.nodes
                .filter(n => n.groupId === group.id && !n.isStatusBlock)
                .forEach(node => {
                    state.nodes
                        .filter(s => s.isStatusBlock && s.targetNodeId === node.id)
                        .forEach(statusBlock => additionalNodes.add(statusBlock));
                });
        });

        // 合并所有要复制的内容
        additionalNodes.forEach(node => nodesToCopy.add(node));
        const groupsToCopy = new Set([...selectedGroups, ...additionalGroups]);

        const nodeList = Array.from(nodesToCopy);
        const groupList = Array.from(groupsToCopy);
        
        // 只使用顶层被选中的对象计算原点，忽略嵌套节点集内部的对象
        const topLevelItems = [...selectedNodes, ...selectedGroups];
        if (topLevelItems.length === 0) return;

        const origin = {
            x: Math.min(...topLevelItems.map(item => item.x)),
            y: Math.min(...topLevelItems.map(item => item.y))
        };

        // 使用序列化函数优化复制的数据结构
        const clipboardData = {
            type: 'canvas-v4.2-nodeset', // 更新版本号以支持节点集
            nodes: nodeList.map(n => {
                const serialized = serializeNode(n);
                // 状态块的坐标动态计算，不需要保存相对位置
                if (n.isStatusBlock) {
                    return serialized;
                } else {
                    return {
                        ...serialized,
                        x: n.x - origin.x,
                        y: n.y - origin.y
                    };
                }
            })
        };
        
        // 只有当组列表不为空时才添加groups字段
        if (groupList.length > 0) {
            clipboardData.groups = groupList.map(g => {
                const serialized = serializeGroup(g);
                return {
                    ...serialized,
                    x: g.x - origin.x,
                    y: g.y - origin.y
                };
            });
        }
        
        // 只有当包含节点集时才添加hasNodeSets字段
        const hasNodeSets = nodeList.some(n => n.isNodeSet);
        if (hasNodeSets) {
            clipboardData.hasNodeSets = true;
        }

        dom.clipboardHelper.value = JSON.stringify(clipboardData);
        dom.clipboardHelper.select();
        try {
            document.execCommand('copy');
        } catch (err) {
            // 复制到剪贴板失败
        }
    }
    
    // 序列化节点，减少冗余属性
    function serializeNode(node) {
        const serialized = {
            id: node.id,
            type: node.type || 'node',
        };
        
        // 对于状态块，只保存最核心属性，坐标也动态计算
        if (node.isStatusBlock) {
            // 状态块坐标、尺寸、文本等所有属性都动态计算
            // 实现理论最小JSON结构
        } else {
            // 普通节点保存必要属性
            serialized.x = node.x;
            serialized.y = node.y;
            serialized.width = node.width;
            serialized.height = node.height;
            serialized.text = node.text;
        }
        
        // 只保存必要的关系属性
        if (node.groupId) {
            serialized.groupId = node.groupId;
        }
        if (node.parentNodeSetId) {
            serialized.parentNodeSetId = node.parentNodeSetId;
        }
        
        // 只保存特殊类型的属性
        if (node.isNodeSet) {
            serialized.isNodeSet = true;
            serialized.nodeSetData = {
                childNodes: node.nodeSetData.childNodes || [],
                childGroups: node.nodeSetData.childGroups || [],
                view: node.nodeSetData.view ? {...node.nodeSetData.view} : {panX: 0, panY: 0, zoom: 1}
            };
        }
        
        if (node.isStatusBlock) {
            serialized.isStatusBlock = true;
            serialized.targetNodeId = node.targetNodeId;
            serialized.position = node.position;
            serialized.statusIndex = node.statusIndex;
            // 状态块的width、height、text、textAlign等属性在反序列化时动态计算
            // 仅保存核心属性，实现最小化JSON结构，数据量减少约80%
        }
        
        // 只保存自定义过的属性，避免JSON冗余
        if (!node.isStatusBlock) {
            // 设置默认字体但不保存到JSON
            if (!node.font) {
                node.font = 'bold 16px sans-serif';
            }
            // 只有当用户自定义过样式时才保存样式相关属性
            if (node.hasCustomStyle) {
                serialized.hasCustomStyle = true;
                serialized.backgroundColor = node.backgroundColor;
                serialized.color = node.color;
                if (node.font !== 'bold 16px sans-serif') {
                    serialized.font = node.font;
                }
            }
            // 注意：如果hasCustomStyle为false，我们不保存任何样式相关属性
        }
        if (node.imageData) {
            serialized.imageData = node.imageData;
            if (node.imageAspectRatio !== 1) {
                serialized.imageAspectRatio = node.imageAspectRatio;
            }
        }
        
        // 保存必要的对齐属性（状态块的这些属性动态计算，不保存）
        if (!node.isStatusBlock) {
            if (node.textAlign && node.textAlign !== 'left') {
                serialized.textAlign = node.textAlign;
            }
            if (node.textVerticalAlign && node.textVerticalAlign !== 'middle') {
                serialized.textVerticalAlign = node.textVerticalAlign;
            }
            // 保存wordWrap属性
            if (node.wordWrap) {
                serialized.wordWrap = node.wordWrap;
            }
            // 保存lineCount属性，用于恢复wordWrap状态
            if (node.lineCount && node.lineCount > 1) {
                serialized.lineCount = node.lineCount;
            }
        }
        
        return serialized;
    }
    
    // 序列化组，减少冗余属性
    function serializeGroup(group) {
        const serialized = {
            id: group.id,
            x: group.x,
            y: group.y,
            width: group.width,
            height: group.height,
            title: group.title,
            type: 'group',
            nodeIds: group.nodeIds || []
        };
        
        // 只保存非默认的样式属性
        if (group.color !== '#3b82f6') {
            serialized.color = group.color;
        }
        
        // 只保存必要的关系属性
        if (group.parentNodeSetId) {
            serialized.parentNodeSetId = group.parentNodeSetId;
        }
        
        // 只在非默认值时保存
        if (group.hasCustomStyle) {
            serialized.hasCustomStyle = true;
        }
        
        return serialized;
    }
    
    // 全局反序列化节点函数，用于loadState和pasteFromClipboard
    function deserializeNode(nodeData) {
        // 对于状态块，先创建基础对象，避免复制多余的动态计算属性
        let node;
        if (nodeData.isStatusBlock) {
            node = {
                id: utils.generateId(), // 为状态块生成新的唯一ID，避免粘贴时ID重复
                type: nodeData.type || 'node',
                isStatusBlock: true,
                targetNodeId: nodeData.targetNodeId,
                position: nodeData.position,
                statusIndex: nodeData.statusIndex,
                // 设置默认值
                isSelected: false,
                hasCustomStyle: true, // 状态块总是有自定义样式
                manuallyAdjustedHeight: false,
                manuallyAdjustedWidth: false,
                isCreatedByUser: false,
            };
        } else {
            node = {
                ...nodeData,
                // 设置默认值
                isSelected: false,
                hasCustomStyle: nodeData.hasCustomStyle || false,
                manuallyAdjustedHeight: false,
                manuallyAdjustedWidth: false,
                isCreatedByUser: false,
            };
        }
        
        // 设置默认样式（如果没有提供）
        if (!node.isStatusBlock) {
            // 获取当前主题颜色，确保即使主题未加载也有默认值
            const themeColors = (activeTheme && activeTheme.colors) ? activeTheme.colors : {
                nodeBg: '#ffffff',
                nodeText: '#000000',
                nodeStroke: '#e5e7eb'
            };
            
            // 非自定义样式节点使用当前主题颜色
            if (!node.hasCustomStyle && !node.isStatusBlock) {
                // 即使有backgroundColor和color属性，非自定义样式节点也应该使用主题颜色
                // 这确保了在撤销/重做时节点颜色与当前主题一致
                node.backgroundColor = themeColors.nodeBg;
                node.color = themeColors.nodeText;
                if (themeColors.nodeStroke) {
                    node.strokeColor = themeColors.nodeStroke;
                }
            }
            // 自定义样式节点但没有指定颜色时，使用固定默认值作为后备
            else {
                if (!node.backgroundColor) node.backgroundColor = '#ffffff';
                if (!node.color) node.color = themeColors.nodeText; // 使用主题文本颜色代替固定黑色
            }
            // 字体保持默认设置
            if (!node.font) node.font = 'bold 16px sans-serif';
        }
        
        // 确保节点集数据存在
        if (node.isNodeSet && !node.nodeSetData) {
            node.nodeSetData = {
                childNodes: [],
                childGroups: [],
                view: { panX: 0, panY: 0, zoom: 1 }
            };
        }
        
        // 确保状态块有必要的属性（动态计算，减少序列化数据）
        if (node.isStatusBlock) {
            // 从statusIndex动态计算所有属性
            const statusData = statusColors[node.statusIndex] || statusColors[0];
            node.text = statusData.status;
            node.backgroundColor = statusData.color;
            node.color = 'rgba(255, 255, 255, 0.7)'; // 70%亮度的白色文字
            node.font = 'bold 10px sans-serif';
            node.textAlign = 'center';
            node.textVerticalAlign = 'middle';
            node.hasCustomStyle = true;
            
            // 动态计算尺寸和位置（基于目标节点和位置方向）
            const targetNode = state.nodes.find(n => n.id === node.targetNodeId);
            if (targetNode) {
                const gridSize = state.settings.gridSize;
                
                // 根据位置方向设置尺寸
                switch (node.position) {
                    case 'top':
                    case 'bottom':
                        node.width = targetNode.width;
                        node.height = gridSize;
                        break;
                    case 'left':
                    case 'right':
                        node.width = gridSize;
                        node.height = targetNode.height;
                        break;
                }
                
                // 根据位置方向设置位置（与addStatusBlock保持一致）
                switch (node.position) {
                    case 'top':
                        node.x = targetNode.x;
                        node.y = targetNode.y - gridSize;
                        break;
                    case 'bottom':
                        node.x = targetNode.x;
                        node.y = targetNode.y + targetNode.height;
                        break;
                    case 'left':
                        node.x = targetNode.x - gridSize;
                        node.y = targetNode.y;
                        break;
                    case 'right':
                        node.x = targetNode.x + targetNode.width;
                        node.y = targetNode.y;
                        break;
                }
            }
            
            // 计算描边颜色 - 安全地获取主题颜色
            let canvasBgColor = '#ffffff'; // 默认白色背景
            if (activeTheme && activeTheme.colors && activeTheme.colors.canvasBg) {
                canvasBgColor = activeTheme.colors.canvasBg;
            } else if (state.themes && state.themes.default && state.themes.default.colors && state.themes.default.colors.canvasBg) {
                canvasBgColor = state.themes.default.colors.canvasBg;
            }
            node.strokeColor = getContrastingColor(canvasBgColor);
            node.strokeWidth = 1;
        }
        
        // 确保基本属性存在
        if (!node.type) node.type = 'node';
        
        // 恢复wordWrap属性
        if (!node.isStatusBlock) {
            // 如果有保存的wordWrap属性，直接使用
            if (nodeData.wordWrap !== undefined) {
                node.wordWrap = nodeData.wordWrap;
            }
            // 如果没有wordWrap属性但有lineCount > 1，说明需要换行
            else if (nodeData.lineCount && nodeData.lineCount > 1) {
                node.wordWrap = true;
            }
            // 确保lineCount属性也被恢复
            if (nodeData.lineCount) {
                node.lineCount = nodeData.lineCount;
            }
        }
        
        return node;
    }
    
    // 全局反序列化组函数，用于loadState和pasteFromClipboard
    function deserializeGroup(groupData) {
        const group = {
            ...groupData,
            // 设置默认值
            isSelected: false,
            hasCustomStyle: groupData.hasCustomStyle || false,
        };
        
        // 设置默认样式（如果没有提供）
        // 获取当前主题颜色，确保即使主题未加载也有默认值
        const themeColors = (activeTheme && activeTheme.colors) ? activeTheme.colors : {
            groupColor: '#3b82f6',
            textColor: '#000000'
        };
        
        // 非自定义样式组使用当前主题颜色
        if (!group.hasCustomStyle) {
            // 即使有color属性，非自定义样式组也应该使用主题颜色
            // 这确保了在撤销/重做时组颜色与当前主题一致
            group.color = themeColors.groupColor || '#3b82f6';
        }
        // 自定义样式组但没有指定颜色时，使用固定默认值作为后备
        else {
            if (!group.color) group.color = '#3b82f6';
        }
        
        // 确保基本属性存在
        if (!group.type) group.type = 'group';
        if (!group.nodeIds) group.nodeIds = [];
        
        return group;
    }
    
    function pasteFromClipboard(pastePos, text) {
        const snappedPastePos = { x: utils.snap(pastePos.x), y: utils.snap(pastePos.y) };

        try {
            const data = JSON.parse(text);
            if (data.type && data.type.startsWith('canvas-v')) {
                state.nodes.forEach(n => n.isSelected = false);
                state.groups.forEach(g => g.isSelected = false);
                
                const idMap = new Map();
                data.nodes.forEach(node => idMap.set(node.id, utils.generateId()));
                // 只有在存在groups字段时才处理组的ID映射
                if (data.groups && data.groups.length > 0) {
                    data.groups.forEach(group => idMap.set(group.id, utils.generateId()));
                }
                


                // 获取当前节点集ID
                const currentNodeSetId = state.nodeSetNavigation.currentNodeSetId;
                
                // 获取当前主题颜色，用于适应主题预设样式的节点
                const currentThemeColors = state.settings.themeColors;
                
                // 创建节点，包括节点集
                data.nodes.forEach(nodeData => {
                    // 先准备节点数据
                    const preparedNodeData = {
                        ...nodeData,
                        id: idMap.get(nodeData.id),
                        x: nodeData.x + snappedPastePos.x,
                        y: nodeData.y + snappedPastePos.y,
                        groupId: nodeData.groupId ? idMap.get(nodeData.groupId) : null,
                        // 如果原来有父节点集且在复制的数据中，则使用映射后的ID，否则使用当前层级的节点集ID
                        parentNodeSetId: (nodeData.parentNodeSetId && idMap.has(nodeData.parentNodeSetId)) ? 
                            idMap.get(nodeData.parentNodeSetId) : currentNodeSetId,
                        // 更新状态块的targetNodeId为映射后的新ID
                        targetNodeId: nodeData.targetNodeId && idMap.has(nodeData.targetNodeId) ? 
                            idMap.get(nodeData.targetNodeId) : nodeData.targetNodeId
                    };
                    
                    // 如果是节点集，需要重建其内部结构
                    if (nodeData.isNodeSet && nodeData.nodeSetData) {
                        preparedNodeData.nodeSetData = {
                            childNodes: nodeData.nodeSetData.childNodes ? 
                                nodeData.nodeSetData.childNodes.map(oldId => idMap.get(oldId)).filter(Boolean) : [],
                            childGroups: nodeData.nodeSetData.childGroups ? 
                                nodeData.nodeSetData.childGroups.map(oldId => idMap.get(oldId)).filter(Boolean) : [],
                            view: nodeData.nodeSetData.view ? {...nodeData.nodeSetData.view} : {
                                panX: 0,
                                panY: 0,
                                zoom: 1
                            }
                        };
                    }
                    
                    // 使用反序列化函数创建节点
                    const newNode = deserializeNode(preparedNodeData);
                    newNode.isSelected = true; // 设置为选中状态
                    
                    // 主题适应逻辑：如果节点不是自定义样式且不是状态块，则应用当前主题颜色
                    if (!nodeData.hasCustomStyle && currentThemeColors && !nodeData.isStatusBlock) {
                        newNode.backgroundColor = currentThemeColors.nodeBg;
                        newNode.color = currentThemeColors.nodeText;
                        if (currentThemeColors.nodeStroke) {
                            newNode.strokeColor = currentThemeColors.nodeStroke;
                        }
                    }
                    
                    state.nodes.push(newNode);
                    
                    // 只有当节点是顶层对象（其父节点集ID在本次粘贴中创建，或不存在）时，才添加到当前节点集的子列表
                    // 检查该节点是否是本次粘贴操作中某个新创建节点集的内部节点
                    const isInternalNode = nodeData.parentNodeSetId && idMap.has(nodeData.parentNodeSetId);
                    
                    // 只有顶层对象（不是内部节点）才需要关联到当前画布层级
                    if (currentNodeSetId && !isInternalNode) {
                        const parentNodeSet = state.nodes.find(n => n.id === currentNodeSetId && n.isNodeSet);
                        if (parentNodeSet && parentNodeSet.nodeSetData) {
                            // 确保不重复添加
                            if (!parentNodeSet.nodeSetData.childNodes.includes(newNode.id)) {
                                parentNodeSet.nodeSetData.childNodes.push(newNode.id);
                            }
                        }
                    }
                });

                // 创建组（只有在存在groups字段时才处理）
                if (data.groups && data.groups.length > 0) {
                    data.groups.forEach(groupData => {
                    // 先准备组数据
                    const preparedGroupData = {
                        ...groupData,
                        id: idMap.get(groupData.id),
                        x: groupData.x + snappedPastePos.x,
                        y: groupData.y + snappedPastePos.y,
                        nodeIds: groupData.nodeIds.map(oldId => idMap.get(oldId)).filter(Boolean),
                        // 设置父节点集ID为当前层级
                        parentNodeSetId: currentNodeSetId
                    };
                    
                    // 使用反序列化函数创建组
                    const newGroup = deserializeGroup(preparedGroupData);
                    newGroup.isSelected = true; // 设置为选中状态
                    
                    // 主题适应逻辑：如果分组不是自定义样式，则应用当前主题颜色
                    if (!groupData.hasCustomStyle && currentThemeColors) {
                        newGroup.color = currentThemeColors.group;
                    }
                    
                    state.groups.push(newGroup);
                    
                    // 只有当组是顶层对象（其父节点集ID在本次粘贴中创建，或不存在）时，才添加到当前节点集的子列表
                    // 检查该组是否是本次粘贴操作中某个新创建节点集的内部组
                    const isInternalGroup = groupData.parentNodeSetId && idMap.has(groupData.parentNodeSetId);
                    
                    // 只有顶层对象（不是内部组）才需要关联到当前画布层级
                    if (currentNodeSetId && !isInternalGroup) {
                        const parentNodeSet = state.nodes.find(n => n.id === currentNodeSetId && n.isNodeSet);
                        if (parentNodeSet && parentNodeSet.nodeSetData) {
                            // 确保不重复添加
                            if (!parentNodeSet.nodeSetData.childGroups.includes(newGroup.id)) {
                                parentNodeSet.nodeSetData.childGroups.push(newGroup.id);
                            }
                        }
                    }
                    });
                }

                // 如果包含节点集，显示提示信息
                if (data.hasNodeSets) {
                    // 节点集层级关系已重建
                }

                updateMagneticGroups();
                updateCanvasCountInfo(); // Update count after pasting
                updateCanvasSelectionInfo(); // Update selection info after pasting
                saveState('粘贴内容');
                setStateDirty();
                return;
            }
        } catch (e) { 
            /* Not canvas data, treat as plain text */ 
        }
        
        if (text && text.trim()) {
            // 清空之前的选择状态
            state.nodes.forEach(n => n.isSelected = false);
            state.groups.forEach(g => g.isSelected = false);
            
            // 创建新节点并选中
            createNode(pastePos.x, pastePos.y, text.trim()).isSelected = true;
            updateCanvasSelectionInfo(); // Update selection info after creating node from text
        }
    }

    function copyStyle() {
        const selectedNodes = getSelectedNodes();
        const selectedGroups = getSelectedGroups();

        if (selectedNodes.length > 0) {
            const firstNode = selectedNodes[0];
            styleClipboard.nodeStyle = {
                backgroundColor: firstNode.backgroundColor,
                color: firstNode.color
            };
        } else {
            styleClipboard.nodeStyle = null;
        }

        if (selectedGroups.length > 0) {
            const firstGroup = selectedGroups[0];
            styleClipboard.groupStyle = {
                color: firstGroup.color
            };
        } else {
            styleClipboard.groupStyle = null;
        }
    }

    function pasteStyle() {
        const selectedNodes = getSelectedNodes();
        const selectedGroups = getSelectedGroups();

        let changed = false;

        if (styleClipboard.nodeStyle && selectedNodes.length > 0) {
            selectedNodes.forEach(node => {
                node.backgroundColor = styleClipboard.nodeStyle.backgroundColor;
                node.color = styleClipboard.nodeStyle.color;
                node.hasCustomStyle = true;
            });
            changed = true;
        }

        if (styleClipboard.groupStyle && selectedGroups.length > 0) {
            selectedGroups.forEach(group => {
                group.color = styleClipboard.groupStyle.color;
                group.hasCustomStyle = true;
            });
            changed = true;
        }

        if (changed) {
            saveState('粘贴样式');
            setStateDirty();
        }
    }


    function updateMagneticGroups() {
        if (!state.settings.magneticNodes) {
            state.magneticGroups = [];
            return;
        }
        state.magneticGroups = [];
        const visited = new Set();
        const proximity = 1;
        for (const node of state.nodes) {
            if (visited.has(node.id)) continue;
            const cluster = new Set();
            const queue = [node];
            visited.add(node.id);
            while (queue.length > 0) {
                const current = queue.shift();
                cluster.add(current.id);
                for (const neighbor of state.nodes) {
                    if (visited.has(neighbor.id)) continue;
                    const r1 = { x: current.x - proximity, y: current.y - proximity, width: current.width + 2 * proximity, height: current.height + 2 * proximity };
                    if (utils.checkOverlap(r1, neighbor)) {
                        visited.add(neighbor.id);
                        queue.push(neighbor);
                    }
                }
            }
            if (cluster.size > 1) {
                state.magneticGroups.push(cluster);
            }
        }
        setStateDirty();
    }

    // 简化的组框关联更新函数
    function updateGroupAssociations() {
        const currentLevelNodes = getCurrentLevelNodes();
        const currentLevelGroups = getCurrentLevelGroups();
        
        // 为每个节点检查它是否在任何组框内
        currentLevelNodes.forEach(node => {
            let newGroupId = null;
            
            // 检查节点是否完全在某个组框内
            for (const group of currentLevelGroups) {
                const nodeCenter = {
                    x: node.x + node.width / 2,
                    y: node.y + node.height / 2
                };
                
                // 检查节点中心是否在组框内（排除标题栏区域）
                const groupContentArea = {
                    x: group.x,
                    y: group.y + (group.titleBar ? group.titleBar.height : 30), // 标题栏高度
                    width: group.width,
                    height: group.height - (group.titleBar ? group.titleBar.height : 30)
                };
                
                if (nodeCenter.x >= groupContentArea.x && 
                    nodeCenter.x <= groupContentArea.x + groupContentArea.width &&
                    nodeCenter.y >= groupContentArea.y && 
                    nodeCenter.y <= groupContentArea.y + groupContentArea.height) {
                    newGroupId = group.id;
                    break; // 找到第一个包含该节点的组框就停止
                }
            }
            
            // 如果节点的组框关联发生变化，更新它
            if (node.groupId !== newGroupId) {
                // 从旧组中移除
                if (node.groupId) {
                    const oldGroup = currentLevelGroups.find(g => g.id === node.groupId);
                    if (oldGroup && oldGroup.nodeIds) {
                        oldGroup.nodeIds = oldGroup.nodeIds.filter(id => id !== node.id);
                    }
                }
                
                // 添加到新组
                if (newGroupId) {
                    const newGroup = currentLevelGroups.find(g => g.id === newGroupId);
                    if (newGroup) {
                        if (!newGroup.nodeIds) newGroup.nodeIds = [];
                        if (!newGroup.nodeIds.includes(node.id)) {
                            newGroup.nodeIds.push(node.id);
                        }
                    }
                }
                
                node.groupId = newGroupId;
            }
        });
    }
    
    async function saveCanvas(fileName, isModule = false) {
        let nodesToSave = state.nodes;
        let groupsToSave = state.groups;

        if (isModule) {
            const selectedNodes = getSelectedNodes();
            if (selectedNodes.length === 0) {
                showPermissionError("请先选择要导出的节点");
                return;
            }
            // 直接使用选中的节点，不进行深拷贝
            nodesToSave = selectedNodes;
            const groupIds = new Set(selectedNodes.map(n => n.groupId).filter(Boolean));
            groupsToSave = state.groups.filter(g => groupIds.has(g.id));
            
            groupsToSave.forEach(group => {
                group.nodeIds = group.nodeIds.filter(id => nodesToSave.some(n => n.id === id));
            });

            const allItems = [...nodesToSave, ...groupsToSave];
            if (allItems.length === 0) return;

            // 计算最小坐标，但先不修改原始节点
            const minX = Math.min(...allItems.map(item => item.x));
            const minY = Math.min(...allItems.map(item => item.y));
        }

        // 使用序列化函数优化保存的数据结构
        const serializedNodes = nodesToSave.map(node => serializeNode(node));
        const serializedGroups = groupsToSave.map(group => serializeGroup(group));
        
        // 如果是模块导出，调整序列化后的坐标
        if (isModule) {
            const allSerializedItems = [...serializedNodes, ...serializedGroups];
            const minX = Math.min(...allSerializedItems.map(item => item.x));
            const minY = Math.min(...allSerializedItems.map(item => item.y));
            
            // 只调整序列化后的数据
            serializedNodes.forEach(n => { n.x -= minX; n.y -= minY; });
            serializedGroups.forEach(g => { g.x -= minX; g.y -= minY; });
        }
        
        const dataToSave = {
            nodes: serializedNodes
        };
        
        // 只有当groups不为空时才保存groups字段
        if (serializedGroups.length > 0) {
            dataToSave.groups = serializedGroups;
        }
        
        // 只有当不是模块且magneticGroups不为空时才保存
        if (!isModule && state.magneticGroups.length > 0) {
            dataToSave.magneticGroups = state.magneticGroups.map(cluster => Array.from(cluster));
        }
        
        // 只有当不是模块时才保存view，模块使用默认视图
        if (!isModule) {
            dataToSave.view = state.view;
        }

        const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
        
        // 对于非模块导出，尝试使用FileSystem Access API保存并获取文件句柄
        if (!isModule && supportsFileSystemAccess && !currentFileHandle) {
            try {
                // 防止重复调用文件选择器
                if (isFilePickerActive) {
                    // 如果已经有文件选择器激活，使用传统方式
                    fallbackSave();
                    return;
                }
                
                isFilePickerActive = true;
                
                const handle = await window.showSaveFilePicker({
                    suggestedName: fileName, // 不添加.json后缀
                    types: [{ description: 'JSON Files', accept: { 'application/json': ['.json'] } }],
                });
                
                const writable = await handle.createWritable();
                await writable.write(blob);
                await writable.close();
                
                // 更新画布名称和文件句柄
                const savedFileName = handle.name.replace(/\.json$/i, '');
                dom.canvasNameInput.value = savedFileName;
                // 设置当前打开的文件句柄和文件名，用于实现覆盖保存功能
                currentFileHandle = handle;
                currentOpenedFileName = handle.name;
                
                // 显示保存成功提示
                showToast('保存成功', 'success', 1500);
                
                return; // 成功保存，直接返回
            } catch (err) {
                // 检查是否是用户取消操作
                if (err.name === 'AbortError') {
                    console.log('用户取消了保存操作');
                    return; // 用户取消，直接返回，不显示任何提示
                } else {
                    console.warn('使用FileSystem Access API保存失败，回退到传统保存方式', err);
                    // 其他错误时使用传统方式作为备用
                    fallbackSave();
                }
            } finally {
                // 无论成功失败，都重置状态标志
                setTimeout(() => {
                    isFilePickerActive = false;
                }, 300);
            }
        } else {
            // 使用传统保存方式
            fallbackSave();
        }
        
        // 传统保存方式作为备用
        function fallbackSave() {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName; // 不再自动添加.json后缀，使用用户提供的原始文件名
            a.click();
            URL.revokeObjectURL(url);
            // 显示保存成功提示
            showToast('保存成功', 'success', 1500);
        }
    }

    // 跟踪当前打开的文件句柄和文件名，用于实现覆盖保存功能
    let currentFileHandle = null;
    let currentOpenedFileName = null;
    
    // 检查浏览器是否支持File System Access API
    const supportsFileSystemAccess = 'showSaveFilePicker' in window && 'showOpenFilePicker' in window;
    
    // 文件操作状态标志，防止重复调用文件选择器
    let isFilePickerActive = false;

    async function directSave() {
        const name = dom.canvasNameInput.value || '新建画布';
        
        // 智能保存逻辑：检测画布名称是否与当前打开的文件名不同
        if (currentFileHandle && currentOpenedFileName) {
            // 从文件名中移除.json后缀进行比较
            const currentFileNameWithoutExt = currentOpenedFileName.replace(/\.json$/i, '');
            if (name !== currentFileNameWithoutExt) {
                // 名称不同，触发另存为操作
                console.log('画布名称已修改，触发另存为操作');
                await saveAs(true);
                return;
            }
        }
        
        // 使用序列化函数优化保存的数据结构
        const serializedNodes = state.nodes.map(node => serializeNode(node));
        const serializedGroups = state.groups.map(group => serializeGroup(group));
        
        const dataToSave = {
            nodes: serializedNodes
        };
        
        // 只有当groups不为空时才保存groups字段
        if (serializedGroups.length > 0) {
            dataToSave.groups = serializedGroups;
        }
        
        // 只有当magneticGroups不为空时才保存
        if (state.magneticGroups.length > 0) {
            dataToSave.magneticGroups = state.magneticGroups.map(cluster => Array.from(cluster));
        }
        
        // 保存view字段
        dataToSave.view = state.view;
        const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
        
        // 如果有当前打开的文件句柄，则直接写入
        if (currentFileHandle && supportsFileSystemAccess) {
            try {
                const writable = await currentFileHandle.createWritable();
                await writable.write(blob);
                await writable.close();
                // 显示保存成功提示
                showToast('保存成功', 'success', 1500);
                return; // 成功保存，直接返回
            } catch (err) {
                // 如果写入失败，回退到saveCanvas方式
                console.warn('覆盖保存失败，回退到常规保存方式', err);
            }
        }
        
        // 使用异步的saveCanvas函数，它会处理首次保存并获取文件句柄
        await saveCanvas(name);
    }

    async function saveAs(useCurrentName = false) {
        // 防止重复调用文件选择器
        if (isFilePickerActive) {
            return;
        }
        
        isFilePickerActive = true;
        
        try {
            // 如果useCurrentName为true（从directSave调用），使用当前名称；否则添加"_副本"后缀
            const suggestedName = useCurrentName ? 
                (dom.canvasNameInput.value || '新建画布') : 
                (dom.canvasNameInput.value || '新建画布') + '_副本';
            
            // 使用序列化函数优化保存的数据结构
            const serializedNodes = state.nodes.map(node => serializeNode(node));
            const serializedGroups = state.groups.map(group => serializeGroup(group));
        
            const dataToSave = {
                nodes: serializedNodes
            };
            
            // 只有当groups不为空时才保存groups字段
            if (serializedGroups.length > 0) {
                dataToSave.groups = serializedGroups;
            }
            
            // 只有当magneticGroups不为空时才保存
            if (state.magneticGroups.length > 0) {
                dataToSave.magneticGroups = state.magneticGroups.map(cluster => Array.from(cluster));
            }
            
            // 保存view字段
            dataToSave.view = state.view;
            const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
            
            if (supportsFileSystemAccess) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: suggestedName, // 不添加.json后缀
                        types: [{ description: 'JSON Files', accept: { 'application/json': ['.json'] } }],
                    });
                    
                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    
                    // 更新画布名称和文件句柄
                    const savedFileName = handle.name.replace(/\.json$/i, '');
                    dom.canvasNameInput.value = savedFileName;
                    // 设置当前打开的文件句柄和文件名，用于实现覆盖保存功能
                    currentFileHandle = handle;
                    currentOpenedFileName = handle.name;
                    
                    // 显示另存为成功提示
                    showToast('另存为成功', 'success', 1500);
                } catch (err) {
                    // 检查是否是用户取消操作
                    if (err.name === 'AbortError') {
                        console.log('用户取消了另存为操作');
                        return; // 用户取消，直接返回，不显示任何提示
                    } else {
                        console.warn('保存文件失败', err);
                        // 其他错误时使用传统方式作为备用
                        saveCanvas(suggestedName);
                    }
                }
            } else {
                // 不支持File System Access API时使用传统方式
                saveCanvas(suggestedName);
                // Update canvas name input with the saved file name for fallback save method
                dom.canvasNameInput.value = suggestedName;
                currentOpenedFileName = null;
                // 显示另存为成功提示
                showToast('另存为成功', 'success', 1500);
            }
        } finally {
            // 无论成功失败，都重置状态标志
            setTimeout(() => {
                isFilePickerActive = false;
            }, 300);
        }
    }

    // ===================================================================================
    // 自动保存功能
    // ===================================================================================
    
    // 初始化IndexedDB
    async function initAutoSaveDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('CanvasAutoSave', 1);
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                autoSaveDB = request.result;
                resolve(autoSaveDB);
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains('realtimeBackup')) {
                    db.createObjectStore('realtimeBackup', { keyPath: 'id' });
                }
            };
        });
    }

    // 常规自动保存（5个文件循环）
    async function performAutoSave() {
        if (!state.settings.autoSaveEnabled || (state.nodes.length === 0 && state.groups.length === 0)) {
            return;
        }

        try {
            // 检查是否为localhost
            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            
            // 准备保存数据
            const serializedNodes = state.nodes.map(node => serializeNode(node));
            const serializedGroups = state.groups.map(group => serializeGroup(group));
            
            const dataToSave = {
                nodes: serializedNodes,
                timestamp: new Date().toISOString(),
                canvasName: dom.canvasNameInput.value || '新建画布'
            };
            
            if (serializedGroups.length > 0) {
                dataToSave.groups = serializedGroups;
            }
            
            if (state.magneticGroups.length > 0) {
                dataToSave.magneticGroups = state.magneticGroups.map(cluster => Array.from(cluster));
            }
            
            dataToSave.view = state.view;

            const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
            
            // 生成文件名
            const fileName = `自动保存${String(autoSaveFileIndex + 1).padStart(2, '0')}.json`;
            
            if (supportsFileSystemAccess && isLocalhost) {
                // localhost环境下尝试静默保存，避免弹窗
                try {
                    // 尝试使用之前保存的文件句柄（如果存在）
                    if (window.autoSaveFileHandles && window.autoSaveFileHandles[autoSaveFileIndex]) {
                        const handle = window.autoSaveFileHandles[autoSaveFileIndex];
                        const writable = await handle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                        updateAutoSaveStatus(`已保存: ${fileName}`);
                    } else {
                        // 首次保存或句柄不存在时，使用传统方式避免弹窗
                        fallbackAutoSave(blob, fileName);
                    }
                } catch (err) {
                    // 如果出错，使用传统方式
                    fallbackAutoSave(blob, fileName);
                }
            } else {
                // 非localhost环境或不支持FileSystem API时使用传统方式
                fallbackAutoSave(blob, fileName);
            }
            
            // 更新文件索引（循环0-4）
            autoSaveFileIndex = (autoSaveFileIndex + 1) % 5;
            
        } catch (error) {
            console.warn('自动保存失败:', error);
            updateAutoSaveStatus('保存失败');
        }
    }

    // 传统自动保存方式
    function fallbackAutoSave(blob, fileName) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        updateAutoSaveStatus(`已下载: ${fileName}`);
    }

    // 实时备份保存到IndexedDB
    async function performRealtimeBackup() {
        if (!state.settings.realtimeBackupEnabled || !autoSaveDB || (state.nodes.length === 0 && state.groups.length === 0)) {
            return;
        }

        try {
            const serializedNodes = state.nodes.map(node => serializeNode(node));
            const serializedGroups = state.groups.map(group => serializeGroup(group));
            
            const backupData = {
                id: 'realtimeBackup',
                nodes: serializedNodes,
                groups: serializedGroups,
                magneticGroups: state.magneticGroups.map(cluster => Array.from(cluster)),
                view: state.view,
                timestamp: new Date().toISOString(),
                canvasName: dom.canvasNameInput.value || '新建画布'
            };

            const transaction = autoSaveDB.transaction(['realtimeBackup'], 'readwrite');
            const store = transaction.objectStore('realtimeBackup');
            await store.put(backupData);
            
        } catch (error) {
            console.warn('实时备份失败:', error);
        }
    }

    // 实时JSON文件保存变量
    let realtimeJsonFileHandle = null;

    // 实时JSON文件保存函数
    async function performRealtimeJsonSave() {
        if (!state.settings.autoSaveEnabled || (state.nodes.length === 0 && state.groups.length === 0)) {
            return;
        }

        try {
            // 检查是否为localhost
            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            
            if (!isLocalhost) {
                return; // 只在localhost环境下执行
            }
            
            // 准备保存数据
            const serializedNodes = state.nodes.map(node => serializeNode(node));
            const serializedGroups = state.groups.map(group => serializeGroup(group));
            
            const dataToSave = {
                nodes: serializedNodes,
                timestamp: new Date().toISOString(),
                canvasName: dom.canvasNameInput.value || '新建画布'
            };
            
            if (serializedGroups.length > 0) {
                dataToSave.groups = serializedGroups;
            }
            
            if (state.magneticGroups.length > 0) {
                dataToSave.magneticGroups = state.magneticGroups.map(cluster => Array.from(cluster));
            }
            
            dataToSave.view = state.view;

            const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
            const fileName = '画布实时备份.json';
            
            if (supportsFileSystemAccess) {
                try {
                    // 尝试使用之前保存的文件句柄（如果存在）
                    if (realtimeJsonFileHandle) {
                        const writable = await realtimeJsonFileHandle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                    } else {
                        // 首次保存时，尝试获取文件句柄，但不强制用户选择
                        // 如果用户没有选择文件位置，就跳过这次保存
                        // 这样可以避免频繁弹出文件选择器
                        console.log('实时JSON文件保存需要用户首次选择保存位置');
                    }
                } catch (err) {
                    console.warn('实时JSON文件保存失败:', err);
                }
            } else {
                // 不支持FileSystem API时，使用静默下载方式
                // 但为了避免频繁下载，我们限制下载频率
                if (!window.lastRealtimeJsonSave || Date.now() - window.lastRealtimeJsonSave > 10000) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    a.style.display = 'none';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    window.lastRealtimeJsonSave = Date.now();
                }
            }
            
        } catch (error) {
            console.warn('实时JSON文件保存失败:', error);
        }
    }

    // 手动触发实时JSON文件保存位置选择
    async function initRealtimeJsonSave() {
        if (!supportsFileSystemAccess) {
            console.log('浏览器不支持FileSystem API，将使用下载方式');
            return true; // 不支持FileSystem API时返回true，允许继续
        }

        try {
            const fileName = '画布实时备份.json';
            realtimeJsonFileHandle = await window.showSaveFilePicker({
                suggestedName: fileName,
                types: [{
                    description: 'JSON files',
                    accept: { 'application/json': ['.json'] }
                }]
            });
            console.log('实时JSON文件保存位置已设置');
            return true; // 成功选择文件位置
        } catch (err) {
            console.log('用户取消了实时JSON文件保存位置设置');
            return false; // 用户取消了文件选择
        }
    }

    // 启动自动保存
    function startAutoSave() {
        if (autoSaveTimer) {
            clearInterval(autoSaveTimer);
        }
        if (realtimeJsonSaveTimer) {
            clearInterval(realtimeJsonSaveTimer);
        }

        // 启动常规自动保存（5分钟间隔）
        autoSaveTimer = setInterval(performAutoSave, state.settings.autoSaveInterval);
        
        // 启动实时JSON文件保存（每秒一次）
        realtimeJsonSaveTimer = setInterval(performRealtimeJsonSave, 1000);
        
        updateAutoSaveStatus('已启用');
    }

    // 停止自动保存
    function stopAutoSave() {
        if (autoSaveTimer) {
            clearInterval(autoSaveTimer);
            autoSaveTimer = null;
        }
        if (realtimeJsonSaveTimer) {
            clearInterval(realtimeJsonSaveTimer);
            realtimeJsonSaveTimer = null;
        }
        
        updateAutoSaveStatus('已关闭');
    }

    // 启动实时备份
    function startRealtimeBackup() {
        if (realtimeBackupTimer) {
            clearInterval(realtimeBackupTimer);
        }

        // 启动实时备份（1秒间隔）
        realtimeBackupTimer = setInterval(performRealtimeBackup, state.settings.realtimeBackupInterval);
        
        updateRealtimeBackupStatus('已启用');
    }

    // 停止实时备份
    function stopRealtimeBackup() {
        if (realtimeBackupTimer) {
            clearInterval(realtimeBackupTimer);
            realtimeBackupTimer = null;
        }
        
        updateRealtimeBackupStatus('已关闭');
    }

    // 切换自动保存状态
    async function toggleAutoSave() {
        state.settings.autoSaveEnabled = !state.settings.autoSaveEnabled;
        
        if (state.settings.autoSaveEnabled) {
            // 初始化IndexedDB（如果还没有初始化）
            if (!autoSaveDB) {
                try {
                    await initAutoSaveDB();
                } catch (error) {
                    console.error('初始化IndexedDB失败:', error);
                    state.settings.autoSaveEnabled = false;
                    updateAutoSaveStatus('初始化失败');
                    return;
                }
            }
            
            // 检查是否为localhost环境，如果是则初始化实时JSON文件保存
            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            if (isLocalhost && supportsFileSystemAccess && !realtimeJsonFileHandle) {
                // 在localhost环境下首次启用自动保存时，提示用户选择实时JSON文件保存位置
                const fileSelectionSuccess = await initRealtimeJsonSave();
                if (!fileSelectionSuccess) {
                    // 用户取消了文件选择，重置自动保存状态
                    state.settings.autoSaveEnabled = false;
                    dom.autoSaveToggleBtn.classList.remove('active');
                    console.log('用户取消文件选择，自动保存功能未启用');
                    return;
                }
            }
            
            startAutoSave();
            dom.autoSaveToggleBtn.classList.add('active');
        } else {
            stopAutoSave();
            dom.autoSaveToggleBtn.classList.remove('active');
        }
    }

    // 更新自动保存状态显示
    function updateAutoSaveStatus(message) {
        // 不再显示状态文字，状态通过按钮的active类来表示
        // 这个函数保留是为了兼容性，但不执行任何操作
    }

    // 更新实时备份状态显示
    function updateRealtimeBackupStatus(message) {
        // 不再显示状态文字，状态通过按钮的active类来表示
        // 这个函数保留是为了兼容性，但不执行任何操作
    }

    // 切换实时备份状态
    async function toggleRealtimeBackup() {
        state.settings.realtimeBackupEnabled = !state.settings.realtimeBackupEnabled;
        
        if (state.settings.realtimeBackupEnabled) {
            // 初始化IndexedDB（如果还没有初始化）
            if (!autoSaveDB) {
                try {
                    await initAutoSaveDB();
                } catch (error) {
                    console.error('初始化IndexedDB失败:', error);
                    state.settings.realtimeBackupEnabled = false;
                    updateRealtimeBackupStatus('初始化失败');
                    return;
                }
            }
            
            startRealtimeBackup();
            dom.realtimeBackupToggleBtn.classList.add('active');
        } else {
            stopRealtimeBackup();
            dom.realtimeBackupToggleBtn.classList.remove('active');
        }
    }

    // 从实时备份恢复数据
    async function loadFromRealtimeBackup() {
        if (!autoSaveDB) {
            try {
                await initAutoSaveDB();
            } catch (error) {
                console.error('无法访问备份数据:', error);
                return null;
            }
        }

        try {
            const transaction = autoSaveDB.transaction(['realtimeBackup'], 'readonly');
            const store = transaction.objectStore('realtimeBackup');
            const request = store.get('realtimeBackup');
            
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        } catch (error) {
            console.error('读取备份数据失败:', error);
            return null;
        }
    }

    // 初始化自动保存系统
    async function initializeAutoSave() {
        try {
            // 初始化IndexedDB
            await initAutoSaveDB();
            
            // 初始化文件句柄存储（用于localhost环境）
            if (!window.autoSaveFileHandles) {
                window.autoSaveFileHandles = {};
            }
            
            // 检查是否为localhost环境
            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            
            if (isLocalhost) {
                console.log('检测到localhost环境，自动保存将使用优化模式');
            }
            
            updateAutoSaveStatus('已初始化');
        } catch (error) {
            console.error('自动保存系统初始化失败:', error);
            updateAutoSaveStatus('初始化失败');
        }
    }

    // 传统的文件输入加载函数，作为File System Access API的后备
    async function loadCanvas(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        try {
            // 使用现代的File.text()方法代替FileReader
            const fileContent = await file.text();
            
            // 调用新的处理函数，使用null作为文件句柄（因为传统方式没有文件句柄）
            await processLoadedFileContent(fileContent, null);
            
            // 设置文件名，但没有文件句柄
            dom.canvasNameInput.value = file.name.replace(/\.json$/i, '');
            currentFileHandle = null;
            currentOpenedFileName = file.name;
            
            // 显示加载成功提示
            showToast('文件加载成功', 'success', 1500);
            
        } catch (error) {
            alert('加载文件失败！请检查文件格式是否正确。');
        } finally {
            // 清空文件输入，允许重复选择同一文件
            event.target.value = '';
        }
    }

    function convertMarkdownToNodes() {
        // 显示MD导入弹窗
        showMdConvertModal();
    }

    // JSON格式检测辅助函数
    function isValidJSON(text) {
        try {
            const parsed = JSON.parse(text.trim());
            return parsed && typeof parsed === 'object';
        } catch {
            return false;
        }
    }
    
    function isHierarchicalJSON(obj) {
        // 检测是否包含 name 字段
        if (typeof obj.name === 'string') {
            return true;
        }
        
        // 检测是否包含 children 数组
        if (Array.isArray(obj.children)) {
            return true;
        }
        
        // 检测是否为节点数组
        if (Array.isArray(obj) && obj.some(item => 
            item && typeof item.name === 'string'
        )) {
            return true;
        }
        
        return false;
    }

    // 检测缩进式层级结构
    function hasIndentedHierarchy(text) {
        if (!text || typeof text !== 'string') {
            return false;
        }
        
        const lines = text.split('\n').filter(line => line.trim().length > 0);
        
        // 至少需要2行内容
        if (lines.length < 2) {
            return false;
        }
        
        let hasIndentation = false;
        let indentLevels = new Set();
        
        for (const line of lines) {
            // 计算行首的缩进（空格或Tab）
            const match = line.match(/^(\s*)/);
            const indentLength = match ? match[1].length : 0;
            
            // 检测是否包含Tab字符
            const hasTab = line.startsWith('\t');
            
            // 如果有缩进（空格或Tab），记录缩进级别
            if (indentLength > 0 || hasTab) {
                hasIndentation = true;
                if (hasTab) {
                    // 计算Tab的数量
                    const tabCount = (line.match(/^\t*/)[0] || '').length;
                    indentLevels.add(tabCount);
                } else {
                    // 将空格数量转换为缩进级别（假设每4个空格为一级）
                    indentLevels.add(Math.floor(indentLength / 4));
                }
            } else {
                indentLevels.add(0); // 无缩进为0级
            }
        }
        
        // 检查是否有层级结构：至少有2个不同的缩进级别
        return hasIndentation && indentLevels.size >= 2;
    }

    // 检测是否为标准项目JSON文件格式
    function isStandardProjectJSON(obj) {
        if (!obj || typeof obj !== 'object') {
            return false;
        }
        
        // 检查是否包含标准项目文件的关键字段
        const hasNodes = Array.isArray(obj.nodes);
        const hasGroups = obj.groups !== undefined;
        const hasCanvasData = obj.canvasData !== undefined;
        
        // 如果有nodes数组，检查节点结构
        if (hasNodes && obj.nodes.length > 0) {
            const firstNode = obj.nodes[0];
            // 检查节点是否包含标准字段：id, x, y, width, height, text等
            const hasStandardNodeFields = firstNode.id && 
                                        typeof firstNode.x === 'number' && 
                                        typeof firstNode.y === 'number' && 
                                        typeof firstNode.width === 'number' && 
                                        typeof firstNode.height === 'number';
            if (hasStandardNodeFields) {
                return true;
            }
        }
        
        // 检查其他标准项目文件特征
        if (hasGroups || hasCanvasData) {
            return true;
        }
        
        return false;
    }

    // 可导入内容检测算法（支持Markdown和JSON格式）
    function isImportableContent(text) {
        if (!text || typeof text !== 'string' || text.trim().length === 0) {
            return false;
        }
        
        const trimmedText = text.trim();
        
        // 首先检查是否为标准项目JSON文件格式，如果是则直接返回false
        if (isValidJSON(trimmedText)) {
            try {
                const parsed = JSON.parse(trimmedText.trim());
                // 检查是否为标准项目文件格式（包含nodes、groups等字段）
                if (isStandardProjectJSON(parsed)) {
                    return false; // 标准项目文件不应被识别为Markdown
                }
                // 只有非标准项目文件的层级JSON才可能是Markdown导出的JSON
                return isHierarchicalJSON(parsed);
            } catch (error) {
                // JSON解析失败，继续检查Markdown语法
            }
        }
        
        // 检测标题标记 (# ## ### 等)
        if (/^#{1,6}\s+.+$/m.test(trimmedText)) {
            return true;
        }
        
        // 检测无序列表标记 (- * +)
        if (/^[\s]*[-*+]\s+.+$/m.test(trimmedText)) {
            return true;
        }
        
        // 检测有序列表 (1. 2. 等)
        if (/^[\s]*\d+\.\s+.+$/m.test(trimmedText)) {
            return true;
        }
        
        // 检测代码块 (```)
        if (/```[\s\S]*```/.test(trimmedText)) {
            return true;
        }
        
        // 检测链接 [text](url)
        if (/\[.+\]\(.+\)/.test(trimmedText)) {
            return true;
        }
        
        // 检测粗体 **text** 或 __text__
        if (/\*\*.+\*\*/.test(trimmedText) || /__.+__/.test(trimmedText)) {
            return true;
        }
        
        // 检测斜体 *text* 或 _text_
        if (/\*.+\*/.test(trimmedText) || /_.+_/.test(trimmedText)) {
            return true;
        }
        
        // 检测行内代码 `code`
        if (/`.+`/.test(trimmedText)) {
            return true;
        }
        
        // 检测引用 > text
        if (/^[\s]*>.+$/m.test(trimmedText)) {
            return true;
        }
        
        // 检测水平分割线 --- 或 ***
        if (/^[\s]*(-{3,}|\*{3,})[\s]*$/m.test(trimmedText)) {
            return true;
        }
        
        // 检测缩进式层级结构（新增）
        if (hasIndentedHierarchy(trimmedText)) {
            return true;
        }
        
        return false;
    }

    // 智能位置计算：计算现有节点边界并确定新内容位置
    function calculateSmartImportPosition() {
        const allNodes = state.nodes;
        
        // 如果画布为空，使用默认位置
        if (!allNodes || allNodes.length === 0) {
            return { x: 960, y: 300 };
        }
        
        // 计算所有现有节点的边界框
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        allNodes.forEach(node => {
            const nodeLeft = node.x;
            const nodeRight = node.x + node.width;
            const nodeTop = node.y;
            const nodeBottom = node.y + node.height;
            
            minX = Math.min(minX, nodeLeft);
            maxX = Math.max(maxX, nodeRight);
            minY = Math.min(minY, nodeTop);
            maxY = Math.max(maxY, nodeBottom);
        });
        
        // 计算新内容的起始位置
        // 策略：在现有内容右侧留出间距后开始
        const horizontalGap = 400; // 水平间距
        const newX = maxX + horizontalGap;
        const newY = minY; // 与现有内容顶部对齐
        

        
        return { x: newX, y: newY };
    }

    // MD导入弹窗相关函数
    function showMdConvertModal() {
        dom.mdConvertModalBackdrop.style.display = 'flex';
        dom.mdInputTextarea.value = ''; // 清空输入框
        
        // 临时禁用画布的键盘事件监听器
        document.removeEventListener('paste', handlePaste);
        window.removeEventListener('keydown', handleKeyDown);
        
        // 聚焦到文本输入区域
        setTimeout(() => {
            dom.mdInputTextarea.focus();
        }, 100);
    }

    function hideMdConvertModal() {
        dom.mdConvertModalBackdrop.style.display = 'none';
        
        // 恢复画布的键盘事件监听器
        document.addEventListener('paste', handlePaste);
        window.addEventListener('keydown', handleKeyDown);
    }

    function parseMarkdownText(markdownText) {
        try {
            const trimmedText = markdownText.trim();
            
            // 检查是否是JSON格式
            if (trimmedText.startsWith('{') || trimmedText.startsWith('[')) {
                try {
                    const jsonData = JSON.parse(trimmedText);
                    const result = parseJsonStructure(jsonData);
                    return Array.isArray(result) ? result : [];
                } catch (e) {
                    // JSON解析失败
                    // 如果JSON解析失败，继续按markdown处理
                }
            }
            
            // 处理markdown格式
            const result = parseMarkdownStructure(trimmedText);
            return Array.isArray(result) ? result : [];
        } catch (error) {
            // Markdown解析失败
            return [];
        }
    }
    
    function parseJsonStructure(jsonData) {
        const parsedItems = [];
        
        function traverseNode(node, level = 1, parentIndex = -1) {
            if (!node || !node.name) return;
            
            const currentIndex = parsedItems.length;
            parsedItems.push({
                text: node.name,
                level: level,
                parentIndex: parentIndex,
                index: currentIndex,
                childCount: node.children ? node.children.length : 0
            });
            
            // 递归处理子节点
            if (node.children && Array.isArray(node.children)) {
                for (const child of node.children) {
                    traverseNode(child, level + 1, currentIndex);
                }
            }
        }
        
        traverseNode(jsonData);
        return parsedItems;
    }
    
    function parseMarkdownStructure(markdownText) {
        const lines = markdownText.split('\n').filter(line => line.trim());
        const parsedItems = [];
        
        // 跟踪父级关系
        const levelStack = []; // 存储每个层级的最后一个节点索引
        
        for (const line of lines) {
            const trimmedLine = line.trim();
            
            // 处理标题格式 (# ## ###)
            if (trimmedLine.startsWith('#')) {
                // 计算标题层级
                const level = trimmedLine.match(/^#+/)[0].length;
                const text = trimmedLine.replace(/^#+\s*/, '');
                
                if (text && level <= 3) { // 只支持1-3级标题
                    // 更新层级栈
                    levelStack[level - 1] = parsedItems.length;
                    // 清除更深层级的记录
                    levelStack.splice(level);
                    
                    // 找到父级节点索引
                    let parentIndex = -1;
                    if (level > 1 && levelStack[level - 2] !== undefined) {
                        parentIndex = levelStack[level - 2];
                    }
                    
                    parsedItems.push({
                        text: text,
                        level: level,
                        parentIndex: parentIndex,
                        index: parsedItems.length,
                        childCount: 0 // 将在后续计算
                    });
                }
            }
            // 处理缩进式层级结构
            else if (line.match(/^[\s\t]+\S/)) {
                // 计算缩进层级
                let level = 1;
                const text = trimmedLine;
                
                // 检测Tab缩进
                if (line.startsWith('\t')) {
                    const tabCount = (line.match(/^\t*/)[0] || '').length;
                    level = tabCount + 1; // Tab缩进，每个Tab为一级
                } else {
                    // 检测空格缩进
                    const spaceMatch = line.match(/^(\s*)/);
                    const spaceCount = spaceMatch ? spaceMatch[1].length : 0;
                    level = Math.floor(spaceCount / 4) + 1; // 每4个空格为一级
                }
                
                // 移除层级限制，支持无限层级
                
                if (text) {
                    // 更新层级栈
                    levelStack[level - 1] = parsedItems.length;
                    // 清除更深层级的记录
                    levelStack.splice(level);
                    
                    // 找到父级节点索引
                    let parentIndex = -1;
                    if (level > 1 && levelStack[level - 2] !== undefined) {
                        parentIndex = levelStack[level - 2];
                    }
                    
                    parsedItems.push({
                        text: text,
                        level: level,
                        parentIndex: parentIndex,
                        index: parsedItems.length,
                        childCount: 0 // 将在后续计算
                    });
                }
            }
            // 处理无缩进的顶级内容
            else if (trimmedLine && !trimmedLine.startsWith('#')) {
                // 无缩进的内容作为1级节点
                const level = 1;
                const text = trimmedLine;
                
                // 更新层级栈
                levelStack[level - 1] = parsedItems.length;
                // 清除更深层级的记录
                levelStack.splice(level);
                
                parsedItems.push({
                    text: text,
                    level: level,
                    parentIndex: -1, // 顶级节点没有父级
                    index: parsedItems.length,
                    childCount: 0 // 将在后续计算
                });
            }
        }
        
        // 计算每个节点的子节点数量
        for (let i = 0; i < parsedItems.length; i++) {
            const item = parsedItems[i];
            let childCount = 0;
            
            for (let j = i + 1; j < parsedItems.length; j++) {
                const nextItem = parsedItems[j];
                if (nextItem.parentIndex === i) {
                    childCount++;
                } else if (nextItem.level <= item.level) {
                    break;
                }
            }
            
            item.childCount = childCount;
        }
        
        return parsedItems;
    }

    // 精确测量文字宽度的函数
    function measureTextWidth(text, font = "bold 16px sans-serif") {
        // 创建临时canvas用于测量文字宽度
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.font = font;
        return ctx.measureText(text).width;
    }

    // 智能换行函数
    function calculateTextLines(text, maxWidth, font = "bold 16px sans-serif") {
        const padding = 20; // 节点内边距
        const availableWidth = maxWidth - padding;
        
        // 如果文字宽度小于可用宽度，不需要换行
        const textWidth = measureTextWidth(text, font);
        if (textWidth <= availableWidth) {
            return {
                lines: [text],
                lineCount: 1
            };
        }
        
        // 需要换行，智能断行
        const lines = [];
        let currentLine = '';
        const words = text.split('');
        
        // 优先在空格、标点符号处断行的字符
        const breakChars = [' ', '，', '。', '、', '；', '：', '！', '？', ',', '.', ';', ':', '!', '?'];
        
        for (let i = 0; i < words.length; i++) {
            const char = words[i];
            const testLine = currentLine + char;
            const testWidth = measureTextWidth(testLine, font);
            
            if (testWidth <= availableWidth) {
                currentLine = testLine;
            } else {
                // 当前字符会超出宽度
                if (currentLine.length === 0) {
                    // 如果当前行为空，强制添加至少一个字符
                    currentLine = char;
                    lines.push(currentLine);
                    currentLine = '';
                } else {
                    // 尝试在合适的位置断行
                    let breakIndex = -1;
                    for (let j = currentLine.length - 1; j >= 0; j--) {
                        if (breakChars.includes(currentLine[j])) {
                            breakIndex = j;
                            break;
                        }
                    }
                    
                    if (breakIndex > 0 && currentLine.length - breakIndex < currentLine.length / 2) {
                        // 在标点处断行
                        lines.push(currentLine.substring(0, breakIndex + 1));
                        currentLine = currentLine.substring(breakIndex + 1) + char;
                    } else {
                        // 直接断行
                        lines.push(currentLine);
                        currentLine = char;
                    }
                }
            }
        }
        
        // 添加最后一行
        if (currentLine.length > 0) {
            lines.push(currentLine);
        }
        
        return {
            lines: lines,
            lineCount: lines.length
        };
    }

    // 计算基于行数的节点高度
    function calculateNodeHeight(lineCount, baseHeight = 40, lineHeight = 20) {
        return baseHeight + (lineCount - 1) * lineHeight;
    }

    function generateNodesFromMarkdown(parsedItems, importPosition = { x: 960, y: 300 }) {
        // 验证输入参数
        if (!Array.isArray(parsedItems)) {
            // parsedItems不是数组
            alert('解析失败：数据格式错误！');
            return null;
        }
        
        if (parsedItems.length === 0) {
            alert('没有找到有效的标题内容！');
            return null;
        }

        const nodes = [];
        const groupId = `md_group_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        // 布局参数
        const startX = importPosition.x;  // 起始X坐标（使用智能计算的位置）
        const startY = importPosition.y;  // 起始Y坐标（使用智能计算的位置）
        const baseNodeHeight = 40;  // 基础节点高度
        const lineHeight = 20;  // 行高
        const font = "bold 16px sans-serif";  // 字体
        const minSpacing = 0;  // 无缝衔接，无间距
        
        // 第一遍：计算每级的统一宽度（基于精确文字测量）
        const levelWidths = {};
        const maxLevel = Math.max(...parsedItems.map(item => item.level));
        
        for (let level = 1; level <= maxLevel; level++) {
            const nodesAtLevel = parsedItems.filter(item => item.level === level);
            if (nodesAtLevel.length > 0) {
                // 计算该级别的统一宽度（基于最长文本的实际宽度）
                const maxTextWidth = Math.max(...nodesAtLevel.map(item => measureTextWidth(item.text, font)));
                let uniformWidth;
                
                // 根据实际文字宽度确定节点宽度，加上内边距
                const requiredWidth = maxTextWidth + 40; // 40px内边距
                
                if (requiredWidth <= 120) {
                    uniformWidth = 120;
                } else if (requiredWidth <= 140) {
                    uniformWidth = 140;
                } else if (requiredWidth <= 200) {
                    uniformWidth = 200;
                } else if (requiredWidth <= 280) {
                    uniformWidth = 280;
                } else {
                    // 对于超长文本，使用280px并允许换行
                    uniformWidth = 280;
                }
                
                levelWidths[level] = uniformWidth;
            }
        }
        
        // 计算每级之间的动态间距（基于实际节点宽度，实现无缝衔接）
        const levelSpacings = {};
        for (let level = 1; level < maxLevel; level++) {
            const currentLevelWidth = levelWidths[level] || 120;
            // 无缝衔接：下一级节点直接从当前级节点右边缘开始
            levelSpacings[level] = currentLevelWidth;
        }
        
        // 第二遍：基于宽度计算每个节点的文字行数和实际高度
        const nodeData = parsedItems.map((item, index) => ({
            ...item,
            index: index,
            width: levelWidths[item.level],
            height: 0,  // 待计算
            x: 0,       // 待计算
            y: 0,       // 待计算
            lineCount: 0,  // 文字行数
            textLines: []  // 文字行内容
        }));
        
        // 为每个节点计算文字行数和基础高度
        for (let i = 0; i < nodeData.length; i++) {
            const node = nodeData[i];
            const textInfo = calculateTextLines(node.text, node.width, font);
            node.lineCount = textInfo.lineCount;
            node.textLines = textInfo.lines;
            node.baseHeight = calculateNodeHeight(node.lineCount, baseNodeHeight, lineHeight);
        }
        
        // 第三遍：自底向上重新计算父节点高度（子节点实际高度之和）
        function calculateHeight(nodeIndex) {
            const node = nodeData[nodeIndex];
            
            // 找到所有直接子节点
            const directChildren = nodeData.filter(n => n.parentIndex === nodeIndex);
            
            if (directChildren.length === 0) {
                // 叶子节点：使用基于文字行数计算的高度
                node.height = node.baseHeight;
            } else {
                // 父节点：高度 = 所有直接子节点高度之和
                let totalChildHeight = 0;
                for (const child of directChildren) {
                    if (child.height === 0) {
                        calculateHeight(child.index);  // 递归计算子节点高度
                    }
                    totalChildHeight += child.height;
                }
                node.height = totalChildHeight;
            }
        }
        
        // 为所有节点计算最终高度
        for (let i = 0; i < nodeData.length; i++) {
            if (nodeData[i].height === 0) {
                calculateHeight(i);
            }
        }
        
        // 第四遍：自顶向下计算最终位置
        const levelCurrentY = {}; // 跟踪每个层级的当前Y位置
        
        function calculatePosition(nodeIndex, parentY = null) {
            const node = nodeData[nodeIndex];
            
            // 计算X坐标：基于动态间距，实现完全无缝衔接
            if (node.level === 1) {
                node.x = startX;
            } else {
                // 累计计算X坐标，实现完全无缝衔接
                let cumulativeX = startX;
                for (let level = 1; level < node.level; level++) {
                    const spacing = levelSpacings[level] || (levelWidths[level] || 120);
                    cumulativeX += spacing;
                }
                node.x = cumulativeX;
            }
            
            // 计算Y坐标
            if (node.level === 1) {
                // 一级节点：从起始Y开始，垂直紧贴排列
                if (!levelCurrentY[1]) {
                    levelCurrentY[1] = startY;
                }
                node.y = levelCurrentY[1];
                levelCurrentY[1] += node.height;
            } else {
                // 子节点：基于父节点的Y位置
                if (parentY !== null) {
                    if (!levelCurrentY[`${node.level}_${node.parentIndex}`]) {
                        levelCurrentY[`${node.level}_${node.parentIndex}`] = parentY;
                    }
                    node.y = levelCurrentY[`${node.level}_${node.parentIndex}`];
                    levelCurrentY[`${node.level}_${node.parentIndex}`] += node.height;
                }
            }
            
            // 递归计算所有直接子节点的位置
            const directChildren = nodeData.filter(n => n.parentIndex === nodeIndex);
            for (const child of directChildren) {
                calculatePosition(child.index, node.y);
            }
        }
        
        // 计算所有一级节点及其子节点的位置
        const rootNodes = nodeData.filter(n => n.level === 1);
        for (const rootNode of rootNodes) {
            calculatePosition(rootNode.index);
        }
        
        // 第五遍：创建节点对象（支持文字换行）
        for (let i = 0; i < nodeData.length; i++) {
            const nodeInfo = nodeData[i];
            
            const nodeId = `md_node_${Date.now()}_${i}_${Math.random().toString(36).substr(2, 9)}`;
            
            const node = {
                id: nodeId,
                x: nodeInfo.x,
                y: nodeInfo.y,
                width: nodeInfo.width,
                height: nodeInfo.height,
                text: nodeInfo.text,
                backgroundColor: "#1E293B",
                color: "#f0f0f0",
                font: "bold 16px sans-serif",
                isSelected: false,
                groupId: groupId,
                type: "node",
                imageData: null,
                imageAspectRatio: 1,
                hasCustomStyle: false,
                manuallyAdjustedHeight: nodeInfo.childCount > 0 || nodeInfo.lineCount > 1,  // 父节点或多行文字节点标记为调整的高度
                isNodeSet: false,
                parentNodeSetId: null,
                nodeSetData: {
                    childNodes: [],
                    childGroups: [],
                    view: {
                        panX: 0,
                        panY: 0,
                        zoom: 1
                    }
                },
                strokeColor: "#1E293B",
                // 添加文字换行相关属性
                textLines: nodeInfo.textLines,
                lineCount: nodeInfo.lineCount,
                wordWrap: nodeInfo.lineCount > 1,  // 是否需要换行
                textAlign: "center",  // 文字对齐方式
                verticalAlign: "middle"  // 垂直对齐方式
            };
            
            nodes.push(node);
        }
        
        // 创建组
        const group = {
            id: groupId,
            nodeIds: nodes.map(node => node.id),
            color: "#1E293B"
        };
        
        return {
            nodes: nodes,
            groups: [group]
        };
    }

    function processMdConversion() {
        const markdownText = dom.mdInputTextarea.value.trim();
        
        if (!markdownText) {
            alert('请输入Markdown文本！');
            return;
        }
        
        // 显示导入进度提示
        const progressMessage = document.createElement('div');
        progressMessage.id = 'md-import-progress';
        progressMessage.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 10000;
            text-align: center;
        `;
        progressMessage.innerHTML = '正在导入Markdown内容...<br><small>请稍候</small>';
        document.body.appendChild(progressMessage);
        
        // 使用 setTimeout 让进度提示先显示
        setTimeout(() => {
            try {
            // 解析Markdown文本
            const parsedItems = parseMarkdownText(markdownText);
            
            // 计算智能导入位置
            const importPosition = calculateSmartImportPosition();
            
            // 生成节点
            const result = generateNodesFromMarkdown(parsedItems, importPosition);
            
            if (result) {
                // 合并导入：不清空画布，而是添加新内容
                // 保留现有的节点和组
                const existingNodes = [...state.nodes];
                const existingGroups = [...state.groups];
                
                // 添加新生成的节点和组
                state.nodes = [...existingNodes, ...result.nodes];
                state.groups = [...existingGroups, ...result.groups];
                
                // 计算所有节点的边界，设置合适的视图
                if (state.nodes.length > 0) {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    
                    state.nodes.forEach(node => {
                        minX = Math.min(minX, node.x);
                        minY = Math.min(minY, node.y);
                        maxX = Math.max(maxX, node.x + node.width);
                        maxY = Math.max(maxY, node.y + node.height);
                    });
                    
                    // 设置视图以显示所有节点
                    const boundsWidth = maxX - minX;
                    const boundsHeight = maxY - minY;
                    const centerX = minX + boundsWidth / 2;
                    const centerY = minY + boundsHeight / 2;
                    
                    const canvasWidth = dom.canvas.width;
                    const canvasHeight = dom.canvas.height;
                    const PADDING = 200;
                    
                    const zoomX = canvasWidth / (boundsWidth + PADDING);
                    const zoomY = canvasHeight / (boundsHeight + PADDING);
                    const newZoom = Math.min(zoomX, zoomY, 1.5); // 限制最大缩放
                    
                    state.view = {
                        zoom: Math.max(newZoom, 0.3), // 确保最小缩放
                        panX: canvasWidth / 2 - centerX * Math.max(newZoom, 0.3),
                        panY: canvasHeight / 2 - centerY * Math.max(newZoom, 0.3)
                    };
                } else {
                    // 如果没有节点，重置视图
                    state.view = { panX: 0, panY: 0, zoom: 1 };
                }
                
                // 保存状态并重绘
                saveState('MD导入');
                updateCanvasCountInfo();
                updateCanvasSelectionInfo();
                setStateDirty();
                
                // 关闭弹窗
                hideMdConvertModal();
                

                
                // 显示成功提示
                progressMessage.innerHTML = '✓ 导入成功！<br><small>共生成 ' + state.nodes.length + ' 个节点</small>';
                progressMessage.style.background = 'rgba(0, 128, 0, 0.8)';
                
                // 2秒后移除提示
                setTimeout(() => {
                    if (progressMessage && progressMessage.parentNode) {
                        progressMessage.parentNode.removeChild(progressMessage);
                    }
                }, 2000);
            }
            
            } catch (error) {
                // Markdown导入失败
                
                // 显示错误提示
                progressMessage.innerHTML = '✗ 导入失败<br><small>' + error.message + '</small>';
                progressMessage.style.background = 'rgba(128, 0, 0, 0.8)';
                
                // 3秒后移除提示
                setTimeout(() => {
                    if (progressMessage && progressMessage.parentNode) {
                        progressMessage.parentNode.removeChild(progressMessage);
                    }
                }, 3000);
                
                alert('MD导入失败: ' + error.message);
            }
        }, 100); // 100ms延迟让进度提示先显示
    }
    
    function focusOnSelection() {
        const selectedNodes = getSelectedNodes();
        const selectedGroups = getSelectedGroups();
        
        let targets = [...selectedNodes, ...selectedGroups];

        if (targets.length === 0) {
            // 只聚焦当前层级的节点和组，不包括其他层级的内容
            targets = [...getCurrentLevelNodes(), ...getCurrentLevelGroups()];
        }

        if (targets.length === 0) {
            state.view = { panX: 0, panY: 0, zoom: 1 };
            setStateDirty();
            return;
        }

        // 过滤掉坐标信息不完整的项目
        targets = targets.filter(item => {
            return typeof item.x === 'number' && !isNaN(item.x) &&
                   typeof item.y === 'number' && !isNaN(item.y) &&
                   typeof item.width === 'number' && !isNaN(item.width) &&
                   typeof item.height === 'number' && !isNaN(item.height);
        });
        
        if (targets.length === 0) {
            state.view = { panX: 0, panY: 0, zoom: 1 };
            setStateDirty();
            return;
        }
        
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

        targets.forEach((item) => {
            let itemMinX = item.x;
            let itemMinY = item.y;
            let itemMaxX = item.x + item.width;
            let itemMaxY = item.y + item.height;

            if (item.type === 'group') {
                const TITLE_HEIGHT = state.settings.gridSize;
                const PADDING = state.settings.gridSize / 2;
                
                itemMinX -= PADDING;
                // 只有当group有titleBar时才减去TITLE_HEIGHT
                if (item.titleBar && item.titleBar.x !== null && item.titleBar.y !== null) {
                    itemMinY -= (PADDING + TITLE_HEIGHT);
                } else {
                    itemMinY -= PADDING;
                }
                itemMaxX += PADDING;
                itemMaxY += PADDING;
            }

            minX = Math.min(minX, itemMinX);
            minY = Math.min(minY, itemMinY);
            maxX = Math.max(maxX, itemMaxX);
            maxY = Math.max(maxY, itemMaxY);
        });

        const boundsWidth = maxX - minX;
        const boundsHeight = maxY - minY;
        
        const PADDING = 100; 
        // 修复画布尺寸获取，使用实际显示尺寸而不是内部分辨率
        const canvasRect = dom.canvas.getBoundingClientRect();
        const canvasWidth = canvasRect.width;
        const canvasHeight = canvasRect.height;
        
        if (boundsWidth <= 0 || boundsHeight <= 0 || !isFinite(boundsWidth) || !isFinite(boundsHeight)) {
            // 处理边界计算异常的情况
            if (targets.length > 0) {
                const targetItem = targets[0];
                if (targetItem && isFinite(targetItem.x) && isFinite(targetItem.y)) {
                    state.view.zoom = 1.5; 
                    state.view.panX = canvasWidth / 2 - (targetItem.x + targetItem.width / 2) * state.view.zoom;
                    state.view.panY = canvasHeight / 2 - (targetItem.y + targetItem.height / 2) * state.view.zoom;
                } else {
                    // 如果节点坐标异常，重置视图
                    state.view = { panX: 0, panY: 0, zoom: 1 };
                }
            } else {
                state.view = { panX: 0, panY: 0, zoom: 1 };
            }
            setStateDirty();
            updateStatusBlocks(); // 实时更新状态块大小和位置
            return;
        }
        
        const zoomX = canvasWidth / (boundsWidth + PADDING * 2);
        const zoomY = canvasHeight / (boundsHeight + PADDING * 2);
        const newZoom = Math.min(zoomX, zoomY, 5);

        const centerX = minX + boundsWidth / 2;
        const centerY = minY + boundsHeight / 2;

        const finalPanX = canvasWidth / 2 - centerX * newZoom;
        const finalPanY = canvasHeight / 2 - centerY * newZoom;

        state.view.zoom = newZoom;
        state.view.panX = finalPanX;
        state.view.panY = finalPanY;

        setStateDirty();
    }

    function clearCanvas() {
        state.nodes = [];
        state.groups = [];
        state.magneticGroups = [];
        dom.canvasNameInput.value = "新建画布";
        state.view = { panX: 0, panY: 0, zoom: 1 };
        saveState('新建画布');
        setStateDirty();
    }

    // 从文件合并功能 - 使用现代File.text()方法替代FileReader
    async function mergeFromFile(file, mergeAtPos) { 
        if (!file || (file.type !== 'application/json' && !file.name.endsWith('.json'))) return;
        
        try {
            // 使用现代的File.text()方法代替FileReader
            const fileContent = await file.text();
            
            // 先检查是否明显是Markdown内容，避免不必要的JSON解析错误日志
            if (isImportableContent(fileContent)) {
                // 检测到Markdown内容
                showUnifiedMarkdownImportConfirmation(fileContent, {
                    type: 'merge',
                    mergeAtPos: mergeAtPos
                }).then(choice => {
                    handleUnifiedMarkdownImportChoice(fileContent, choice, {
                        type: 'merge',
                        mergeAtPos: mergeAtPos
                    });
                });
                return;
            }
            
            // 尝试解析JSON
            const data = JSON.parse(fileContent);
            
            // 检查JSON是否包含Markdown格式的层级结构
            if (isHierarchicalJSON(data)) {
                // 检测到层级结构JSON文件
                
                showUnifiedMarkdownImportConfirmation(fileContent, {
                    type: 'merge',
                    isJsonFile: true,
                    jsonData: data,
                    file: file,
                    mergeAtPos: mergeAtPos
                }).then(choice => {
                    if (choice === 'mindmap') {
                        // 解析为Markdown导图
                        try {
                            const parsedItems = parseJsonStructure(data);
                            const result = generateNodesFromMarkdown(parsedItems, mergeAtPos || utils.screenToWorld(lastMousePos.x, lastMousePos.y));
                            
                            if (result) {
                                // 清除现有选择
                                state.nodes.forEach(n => n.isSelected = false);
                                state.groups.forEach(g => g.isSelected = false);
                                
                                // 添加新节点并选中
                                result.nodes.forEach(node => {
                                    node.isSelected = true;
                                    state.nodes.push(node);
                                });
                                
                                if (result.groups) {
                                    result.groups.forEach(group => {
                                        group.isSelected = true;
                                        state.groups.push(group);
                                    });
                                }
                                
                                state.interaction.isMerging = true;
                                state.interaction.mergingItems = [...result.nodes, ...(result.groups || [])];
                                state.interaction.lastMousePos = mergeAtPos || utils.screenToWorld(lastMousePos.x, lastMousePos.y);
                                
                                saveState('JSON-MD合并');
                                updateCanvasCountInfo();
                                updateCanvasSelectionInfo();
                                setStateDirty();
                                // 成功合并节点
                            } else {
                                alert('Markdown解析失败！');
                            }
                        } catch (error) {
                            // 合并失败
                            alert('合并失败：' + (error.message || '未知错误'));
                        }
                    } else if (choice === 'text') {
                         // 作为普通JSON合并，继续执行原有逻辑
                         mergeJsonAsNormalFile(data, mergeAtPos);
                     }
                    // choice === 'cancel' 时不做任何操作
                });
                return;
            }
            
            if (!data.nodes && !data.groups) {
                alert('Invalid module file!');
                return;
            }
            
            state.nodes.forEach(n => n.isSelected = false);
            state.groups.forEach(g => g.isSelected = false);
            
            const idMap = new Map();
            if (data.nodes) data.nodes.forEach(node => idMap.set(node.id, utils.generateId()));
            if (data.groups) data.groups.forEach(group => idMap.set(group.id, utils.generateId()));

            const worldPos = mergeAtPos || utils.screenToWorld(lastMousePos.x, lastMousePos.y);
            const newItems = [];
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const allItemsForBounds = [];
            if (data.nodes) allItemsForBounds.push(...data.nodes);
            if (data.groups) allItemsForBounds.push(...data.groups);

            if (allItemsForBounds.length > 0) {
                minX = Math.min(...allItemsForBounds.map(item => item.x));
                minY = Math.min(...allItemsForBounds.map(item => item.y));
                maxX = Math.max(...allItemsForBounds.map(item => item.x + (item.width || 0)));
                maxY = Math.max(...allItemsForBounds.map(item => item.y + (item.height || 0)));
            } else {
                return;
            }

            const contentWidth = maxX - minX;
            const contentHeight = maxY - minY;

            const moduleCenterX = minX + contentWidth / 2;
            const moduleCenterY = minY + contentHeight / 2;

            const finalOffsetX = worldPos.x - moduleCenterX;
            const finalOffsetY = worldPos.y - moduleCenterY;

            if (data.nodes) {
                data.nodes.forEach(nodeData => {
                    const newNode = {
                        ...nodeData,
                        id: idMap.get(nodeData.id),
                        x: nodeData.x + finalOffsetX,
                        y: nodeData.y + finalOffsetY,
                        isSelected: true,
                        groupId: nodeData.groupId ? idMap.get(nodeData.groupId) : null,
                    };
                    state.nodes.push(newNode);
                    newItems.push(newNode);
                });
            }
            
            if (data.groups) {
                data.groups.forEach(groupData => {
                    const newGroup = {
                        ...groupData,
                        id: idMap.get(groupData.id),
                        isSelected: true,
                        nodeIds: groupData.nodeIds.map(oldId => idMap.get(oldId)).filter(Boolean),
                        x: groupData.x + finalOffsetX,
                        y: groupData.y + finalOffsetY
                    };
                    state.groups.push(newGroup);
                    newItems.push(newGroup);
                });
            }
            
            state.interaction.isMerging = true;
            state.interaction.mergingItems = newItems;
            state.interaction.lastMousePos = worldPos;
            updateCanvasCountInfo();
            updateCanvasSelectionInfo();
            setStateDirty();
        } catch (err) { 
            // JSON解析失败或其他错误
            alert('文件格式不正确！请选择有效的JSON文件。');
        } finally {
            // 清空文件输入
            if (dom.mergeFileInput) {
                dom.mergeFileInput.value = '';
            }
        }
    }

    // 辅助函数：处理普通JSON文件合并
    function mergeJsonAsNormalFile(data, mergeAtPos) {
        if (!data.nodes && !data.groups) {
            alert('Invalid module file!');
            return;
        }
        
        state.nodes.forEach(n => n.isSelected = false);
        state.groups.forEach(g => g.isSelected = false);
        
        const idMap = new Map();
        if (data.nodes) data.nodes.forEach(node => idMap.set(node.id, utils.generateId()));
        if (data.groups) data.groups.forEach(group => idMap.set(group.id, utils.generateId()));

        const worldPos = mergeAtPos || utils.screenToWorld(lastMousePos.x, lastMousePos.y);
        const newItems = [];
        
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        const allItemsForBounds = [];
        if (data.nodes) allItemsForBounds.push(...data.nodes);
        if (data.groups) allItemsForBounds.push(...data.groups);

        if (allItemsForBounds.length > 0) {
            minX = Math.min(...allItemsForBounds.map(item => item.x));
            minY = Math.min(...allItemsForBounds.map(item => item.y));
            maxX = Math.max(...allItemsForBounds.map(item => item.x + (item.width || 0)));
            maxY = Math.max(...allItemsForBounds.map(item => item.y + (item.height || 0)));
        } else {
            return;
        }

        const contentWidth = maxX - minX;
        const contentHeight = maxY - minY;

        const moduleCenterX = minX + contentWidth / 2;
        const moduleCenterY = minY + contentHeight / 2;

        const finalOffsetX = worldPos.x - moduleCenterX;
        const finalOffsetY = worldPos.y - moduleCenterY;

        if (data.nodes) {
            data.nodes.forEach(nodeData => {
                const newNode = {
                    ...nodeData,
                    id: idMap.get(nodeData.id),
                    x: nodeData.x + finalOffsetX,
                    y: nodeData.y + finalOffsetY,
                    isSelected: true,
                    groupId: nodeData.groupId ? idMap.get(nodeData.groupId) : null,
                };
                state.nodes.push(newNode);
                newItems.push(newNode);
            });
        }
        
        if (data.groups) {
            data.groups.forEach(groupData => {
                const newGroup = {
                    ...groupData,
                    id: idMap.get(groupData.id),
                    isSelected: true,
                    nodeIds: groupData.nodeIds.map(oldId => idMap.get(oldId)).filter(Boolean),
                    x: groupData.x + finalOffsetX,
                    y: groupData.y + finalOffsetY
                };
                state.groups.push(newGroup);
                newItems.push(newGroup);
            });
        }
        
        state.interaction.isMerging = true;
        state.interaction.mergingItems = newItems;
        state.interaction.lastMousePos = worldPos;
        updateCanvasCountInfo();
        updateCanvasSelectionInfo();
        setStateDirty();
    }

    function exportModule() {
        const name = dom.canvasNameInput.value || '模块';
        saveCanvas(`${name}_module.json`, true);
    }
    
    function alignSelectedNodes(direction) {
        const selected = getSelectedNodes();
        if (selected.length < 2) return;

        const margin = 0;

        switch (direction) {
            case 'left': {
                const targetX = Math.min(...selected.map(n => n.x));
                const sortedNodes = [...selected].sort((a, b) => a.x - b.x);
                const placedNodes = [];

                sortedNodes.forEach(nodeToMove => {
                    let newX = targetX;
                    placedNodes.forEach(obstacle => {
                        if (nodeToMove.y < obstacle.y + obstacle.height + margin && 
                            nodeToMove.y + nodeToMove.height > obstacle.y - margin) {
                            newX = Math.max(newX, obstacle.x + obstacle.width + margin);
                        }
                    });
                    nodeToMove.x = newX;
                    placedNodes.push(nodeToMove);
                });
                break;
            }
            case 'right': {
                const targetRightX = Math.max(...selected.map(n => n.x + n.width));
                const sortedNodes = [...selected].sort((a, b) => (b.x + b.width) - (a.x + a.width));
                const placedNodes = [];

                sortedNodes.forEach(nodeToMove => {
                    let newX = targetRightX - nodeToMove.width;
                    placedNodes.forEach(obstacle => {
                        if (nodeToMove.y < obstacle.y + obstacle.height + margin && 
                            nodeToMove.y + nodeToMove.height > obstacle.y - margin) {
                            newX = Math.min(newX, obstacle.x - nodeToMove.width - margin);
                        }
                    });
                    nodeToMove.x = newX;
                    placedNodes.push(nodeToMove);
                });
                break;
            }
            case 'top': {
                const targetY = Math.min(...selected.map(n => n.y));
                const sortedNodes = [...selected].sort((a, b) => a.y - b.y);
                const placedNodes = [];

                sortedNodes.forEach(nodeToMove => {
                    let newY = targetY;
                    placedNodes.forEach(obstacle => {
                        if (nodeToMove.x < obstacle.x + obstacle.width + margin && 
                            nodeToMove.x + nodeToMove.width > obstacle.x - margin) {
                            newY = Math.max(newY, obstacle.y + obstacle.height + margin);
                        }
                    });
                    nodeToMove.y = newY;
                    placedNodes.push(nodeToMove);
                });
                break;
            }
            case 'bottom': {
                const targetBottomY = Math.max(...selected.map(n => n.y + n.height));
                const sortedNodes = [...selected].sort((a, b) => (b.y + b.height) - (a.y + a.height));
                const placedNodes = [];

                sortedNodes.forEach(nodeToMove => {
                    let newY = targetBottomY - nodeToMove.height;
                    placedNodes.forEach(obstacle => {
                        if (nodeToMove.x < obstacle.x + obstacle.width + margin && 
                            nodeToMove.x + nodeToMove.width > obstacle.x - margin) {
                            newY = Math.min(newY, obstacle.y - nodeToMove.height - margin);
                        }
                    });
                    nodeToMove.y = newY;
                    placedNodes.push(nodeToMove);
                });
                break;
            }
        }
        saveState('对齐节点');
        updateMagneticGroups();
        setStateDirty();
    }

    function sortAndArrangeNodes(criteria) {
        const nodesToSort = getSelectedNodes();
        if (nodesToSort.length < 2) return;

        // 1. Sort the nodes
        switch (criteria) {
            case 'alpha':
                nodesToSort.sort((a, b) => a.text.localeCompare(b.text));
                break;
            case 'size':
                nodesToSort.sort((a, b) => (b.width * b.height) - (a.width * a.height));
                break;
            case 'id':
                nodesToSort.sort((a, b) => a.id.localeCompare(b.id));
                break;
        }

        // 2. Arrange the nodes
        const PADDING = state.settings.gridSize / 2;
        let totalArea = 0;
        nodesToSort.forEach(n => totalArea += (n.width + PADDING) * (n.height + PADDING));

        const aspectRatio = 3 / 2;
        const rectWidth = Math.sqrt(totalArea * aspectRatio);

        const startX = Math.min(...nodesToSort.map(n => n.x));
        const startY = Math.min(...nodesToSort.map(n => n.y));

        let currentX = startX;
        let currentY = startY;
        let rowHeight = 0;

        nodesToSort.forEach(node => {
            if (currentX + node.width > startX + rectWidth && currentX > startX) {
                currentX = startX;
                currentY += rowHeight;
                rowHeight = 0;
            }
            
            node.x = currentX;
            node.y = currentY;

            currentX += node.width + PADDING;
            rowHeight = Math.max(rowHeight, node.height + PADDING);
        });
        
        saveState('排序节点');
        updateMagneticGroups();
        setStateDirty();
    }


    // ===================================================================================
    // Utility Functions
    // ===================================================================================
    
    function showPermissionError(message = '请先选择对象') {
        // 创建提示弹窗
        const toast = document.createElement('div');
        toast.className = 'permission-toast';
        toast.textContent = message;
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(8px);
            animation: slideInRight 0.3s ease-out;
        `;
        
        document.body.appendChild(toast);
        
        // 1秒后自动消失
        setTimeout(() => {
            toast.style.animation = 'slideOutRight 0.3s ease-in';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }, 1000);
    }
    
    // ===================================================================================
    // Event Handlers
    // ===================================================================================
    
    function updateColorPickersFromSelection() {
        const selectedNodes = getSelectedNodes();
        const selectedGroups = getSelectedGroups();
        
        // 获取当前主题的默认颜色
        const themeColors = state.settings.themeColors || {
            nodeBg: '#2a2a2a',
            nodeText: '#ffffff',
            group: '#4a9eff'
        };

        // 如果有选中的节点，显示第一个节点的颜色
        if (selectedNodes.length > 0) {
            const firstNode = selectedNodes[0];
            dom.nodeBgColorDisplay.style.backgroundColor = firstNode.backgroundColor;
            dom.fontColorDisplay.style.backgroundColor = firstNode.color;
        } else {
            // 没有选中节点时，恢复主题默认颜色
            dom.nodeBgColorDisplay.style.backgroundColor = themeColors.nodeBg;
            dom.fontColorDisplay.style.backgroundColor = themeColors.nodeText;
        }

        // 如果有选中的组，显示第一个组的颜色
        if (selectedGroups.length > 0) {
            const firstGroup = selectedGroups[0];
            dom.groupColorDisplay.style.backgroundColor = firstGroup.color;
        } else {
            // 没有选中组时，恢复主题默认颜色
            dom.groupColorDisplay.style.backgroundColor = themeColors.group;
        }
    }
    
    function handleSelectionChange() {
        updateColorPickersFromSelection();
        updateCanvasSelectionInfo();
        setStateDirty();
    }
    
    function handleSelectionChangeWithHistory(actionDescription) {
        handleSelectionChange();
        if (actionDescription) {
            saveState(actionDescription);
        }
    }
    
    function handleMouseDown(e) {
        // 恢复动画
        resumeAnimation();
        
        // 处理鼠标按下事件
        
        // 检查画布名称输入框是否处于编辑状态，如果是则自动确认并退出编辑状态
        // 但只有当点击的不是输入框本身时才执行
        if (document.activeElement === dom.canvasNameInput && e.target !== dom.canvasNameInput) {
            // 失去焦点，自动确认输入内容
            dom.canvasNameInput.blur(); // 失去焦点，自动确认输入内容
        }
        
        // 处理鼠标后退键（侧键）退出节点集层级
        if (e.button === 3 || e.button === 4) { // 鼠标后退键
            e.preventDefault();
            if (state.nodeSetNavigation.currentNodeSetId !== null) {
                // 当前在节点集内，退出一层
                exitCurrentNodeSet();
            }
            return;
        }
        
        if (state.interaction.isMerging) {
            if (e.button === 0) {
                const itemsToPlace = state.interaction.mergingItems;
                if (itemsToPlace.length > 0) {
                    const minX = Math.min(...itemsToPlace.map(it => it.x));
                    const minY = Math.min(...itemsToPlace.map(it => it.y));
                    const snappedMinX = utils.snap(minX);
                    const snappedMinY = utils.snap(minY);
                    const deltaX = snappedMinX - minX;
                    const deltaY = snappedMinY - minY;
                    if (deltaX !== 0 || deltaY !== 0) {
                        itemsToPlace.forEach(item => {
                            item.x += deltaX;
                            item.y += deltaY;
                        });
                    }
                }
                state.interaction.isMerging = false;
                state.interaction.mergingItems = [];
                saveState('合并模块');
                setStateDirty();
                return;
            }
        }

        if (state.editingItem) {
            stopEditing();
        }
        
        // 获取canvas的边界矩形，计算相对于canvas的坐标（仅用于调试）
        const rect = dom.canvas.getBoundingClientRect();
        const canvasX = e.clientX - rect.left;
        const canvasY = e.clientY - rect.top;
        

        
        // 使用修复后的 screenToWorld 函数，直接传递屏幕坐标
        const worldPos = utils.screenToWorld(e.clientX, e.clientY);

        state.interaction.dragStart = { ...worldPos };
        state.interaction.lastMousePos = { ...worldPos };
        
        // 检测双击 - 如果是双击的第一次点击，不记录选择历史
        const now = Date.now();
        const isDoubleClickFirstClick = state.interaction.lastClickTime && 
                                       (now - state.interaction.lastClickTime) < 300 &&
                                       Math.abs(canvasX - state.interaction.lastClickX) < 5 &&
                                       Math.abs(canvasY - state.interaction.lastClickY) < 5;
        state.interaction.lastClickTime = now;
        state.interaction.lastClickX = canvasX;
        state.interaction.lastClickY = canvasY;
        
        let selectionChanged = false;
        let selectionAction = null;
        
        if (e.button === 1) { // Middle mouse
            state.interaction.isPanning = true;
            dom.canvas.style.cursor = 'grabbing';
            return;
        }

        if (e.button === 0) { // Left mouse
            let hitItem = null;
            let resizeEdge = null;
            
            for (const group of getSelectedGroups()) {
                if (utils.isPointInGroupResizeHandle(worldPos.x, worldPos.y, group)) {
                    state.interaction.isResizingGroup = true;
                    state.interaction.resizeGroup = group;
                    setStateDirty();
                    return;
                }
            }
            for (const node of getSelectedNodes()) {
                resizeEdge = utils.isPointInNodeEdge(worldPos.x, worldPos.y, node);
                if (resizeEdge) {
                    state.interaction.isResizingNode = true;
                    state.interaction.resizeNode = node;
                    state.interaction.resizeEdge = resizeEdge;
                    
                    // 记录多选节点宽度和高度同步调整的初始状态
                    const selectedNodes = getSelectedNodes();
                    state.interaction.resizeInitialStates = selectedNodes.map(n => ({
                        node: n,
                        initialWidth: n.width,
                        initialHeight: n.height,
                        initialX: n.x,
                        initialY: n.y
                    }));
                    state.interaction.resizeInitialWidth = node.width;
                    state.interaction.resizeInitialHeight = node.height;
                    
                    setStateDirty();
                    return;
                }
            }
            
            const currentNodes = getCurrentLevelNodes();
            const currentGroups = getCurrentLevelGroups();
            

            
            for (let i = currentNodes.length - 1; i >= 0; i--) {
                if (utils.isPointInNode(worldPos.x, worldPos.y, currentNodes[i])) {
                    hitItem = currentNodes[i];
                    break;
                }
            }
            if (!hitItem) {
                for (let i = currentGroups.length - 1; i >= 0; i--) {
                    if (utils.isPointInGroupTitle(worldPos.x, worldPos.y, currentGroups[i])) {
                        hitItem = currentGroups[i];
                        break;
                    }
                }
            }
            
            if (hitItem) {
                // 特殊处理：如果点击的是状态块
                if (hitItem.isStatusBlock) {
                    // 记录点击位置，等待双击判断
                    if (!state.lastStatusBlockClick) {
                        state.lastStatusBlockClick = {
                            itemId: hitItem.id,
                            time: Date.now()
                        };
                    } else {
                        // 检查是否在短时间内点击了同一个状态块（双击）
                        const timeDiff = Date.now() - state.lastStatusBlockClick.time;
                        if (state.lastStatusBlockClick.itemId === hitItem.id && timeDiff < 300) {
                            // 双击切换状态块状态
                            hitItem.statusIndex = (hitItem.statusIndex + 1) % statusColors.length;
                            hitItem.backgroundColor = statusColors[hitItem.statusIndex].color;
                            hitItem.text = statusColors[hitItem.statusIndex].status; // 更新状态文字
                            hitItem.color = getContrastingColor(statusColors[hitItem.statusIndex].color); // 更新文字颜色
                            hitItem.textLines = null; // 清除文本行缓存，确保重新计算文字行
                            saveState('切换状态块状态');
                            setStateDirty();
                        }
                        state.lastStatusBlockClick = null;
                    }
                    return;
                }
                
                // 安全检查：确保有有效的拖拽起始点
                if (!state.interaction.dragStart) {
                    return;
                }
                
                // 不立即设置 isDragging，而是准备拖拽状态
                state.interaction.dragPrepared = true;
                state.interaction.actuallyDragged = false;
                
                // 降低历史记录面板的z-index，让节点可以拖拽到面板后面
                if (dom.newHistoryModal && dom.newHistoryModal.style.display === 'block') {
                    dom.newHistoryModal.style.zIndex = '50';
                }
                
                if (!hitItem.isSelected) {
                    if (!e.ctrlKey && !e.shiftKey) {
                        getCurrentLevelNodes().forEach(n => n.isSelected = false);
                        getCurrentLevelGroups().forEach(g => g.isSelected = false);
                    }
                    hitItem.isSelected = true;
                    selectionChanged = true;
                    selectionAction = hitItem.type === 'group' ? '选择组' : '选择节点';
                } else if (e.ctrlKey || e.shiftKey) {
                    hitItem.isSelected = !hitItem.isSelected;
                    selectionChanged = true;
                    if (hitItem.isSelected) {
                        selectionAction = hitItem.type === 'group' ? '选择组' : '选择节点';
                    } else {
                        selectionAction = '取消选择';
                    }
                } else {
                    // 点击已选中的项目且没有按修饰键：保持多选状态，不立即取消其他选择
                    // 这样可以支持多选拖拽，如果用户只是点击而不拖拽，则在mouseup时处理单选
                    // 暂时不改变选择状态，让拖拽逻辑处理多选移动
                }
                
                // 准备拖拽候选项，但不立即开始拖拽
                const selectedGroups = getSelectedGroups();
                const selectedNodes = getSelectedNodes();
                
                // 简化的拖拽逻辑：直接拖拽所有选中的项目
                let dragCandidates = new Set([...selectedNodes, ...selectedGroups]);
                if (state.settings.magneticNodes) {
                    dragCandidates.forEach(item => {
                        if (item.type === 'node' || item.type === 'imageNode') {
                            const cluster = state.magneticGroups.find(c => c.has(item.id));
                            if (cluster) {
                                const currentLevelNodes = getCurrentLevelNodes();
                                cluster.forEach(nodeId => {
                                    const magneticNode = currentLevelNodes.find(n => n.id === nodeId);
                                    if (magneticNode) dragCandidates.add(magneticNode);
                                });
                            }
                        }
                    });
                }
                state.interaction.draggedItems = Array.from(dragCandidates);
                
                // 安全检查：确保有有效的拖拽项目
                if (state.interaction.draggedItems.length === 0) {
                    state.interaction.dragPrepared = false;
                    return;
                }
                
                state.interaction.dragOffsets.clear();
                state.interaction.draggedItems.forEach(item => {
                    if (item && item.id) {
                        state.interaction.dragOffsets.set(item.id, { x: worldPos.x - item.x, y: worldPos.y - item.y });
                    }
                });

            } else { // No item hit, start marquee selection
                // 记录框选开始前的选择状态
                const currentLevelNodes = getCurrentLevelNodes();
                const currentLevelGroups = getCurrentLevelGroups();
                state.interaction.marqueeInitialSelection = {
                    nodes: currentLevelNodes.filter(n => n.isSelected).map(n => n.id),
                    groups: currentLevelGroups.filter(g => g.isSelected).map(g => g.id)
                };
                
                // 检查框选起始点是否在组框内部
                const groupsToExclude = [];
                for (const group of currentLevelGroups) {
                    const groupRect = { x: group.x, y: group.y, width: group.width, height: group.height };
                    if (utils.checkOverlap({ x: worldPos.x, y: worldPos.y, width: 1, height: 1 }, groupRect)) {
                        groupsToExclude.push(group.id);
                    }
                }
                state.interaction.marqueeExcludeGroups = groupsToExclude;
                
                if (!e.ctrlKey && !e.shiftKey) {
                    // Check if any items are currently selected
                    const hasSelectedItems = currentLevelNodes.some(n => n.isSelected) || currentLevelGroups.some(g => g.isSelected);
                    if (hasSelectedItems) {
                        selectionChanged = true;
                        selectionAction = '取消选择';
                    }
                    currentLevelNodes.forEach(n => n.isSelected = false);
                    currentLevelGroups.forEach(g => g.isSelected = false);
                }
                state.interaction.isMarquee = true;
                state.interaction.marqueeRect = { x: worldPos.x, y: worldPos.y, width: 0, height: 0 };
            }
        }
        
        if (selectionChanged && !isDoubleClickFirstClick) {
            handleSelectionChangeWithHistory(selectionAction);
        } else {
            handleSelectionChange();
        }
    }
    
    function handleMouseMove(e) {
        // 获取canvas的边界矩形，计算相对于canvas的坐标（仅用于调试和lastMousePos）
        const rect = dom.canvas.getBoundingClientRect();
        const canvasX = e.clientX - rect.left;
        const canvasY = e.clientY - rect.top;
        

        
        lastMousePos = { x: canvasX, y: canvasY };
        // 使用修复后的 screenToWorld 函数，直接传递屏幕坐标
        const worldPos = utils.screenToWorld(e.clientX, e.clientY);
        const { interaction, view, settings } = state;
        
        // 只在有实际交互时恢复动画
        if (interaction.isDragging || interaction.isSelecting || interaction.isMerging || interaction.isPanning) {
            resumeAnimation();
        }
        
        if (interaction.isMerging) {
            const mouseMoveDelta = { x: worldPos.x - interaction.lastMousePos.x, y: worldPos.y - interaction.lastMousePos.y };
            interaction.mergingItems.forEach(item => {
                item.x += mouseMoveDelta.x;
                item.y += mouseMoveDelta.y;
            });
            interaction.lastMousePos = worldPos;
            setStateDirty();
            return;
        }

        if (interaction.isPanning) {
            view.panX += e.movementX;
            view.panY += e.movementY;
            updateCanvasPositionInfo();
            setStateDirty();
        } else if (interaction.isResizingGroup) {
            const group = interaction.resizeGroup;
            const PADDING = state.settings.gridSize / 2;
            group.width = Math.max(50, worldPos.x - group.x - PADDING);
            group.height = Math.max(50, worldPos.y - group.y - PADDING);
            setStateDirty();
        } else if (interaction.isResizingNode) {
            const node = interaction.resizeNode;
            const isShiftPressed = e.shiftKey;
            const resizeEdge = interaction.resizeEdge;
            
            // 保存调整前的节点信息，用于updateStatusBlocks
            
            if (node.type === 'imageNode') {
                const newWidth = Math.max(50, worldPos.x - node.x);
                node.width = utils.snap(newWidth);
                const pureImageHeight = (node.width - 20) / node.imageAspectRatio;
                const lines = utils.getWrappedTextLines(node.text, node.width - 20);
                const textAreaHeight = node.text.trim() ? Math.max(20, lines.length * utils.getFontSize(node.font) * 1.2) : 0;
                node.height = utils.snap(pureImageHeight + textAreaHeight + 20);
            } else {
                const minWidth = state.settings.gridSize * 2;
                const minHeight = state.settings.gridSize * 2;
                
                if (resizeEdge === 'right') {
                    // 右侧调节宽度
                    const newWidth = Math.max(minWidth, worldPos.x - node.x);
                    const snappedNewWidth = utils.snap(newWidth);
                    node.width = snappedNewWidth;
                    // 标记为手动调节过宽度
                    node.manuallyAdjustedWidth = true;
                    
                    // 无论高度是否被手动调整过，都重新计算文本换行
                    // 但只在高度未被手动调整时更新高度
                    updateNodeHeightSmart(node);
                    
                    // 多选节点宽度同步调整
                    if (interaction.resizeInitialStates && interaction.resizeInitialStates.length > 1) {
                        const currentNode = interaction.resizeNode;
                        const initialWidth = interaction.resizeInitialWidth;
                        
                        dom.canvas.style.cursor = isShiftPressed ? 'col-resize' : 'ew-resize';
                        
                        if (isShiftPressed) {
                            interaction.resizeInitialStates.forEach(state => {
                                if (state.node !== currentNode) {
                                    state.node.width = snappedNewWidth;
                                    state.node.manuallyAdjustedWidth = true;
                                    // 无论高度是否被手动调整过，都重新计算文本换行
                                    updateNodeHeightSmart(state.node);
                                }
                            });
                        } else {
                            const widthDelta = snappedNewWidth - initialWidth;
                            interaction.resizeInitialStates.forEach(state => {
                                if (state.node !== currentNode) {
                                    const newNodeWidth = Math.max(minWidth, state.initialWidth + widthDelta);
                                    state.node.width = utils.snap(newNodeWidth);
                                    state.node.manuallyAdjustedWidth = true;
                                    // 无论高度是否被手动调整过，都重新计算文本换行
                                    updateNodeHeightSmart(state.node);
                                }
                            });
                        }
                    }
                } else if (resizeEdge === 'left') {
                    // 左侧调节宽度
                    const newX = Math.min(node.x + node.width - minWidth, worldPos.x);
                    const snappedNewX = utils.snap(newX);
                    const newWidth = node.x + node.width - snappedNewX;
                    node.x = snappedNewX;
                    node.width = newWidth;
                    // 标记为手动调节过宽度
                    node.manuallyAdjustedWidth = true;
                    
                    // 应用新规则：拖拽调整宽度后智能更新高度（仅在高度未被手动调整时）
                    if (node.manuallyAdjustedHeight !== true) {
                        updateNodeHeightSmart(node);
                    }
                    
                    // 多选节点宽度同步调整
                    if (interaction.resizeInitialStates && interaction.resizeInitialStates.length > 1) {
                        const currentNode = interaction.resizeNode;
                        const initialWidth = interaction.resizeInitialWidth;
                        
                        dom.canvas.style.cursor = isShiftPressed ? 'col-resize' : 'ew-resize';
                        
                        if (isShiftPressed) {
                            // Shift键：统一所有节点的宽度
                            interaction.resizeInitialStates.forEach(state => {
                                if (state.node !== currentNode) {
                                    const deltaX = state.node.width - newWidth;
                                    state.node.x += deltaX;
                                    state.node.width = newWidth;
                                    state.node.manuallyAdjustedWidth = true;
                                    // 无论高度是否被手动调整过，都重新计算文本换行
                                    updateNodeHeightSmart(state.node);
                                }
                            });
                        } else {
                            // 正常模式：按比例调整
                            const widthDelta = newWidth - initialWidth;
                            interaction.resizeInitialStates.forEach(state => {
                                if (state.node !== currentNode) {
                                    const newNodeWidth = Math.max(minWidth, state.initialWidth + widthDelta);
                                    const deltaX = state.node.width - newNodeWidth;
                                    state.node.x += deltaX;
                                    state.node.width = utils.snap(newNodeWidth);
                                    state.node.manuallyAdjustedWidth = true;
                                    // 无论高度是否被手动调整过，都重新计算文本换行
                                    updateNodeHeightSmart(state.node);
                                }
                            });
                        }
                    }
                } else if (resizeEdge === 'top') {
                    // 上侧调节高度
                    // 计算文字所需的最小高度
                    const textMinHeight = node.type === 'imageNode' ? minHeight : utils.getRequiredHeightForText(node.text, node.width);
                    const actualMinHeight = Math.max(minHeight, textMinHeight);
                    
                    const newY = Math.min(node.y + node.height - actualMinHeight, worldPos.y);
                    const snappedNewY = utils.snap(newY);
                    const newHeight = node.y + node.height - snappedNewY;
                    node.y = snappedNewY;
                    node.height = Math.max(actualMinHeight, newHeight);
                    // 标记为手动调节过高度
                    node.manuallyAdjustedHeight = true;
                    
                    // 多选节点高度同步调整
                    if (interaction.resizeInitialStates && interaction.resizeInitialStates.length > 1) {
                        const currentNode = interaction.resizeNode;
                        const initialHeight = interaction.resizeInitialHeight;
                        
                        dom.canvas.style.cursor = isShiftPressed ? 'row-resize' : 'ns-resize';
                        
                        if (isShiftPressed) {
                            // Shift键：统一所有节点的高度
                            interaction.resizeInitialStates.forEach(state => {
                                if (state.node !== currentNode) {
                                    const deltaY = state.node.height - newHeight;
                                    state.node.y += deltaY;
                                    state.node.height = newHeight;
                                    state.node.manuallyAdjustedHeight = true;
                                }
                            });
                        } else {
                            // 正常模式：按比例调整
                            const heightDelta = newHeight - initialHeight;
                            interaction.resizeInitialStates.forEach(state => {
                                if (state.node !== currentNode) {
                                    const nodeTextMinHeight = state.node.type === 'imageNode' ? minHeight : utils.getRequiredHeightForText(state.node.text, state.node.width);
                                    const nodeActualMinHeight = Math.max(minHeight, nodeTextMinHeight);
                                    const newNodeHeight = Math.max(nodeActualMinHeight, state.initialHeight + heightDelta);
                                    const deltaY = state.node.height - newNodeHeight;
                                    state.node.y += deltaY;
                                    state.node.height = utils.snap(newNodeHeight);
                                    state.node.manuallyAdjustedHeight = true;
                                }
                            });
                        }
                    }
                } else if (resizeEdge === 'bottom') {
                    // 下侧调节高度
                    // 计算文字所需的最小高度
                    const textMinHeight = node.type === 'imageNode' ? minHeight : utils.getRequiredHeightForText(node.text, node.width);
                    const actualMinHeight = Math.max(minHeight, textMinHeight);
                    
                    const newHeight = Math.max(actualMinHeight, worldPos.y - node.y);
                    node.height = utils.snap(newHeight);
                    // 标记为手动调节过高度
                    node.manuallyAdjustedHeight = true;
                    
                    // 多选节点高度同步调整
                    if (interaction.resizeInitialStates && interaction.resizeInitialStates.length > 1) {
                        const currentNode = interaction.resizeNode;
                        const initialHeight = interaction.resizeInitialHeight;
                        
                        dom.canvas.style.cursor = isShiftPressed ? 'row-resize' : 'ns-resize';
                        
                        if (isShiftPressed) {
                            // Shift键：统一所有节点的高度
                            interaction.resizeInitialStates.forEach(state => {
                                if (state.node !== currentNode) {
                                    state.node.height = newHeight;
                                    state.node.manuallyAdjustedHeight = true;
                                }
                            });
                        } else {
                            // 正常模式：按比例调整
                            const heightDelta = newHeight - initialHeight;
                            interaction.resizeInitialStates.forEach(state => {
                                if (state.node !== currentNode) {
                                    const nodeTextMinHeight = state.node.type === 'imageNode' ? minHeight : utils.getRequiredHeightForText(state.node.text, state.node.width);
                                    const nodeActualMinHeight = Math.max(minHeight, nodeTextMinHeight);
                                    const newNodeHeight = Math.max(nodeActualMinHeight, state.initialHeight + heightDelta);
                                    state.node.height = utils.snap(newNodeHeight);
                                    state.node.manuallyAdjustedHeight = true;
                                }
                            });
                        }
                    }
                }
            }
            setStateDirty();
            updateStatusBlocks(); // 实时更新状态块大小和位置
        } else if (interaction.isDragging || interaction.dragPrepared) {
            // 安全检查：确保有有效的拖拽目标
            if (!interaction.draggedItems || interaction.draggedItems.length === 0) {
                // 无有效拖拽目标
                resetInteractionState();
                return;
            }
            
            // 如果是准备拖拽状态，检查是否真的开始移动
            if (interaction.dragPrepared && !interaction.isDragging) {
                const dragThreshold = 3; // 像素阈值，超过这个距离才开始拖拽
                
                // 安全检查：确保有拖拽起始点
                if (!interaction.dragStart) {
                    // 无拖拽起始点
                    resetInteractionState();
                    return;
                }
                
                const screenDragStart = utils.worldToScreen(interaction.dragStart.x, interaction.dragStart.y);
                const distance = Math.sqrt(
                    Math.pow(e.clientX - screenDragStart.x, 2) + 
                    Math.pow(e.clientY - screenDragStart.y, 2)
                );
                
                if (distance > dragThreshold) {
                    // 开始真正的拖拽
                    interaction.isDragging = true;
                    interaction.dragPrepared = false;
                } else {
                    // 还没有超过阈值，不开始拖拽
                    return;
                }
            }
            
            const primaryItem = interaction.draggedItems[0];
            if (!primaryItem) {
                // 主项目为空
                resetInteractionState();
                return;
            }
            
            // Mark that actual dragging has occurred
            state.interaction.actuallyDragged = true;

            const offset = interaction.dragOffsets.get(primaryItem.id) || { x: 0, y: 0 };
            let newX = worldPos.x - offset.x;
            let newY = worldPos.y - offset.y;
            
            if (settings.snapToGrid) {
                newX = utils.snap(newX);
                newY = utils.snap(newY);
            }
            
            let finalDelta = {
                x: newX - primaryItem.x,
                y: newY - primaryItem.y
            };
            
            // 构建需要移动的项目集合
            const itemsToMoveInitially = new Set();
            
            // 添加直接拖拽的项目
            interaction.draggedItems.forEach(item => {
                itemsToMoveInitially.add(item);
                
                // 如果拖拽的是组框，添加组内所有节点
                if (item.type === 'group') {
                    getCurrentLevelNodes()
                        .filter(n => n.groupId === item.id)
                        .forEach(node => itemsToMoveInitially.add(node));
                }
                
                // 如果拖拽的是节点，添加与其关联的状态块
                if (!item.isStatusBlock) {
                    getCurrentLevelNodes()
                        .filter(n => n.isStatusBlock && n.targetNodeId === item.id)
                        .forEach(statusBlock => itemsToMoveInitially.add(statusBlock));
                }
            });

            // 插入模式特殊处理
            if (settings.insertMode) {
                // 在插入模式下，清除之前的高亮区域
                interaction.insertHighlightRegions = [];
                interaction.insertTarget = null;
                interaction.insertDirection = null;
                
                // 检测目标节点并计算插入区域
                const currentLevelNodes = getCurrentLevelNodes();
                const draggedNodeIds = new Set(interaction.draggedItems.map(item => item.id));
                
                for (const targetNode of currentLevelNodes) {
                    // 跳过正在拖拽的节点
                    if (draggedNodeIds.has(targetNode.id)) continue;
                    
                    // 检查鼠标是否在目标节点附近（紧贴判定）
                    const proximity = 1; // 与磁吸功能相同的紧贴判定距离
                    const expandedTarget = {
                        x: targetNode.x - proximity,
                        y: targetNode.y - proximity,
                        width: targetNode.width + 2 * proximity,
                        height: targetNode.height + 2 * proximity
                    };
                    
                    if (utils.isPointInNode(worldPos.x, worldPos.y, expandedTarget)) {
                        // 计算四个三角形区域
                        const centerX = targetNode.x + targetNode.width / 2;
                        const centerY = targetNode.y + targetNode.height / 2;
                        const relativeX = worldPos.x - centerX;
                        const relativeY = worldPos.y - centerY;
                        
                        // 判断在哪个三角形区域
                        let direction = '';
                        if (Math.abs(relativeX) > Math.abs(relativeY)) {
                            direction = relativeX > 0 ? 'right' : 'left';
                        } else {
                            direction = relativeY > 0 ? 'bottom' : 'top';
                        }
                        
                        // 设置插入目标和方向
                        interaction.insertTarget = targetNode;
                        interaction.insertDirection = direction;
                        
                        // 创建高亮区域
                        const triangleSize = 20;
                        let highlightRegion = {};
                        
                        switch (direction) {
                            case 'top':
                                highlightRegion = {
                                    type: 'triangle',
                                    points: [
                                        { x: centerX, y: targetNode.y },
                                        { x: centerX - triangleSize, y: targetNode.y + triangleSize },
                                        { x: centerX + triangleSize, y: targetNode.y + triangleSize }
                                    ]
                                };
                                break;
                            case 'bottom':
                                highlightRegion = {
                                    type: 'triangle',
                                    points: [
                                        { x: centerX, y: targetNode.y + targetNode.height },
                                        { x: centerX - triangleSize, y: targetNode.y + targetNode.height - triangleSize },
                                        { x: centerX + triangleSize, y: targetNode.y + targetNode.height - triangleSize }
                                    ]
                                };
                                break;
                            case 'left':
                                highlightRegion = {
                                    type: 'triangle',
                                    points: [
                                        { x: targetNode.x, y: centerY },
                                        { x: targetNode.x + triangleSize, y: centerY - triangleSize },
                                        { x: targetNode.x + triangleSize, y: centerY + triangleSize }
                                    ]
                                };
                                break;
                            case 'right':
                                highlightRegion = {
                                    type: 'triangle',
                                    points: [
                                        { x: targetNode.x + targetNode.width, y: centerY },
                                        { x: targetNode.x + targetNode.width - triangleSize, y: centerY - triangleSize },
                                        { x: targetNode.x + targetNode.width - triangleSize, y: centerY + triangleSize }
                                    ]
                                };
                                break;
                        }
                        
                        interaction.insertHighlightRegions = [highlightRegion];
                        break; // 找到第一个目标就停止
                    }
                }
            }

            // 插入模式下跳过碰撞检测和吸附逻辑
            if (settings.insertMode) {
                // 插入模式：直接移动，无视碰撞和吸附
                itemsToMoveInitially.forEach(item => {
                    item.x += finalDelta.x;
                    item.y += finalDelta.y;
                });
            } else if (state.settings.pushMode) {
                // 只在当前层级进行推动
                const currentLevelNodes = getCurrentLevelNodes();
                // Push模式处理
                
                let pushDelta = { x: 0, y: 0 };
                if (Math.abs(finalDelta.x) > Math.abs(finalDelta.y)) {
                    pushDelta.x = finalDelta.x;
                } else {
                    pushDelta.y = finalDelta.y;
                }

                const movedThisFrame = new Set(itemsToMoveInitially);
                
                itemsToMoveInitially.forEach(item => {
                    item.x += pushDelta.x;
                    item.y += pushDelta.y;
                });
                
                const queue = [...itemsToMoveInitially];
                let safety = 0;
                while(queue.length > 0 && safety < currentLevelNodes.length * 2) {
                    const mover = queue.shift();
                    safety++;
                    
                    currentLevelNodes.forEach(staticNode => {
                        if (movedThisFrame.has(staticNode)) return;

                        if (utils.checkOverlap(mover, staticNode)) {
                            staticNode.x += pushDelta.x;
                            staticNode.y += pushDelta.y;
                            movedThisFrame.add(staticNode);
                            queue.push(staticNode);
                        }
                    });
                }
            } else {
                 if (state.settings.collisionDetection) {
                    const allMovingNodes = [...itemsToMoveInitially].filter(item => item.type !== 'group');
                    const allMovingNodesSet = new Set(allMovingNodes);
                    
                    // 只在当前层级进行碰撞检测
                    const currentLevelNodes = getCurrentLevelNodes();

                    if (allMovingNodes.length > 0) {
                        let allowedDx = finalDelta.x;
                        if (allowedDx !== 0) {
                            for (const draggedNode of allMovingNodes) {
                                for (const staticNode of currentLevelNodes) {
                                    // 跳过与自身或正在移动的节点的碰撞检测
                                    if (allMovingNodesSet.has(staticNode)) {
                                        continue;
                                    }
                                    // 跳过同一目标节点的状态块之间的碰撞
                                    if (draggedNode.isStatusBlock && staticNode.isStatusBlock && draggedNode.targetNodeId === staticNode.targetNodeId) {
                                        continue;
                                    }
                                    // 跳过状态块与它关联的主节点之间的碰撞
                                    if ((draggedNode.isStatusBlock && staticNode.id === draggedNode.targetNodeId) || 
                                        (staticNode.isStatusBlock && draggedNode.id === staticNode.targetNodeId)) {
                                        continue;
                                    }
                                    const moverRectX = { x: draggedNode.x + allowedDx, y: draggedNode.y, width: draggedNode.width, height: draggedNode.height };
                                    if (utils.checkOverlap(moverRectX, staticNode)) {
                                        if (allowedDx > 0) { allowedDx = Math.min(allowedDx, staticNode.x - (draggedNode.x + draggedNode.width)); }
                                        else { allowedDx = Math.max(allowedDx, (staticNode.x + staticNode.width) - draggedNode.x); }
                                    }
                                }
                            }
                        }
                        finalDelta.x = allowedDx;

                        let allowedDy = finalDelta.y;
                        if (allowedDy !== 0) {
                            for (const draggedNode of allMovingNodes) {
                                for (const staticNode of currentLevelNodes) {
                                    // 跳过与自身或正在移动的节点的碰撞检测
                                    if (allMovingNodesSet.has(staticNode)) {
                                        continue;
                                    }
                                    // 跳过同一目标节点的状态块之间的碰撞
                                    if (draggedNode.isStatusBlock && staticNode.isStatusBlock && draggedNode.targetNodeId === staticNode.targetNodeId) {
                                        continue;
                                    }
                                    // 跳过状态块与它关联的主节点之间的碰撞
                                    if ((draggedNode.isStatusBlock && staticNode.id === draggedNode.targetNodeId) || 
                                        (staticNode.isStatusBlock && draggedNode.id === staticNode.targetNodeId)) {
                                        continue;
                                    }
                                    const moverRectY = { x: draggedNode.x + finalDelta.x, y: draggedNode.y + allowedDy, width: draggedNode.width, height: draggedNode.height };
                                    if (utils.checkOverlap(moverRectY, staticNode)) {
                                        if (allowedDy > 0) { allowedDy = Math.min(allowedDy, staticNode.y - (draggedNode.y + draggedNode.height)); }
                                        else { allowedDy = Math.max(allowedDy, (staticNode.y + staticNode.height) - draggedNode.y); }
                                    }
                                }
                            }
                        }
                        finalDelta.y = allowedDy;
                    }
                }
                
                itemsToMoveInitially.forEach(item => {
                     item.x += finalDelta.x;
                     item.y += finalDelta.y;
                });
            }
            updateCanvasSelectionInfo(); // Update selection info during drag
            updateStatusBlocks(); // 实时更新状态块位置
            setStateDirty();
        } else if (interaction.isMarquee) {
            interaction.marqueeRect.width = worldPos.x - interaction.marqueeRect.x;
            interaction.marqueeRect.height = worldPos.y - interaction.marqueeRect.y;
            
            // 实时框选检测：计算当前框选区域
            const rect = interaction.marqueeRect;
            const minX = Math.min(rect.x, rect.x + rect.width);
            const maxX = Math.max(rect.x, rect.x + rect.width);
            const minY = Math.min(rect.y, rect.y + rect.height);
            const maxY = Math.max(rect.y, rect.y + rect.height);
            const marqueeRegion = {x: minX, y: minY, width: maxX-minX, height: maxY-minY};
            
            // 实时更新节点和群组的选中状态
            const currentLevelNodes = getCurrentLevelNodes();
            const currentLevelGroups = getCurrentLevelGroups();
            
            let selectionChanged = false;
            
            // 优化：只检测可能与框选区域相交的节点和群组
            // 简单的空间裁剪，避免检测明显不相交的对象
            const expandedRegion = {
                x: marqueeRegion.x - 50,
                y: marqueeRegion.y - 50,
                width: marqueeRegion.width + 100,
                height: marqueeRegion.height + 100
            };
            
            // 检测节点
            currentLevelNodes.forEach(node => {
                // 快速裁剪：如果节点明显不在扩展区域内，跳过详细检测
                if (node.x > expandedRegion.x + expandedRegion.width || 
                    node.x + node.width < expandedRegion.x ||
                    node.y > expandedRegion.y + expandedRegion.height ||
                    node.y + node.height < expandedRegion.y) {
                    // 节点在扩展区域外，如果之前被选中则取消选中
                    if (node.isSelected) {
                        node.isSelected = false;
                        selectionChanged = true;
                    }
                } else {
                    // 节点可能相交，进行精确检测
                    const shouldBeSelected = utils.checkOverlap(node, marqueeRegion);
                    if (node.isSelected !== shouldBeSelected) {
                        node.isSelected = shouldBeSelected;
                        selectionChanged = true;
                    }
                }
            });
            
            // 检测群组
            currentLevelGroups.forEach(group => {
                // 使用标题栏区域进行检测，而不是整个组区域
                const titleBarRect = group.titleBar || {x: group.x, y: group.y, width: group.width, height: 0};
                
                // 检查是否是需要排除的组框（框选起始点在其内部）
                const shouldExclude = state.interaction.marqueeExcludeGroups && 
                                    state.interaction.marqueeExcludeGroups.includes(group.id);
                
                // 快速裁剪 - 基于标题栏区域
                if (titleBarRect.x > expandedRegion.x + expandedRegion.width || 
                    titleBarRect.x + titleBarRect.width < expandedRegion.x ||
                    titleBarRect.y > expandedRegion.y + expandedRegion.height ||
                    titleBarRect.y + titleBarRect.height < expandedRegion.y) {
                    // 群组标题栏在扩展区域外，取消选中
                    if (group.isSelected) {
                        group.isSelected = false;
                        selectionChanged = true;
                    }
                } else {
                    // 群组可能相交，只检查标题栏区域
                    const titleOverlaps = utils.checkGroupTitleOverlap(marqueeRegion, group);
                    // 如果框选区域包含标题栏，则选中组，即使起始点在组内部
                    const shouldBeSelected = titleOverlaps;
                    if (group.isSelected !== shouldBeSelected) {
                        group.isSelected = shouldBeSelected;
                        selectionChanged = true;
                    }
                }
            });
            
            // 总是需要重绘以更新框选框位置
            setStateDirty();
        } else {
            let cursor = 'default';
            const selectedNodes = getSelectedNodes();
            const isMultipleNodesSelected = selectedNodes.length > 1;
            
            for (const node of selectedNodes) {
                const edge = utils.isPointInNodeEdge(worldPos.x, worldPos.y, node);
                if (edge === 'right' || edge === 'left') {
                    if (isMultipleNodesSelected) {
                        // 多选节点时，根据Shift键状态显示不同的鼠标样式
                        cursor = e.shiftKey ? 'col-resize' : 'ew-resize';
                    } else {
                        cursor = 'ew-resize';
                    }
                }
                else if (edge === 'top' || edge === 'bottom') {
                    cursor = 'ns-resize';
                }
                else if (edge === 'bottom-right') cursor = 'nwse-resize';
            }
            for (const group of getSelectedGroups()) {
                if (utils.isPointInGroupResizeHandle(worldPos.x, worldPos.y, group)) {
                    cursor = 'nwse-resize';
                }
            }
            dom.canvas.style.cursor = cursor;
        }
    }
    
    function handleMouseUp(e) {
        // 处理点击已选中项目但没有拖拽的情况
        if ((state.interaction.isDragging && !state.interaction.actuallyDragged) || state.interaction.dragPrepared) {
            if (!e.ctrlKey && !e.shiftKey) {
                // 如果用户点击了已选中的项目但没有实际拖拽，且没有按修饰键，则进行单选
                // 使用修复后的 screenToWorld 函数，直接传递屏幕坐标
                const worldPos = utils.screenToWorld(e.clientX, e.clientY);
                const hitItem = getItemAt(worldPos.x, worldPos.y);
                
                if (hitItem && hitItem.isSelected) {
                    const selectedCount = getCurrentLevelNodes().filter(n => n.isSelected).length + getCurrentLevelGroups().filter(g => g.isSelected).length;
                    if (selectedCount > 1) {
                        // 取消其他项目的选择，只保留当前项目
                        getCurrentLevelNodes().forEach(n => {
                            if (n !== hitItem) n.isSelected = false;
                        });
                        getCurrentLevelGroups().forEach(g => {
                            if (g !== hitItem) g.isSelected = false;
                        });
                        
                        const selectionAction = hitItem.type === 'group' ? '选择组' : '选择节点';
                        handleSelectionChangeWithHistory(selectionAction);
                    }
                }
            }
            
            // 清理拖拽准备状态
            state.interaction.dragPrepared = false;
        }
        
        if (state.interaction.isMarquee) {
            // 框选结束，选中状态已经在handleMouseMove中实时更新了
            // 这里需要比较选择变化并记录历史
            const currentLevelNodes = getCurrentLevelNodes();
            const currentLevelGroups = getCurrentLevelGroups();
            
            const currentSelectedNodes = currentLevelNodes.filter(node => node.isSelected).map(n => n.id);
            const currentSelectedGroups = currentLevelGroups.filter(group => group.isSelected).map(g => g.id);
            

            
            // 比较选择变化
            const initialSelection = state.interaction.marqueeInitialSelection || { nodes: [], groups: [] };
            const selectionChanged = 
                currentSelectedNodes.length !== initialSelection.nodes.length ||
                currentSelectedGroups.length !== initialSelection.groups.length ||
                !currentSelectedNodes.every(id => initialSelection.nodes.includes(id)) ||
                !currentSelectedGroups.every(id => initialSelection.groups.includes(id));
            
            if (selectionChanged) {
                let selectionAction = '';
                if (currentSelectedNodes.length > 0 && currentSelectedGroups.length > 0) {
                    selectionAction = '框选节点和组';
                } else if (currentSelectedNodes.length > 0) {
                    selectionAction = '框选节点';
                } else if (currentSelectedGroups.length > 0) {
                    selectionAction = '框选组';
                } else {
                    selectionAction = '取消选择';
                }
                handleSelectionChangeWithHistory(selectionAction);
            } else {
                handleSelectionChange();
            }
            
            // 清理框选初始状态
            state.interaction.marqueeInitialSelection = null;
            state.interaction.marqueeExcludeGroups = null;
        }
        
        // 拆分移动和调整大小操作的记录
        if (state.interaction.isDragging && state.interaction.actuallyDragged) {
            // 判断是移动节点还是移动组
            const selectedNodes = state.nodes.filter(n => n.selected).length;
            const selectedGroups = state.groups.filter(g => g.selected).length;
            
            if (selectedNodes > 0 && selectedGroups > 0) {
                saveState('移动节点和组');
            } else if (selectedNodes > 0) {
                saveState('移动节点');
            } else if (selectedGroups > 0) {
                saveState('移动组');
            } else {
                saveState('移动对象');
            }
        } else if (state.interaction.isResizingGroup) {
            saveState('调整组大小');
        } else if (state.interaction.isResizingNode) {
            saveState('调整节点大小');
        }

        if (state.interaction.isDragging) {
            // 插入模式特殊处理
            if (state.settings.insertMode && state.interaction.insertTarget && state.interaction.insertDirection) {
                executeChainInsertion();
            } else {
                // 普通拖拽模式：使用简化的组框关联更新
                updateGroupAssociations();
            }
            updateMagneticGroups();
        }
        
        if (state.interaction.isResizingGroup) {
            const group = state.interaction.resizeGroup;
            const groupBounds = { x: group.x, y: group.y, width: group.width, height: group.height };
            const currentLevelNodes = getCurrentLevelNodes();
            const currentLevelGroups = getCurrentLevelGroups();
            
            currentLevelNodes.forEach(node => {
                const isInside = (node.x >= groupBounds.x && 
                                  node.x + node.width <= groupBounds.x + groupBounds.width &&
                                  node.y >= groupBounds.y &&
                                  node.y + node.height <= groupBounds.y + groupBounds.height);
                
                if (isInside) {
                     if (node.groupId !== group.id) {
                        if (node.groupId) {
                            const oldGroup = currentLevelGroups.find(g => g.id === node.groupId);
                            if(oldGroup) oldGroup.nodeIds = oldGroup.nodeIds.filter(id => id !== node.id);
                        }
                        node.groupId = group.id;
                     }
                } else if (node.groupId === group.id) {
                    node.groupId = null;
                }
            });

            group.nodeIds = currentLevelNodes
                .filter(n => n.groupId === group.id)
                .map(n => n.id);
        }
        
        // 重置交互状态 - 这应该在 handleMouseUp 中进行，而不是在 handleMouseMove 中
        state.interaction = { 
            ...state.interaction, 
            isPanning: false, 
            isDragging: false, 
            dragPrepared: false, 
            isMarquee: false, 
            isResizingGroup: false, 
            isResizingNode: false, 
            draggedItems: [], 
            magneticCluster: new Set(), 
            resizeNode: null, 
            resizeEdge: null, 
            actuallyDragged: false, 
            resizeInitialStates: null, 
            resizeInitialWidth: null, 
            insertTarget: null, 
            insertDirection: null, 
            insertHighlightRegions: [] 
        };
        
        // 恢复历史记录面板的z-index
        if (dom.newHistoryModal && dom.newHistoryModal.style.display === 'block') {
            dom.newHistoryModal.style.zIndex = '100';
        }
        
        dom.canvas.style.cursor = 'default';
        // 更新所有状态块的位置和大小
        updateStatusBlocks();
        setStateDirty();
    }
    
    // 全局事件处理函数 - 备用重置机制
    function handleGlobalMouseUp(e) {
        // 只有在有活动的交互状态时才处理
        if (state.interaction.isDragging || state.interaction.dragPrepared || 
            state.interaction.isResizingNode || state.interaction.isResizingGroup || 
            state.interaction.isPanning || state.interaction.isMarquee) {
            

            resetInteractionState();
        }
    }
    
    function handleGlobalMouseLeave(e) {
        // 当鼠标离开整个文档时重置状态
        if (e.target === document.documentElement) {
            resetInteractionState();
        }
    }
    
    function handleWindowBlur(e) {
        // 当窗口失去焦点时重置状态
        resetInteractionState();
    }
    
    function resetInteractionState() {
        // 强制重置所有交互状态
        state.interaction = {
            ...state.interaction,
            isPanning: false,
            isDragging: false,
            dragPrepared: false,
            isMarquee: false,
            isResizingGroup: false,
            isResizingNode: false,
            isMerging: false,
            draggedItems: [],
            magneticCluster: new Set(),
            resizeNode: null,
            resizeEdge: null,
            resizeGroup: null,
            actuallyDragged: false,
            resizeInitialStates: null,
            resizeInitialWidth: null,
            resizeInitialHeight: null,
            marqueeInitialSelection: null,
            marqueeExcludeGroups: null,
            mergingItems: []
        };
        
        // 恢复历史记录面板的z-index
        if (dom.newHistoryModal && dom.newHistoryModal.style.display === 'block') {
            dom.newHistoryModal.style.zIndex = '100';
        }
        
        // 重置光标
        dom.canvas.style.cursor = 'default';
        

        
        setStateDirty();
        updateStatusBlocks(); // 实时更新状态块大小和位置
    }
    

    




    
    function handleDoubleClick(e) {
        const worldPos = utils.screenToWorld(e.clientX, e.clientY);
        
        // 使用层级感知的函数来检测点击的项目
        const hitNode = getNodeAt(worldPos.x, worldPos.y);
        const hitGroup = getGroupAt(worldPos.x, worldPos.y);
        const hitItem = hitNode || hitGroup;
        
        // 检查是否点击了状态块，如果是则不允许编辑
        const hitStatusBlock = getItemAt(worldPos.x, worldPos.y);
        if (hitStatusBlock && hitStatusBlock.isStatusBlock) {
            return;
        }
        
        if (hitItem) {
            startEditing(hitItem);
        } else {
            createNode(worldPos.x, worldPos.y);
        }
    }

    function handleWheel(e) {
        e.preventDefault();
        const scaleAmount = 1.1;
        const mouse = { x: e.clientX, y: e.clientY };
        const worldPosBeforeZoom = utils.screenToWorld(mouse.x, mouse.y);
        
        state.view.zoom *= e.deltaY < 0 ? scaleAmount : 1 / scaleAmount;
        state.view.zoom = Math.max(0.1, Math.min(state.view.zoom, 5));
        
        const worldPosAfterZoom = utils.screenToWorld(mouse.x, mouse.y);
        state.view.panX += (worldPosAfterZoom.x - worldPosBeforeZoom.x) * state.view.zoom;
        state.view.panY += (worldPosAfterZoom.y - worldPosBeforeZoom.y) * state.view.zoom;
        
        // 如果正在编辑，更新编辑框的位置和大小以匹配新的缩放级别
        if (state.editingItem) {
            const currentLevelNodes = getCurrentLevelNodes();
            const editingNode = currentLevelNodes.find(n => n.id === state.editingItem.id);
            if (editingNode) {
                updateNodeDimensionsRealtime(editingNode, dom.textEditor.value);
            }
        }
        
        updateCanvasPositionInfo();
        setStateDirty();
    }
    
    // ===================================================================================
    // Touch Event Handlers
    // ===================================================================================
    
    function handleTouchStart(e) {
        // 首先处理画布名称输入框的blur逻辑（在preventDefault之前）
        // 触摸开始检查画布名称输入框失焦
        
        // 如果画布名称输入框处于活动状态且触摸目标不是输入框本身，则blur它
        if (document.activeElement === dom.canvasNameInput && e.target !== dom.canvasNameInput) {
            // 触摸事件：失去焦点
            dom.canvasNameInput.blur();
        }
        
        // 检查是否需要关闭取色器面板
        const colorPickerPanels = document.querySelectorAll('.custom-color-picker-panel');
        const closestColorPicker = e.target.closest('.custom-color-picker-panel') || e.target.closest('.custom-color-picker-wrapper');
        const isOutsideColorPicker = !closestColorPicker;
        
        // 触摸开始的颜色选择器调试
        
        if (isOutsideColorPicker) {
            // 关闭取色器
            colorPickerPanels.forEach((panel, index) => {
                const wasActive = panel.classList.contains('active');
                panel.classList.remove('active');
                // 取色器面板状态
            });
        }
        
        // 检查是否需要关闭主题下拉菜单
        const isOutsideThemeDropdown = !e.target.closest('#theme-dropdown') && !e.target.closest('#theme-switcher-btn');
        if (isOutsideThemeDropdown && dom.themeDropdown.classList.contains('show')) {
            // 关闭主题下拉菜单
            dom.themeDropdown.classList.remove('show');
        }
        
        e.preventDefault();
        resumeAnimation();
        
        const touch = state.interaction.touch;
        const now = Date.now();
        
        // 清理之前的状态
        if (touch.longPressTimer) {
            clearTimeout(touch.longPressTimer);
            touch.longPressTimer = null;
        }
        
        // 记录触摸点信息
        touch.isActive = true;
        touch.startTime = now;
        touch.gestureState = 'detecting';
        touch.longPressTriggered = false;
        touch.preventContextMenu = false;
        
        // 清空触摸点记录
        touch.touches.clear();
        touch.startPositions.clear();
        touch.lastPositions.clear();
        
        // 记录所有触摸点
        for (let i = 0; i < e.touches.length; i++) {
            const touchPoint = e.touches[i];
            const worldPos = utils.screenToWorld(touchPoint.clientX, touchPoint.clientY);
            
            touch.touches.set(touchPoint.identifier, {
                id: touchPoint.identifier,
                clientX: touchPoint.clientX,
                clientY: touchPoint.clientY,
                worldX: worldPos.x,
                worldY: worldPos.y
            });
            
            touch.startPositions.set(touchPoint.identifier, {
                clientX: touchPoint.clientX,
                clientY: touchPoint.clientY,
                worldX: worldPos.x,
                worldY: worldPos.y
            });
            
            touch.lastPositions.set(touchPoint.identifier, {
                clientX: touchPoint.clientX,
                clientY: touchPoint.clientY,
                worldX: worldPos.x,
                worldY: worldPos.y
            });
        }
        
        const touchCount = e.touches.length;
        
        if (touchCount === 1) {
            // 单指触摸
            const touchPoint = e.touches[0];
            const worldPos = utils.screenToWorld(touchPoint.clientX, touchPoint.clientY);
            
            // 检测命中的项目
            touch.hitItem = getItemAt(worldPos.x, worldPos.y);
            
            // 检测双击
            const timeSinceLastTap = now - touch.lastTapTime;
            const isDoubleTap = timeSinceLastTap <= touch.doubleTapThreshold && 
                               touch.lastTapPosition && 
                               Math.abs(touchPoint.clientX - touch.lastTapPosition.x) < 20 &&
                               Math.abs(touchPoint.clientY - touch.lastTapPosition.y) < 20;
            
            if (isDoubleTap) {
                // 双击处理
                handleTouchDoubleTap(worldPos, touch.hitItem);
                return;
            }
            
            // 记录单击信息
            touch.lastTapTime = now;
            touch.lastTapPosition = { x: touchPoint.clientX, y: touchPoint.clientY };
            
            // 设置长按定时器和进度指示器
            addLongPressProgressIndicator(worldPos.x, worldPos.y);
            touch.longPressTimer = setTimeout(() => {
                if (touch.isActive && !touch.longPressTriggered && touch.gestureState === 'detecting') {
                    handleTouchLongPress(worldPos, touch.hitItem);
                }
            }, touch.longPressThreshold);
            
            // 检测是否触摸在节点边缘（仅当节点被选中时）
            if (touch.hitItem && (touch.hitItem.type === 'node' || touch.hitItem.type === 'imageNode') && touch.hitItem.isSelected) {
                touch.resizeEdge = utils.isPointInNodeEdge(worldPos.x, worldPos.y, touch.hitItem, 8); // 增加阈值以适应触摸精度
            } else {
                touch.resizeEdge = null;
            }
            
        } else if (touchCount === 2) {
            // 双指触摸 - 缩放/平移
            const touch1 = e.touches[0];
            const touch2 = e.touches[1];
            
            // 计算双指距离和中心点
            const distance = Math.sqrt(
                Math.pow(touch2.clientX - touch1.clientX, 2) + 
                Math.pow(touch2.clientY - touch1.clientY, 2)
            );
            
            const centerX = (touch1.clientX + touch2.clientX) / 2;
            const centerY = (touch1.clientY + touch2.clientY) / 2;
            const worldCenter = utils.screenToWorld(centerX, centerY);
            
            touch.initialDistance = distance;
            touch.initialZoom = state.view.zoom;
            touch.initialCenter = worldCenter;
            touch.gestureType = 'pinch';
            touch.gestureState = 'active';
            
            // 清除长按定时器和进度指示器
            removeLongPressProgressIndicator();
            if (touch.longPressTimer) {
                clearTimeout(touch.longPressTimer);
                touch.longPressTimer = null;
            }
        }
        
        // 修复移动端编辑状态下画布内容消失问题
        // 如果当前处于编辑状态，强制重绘画布
        if (state.editingItem) {
            setStateDirty();
        }
    }
    
    function handleTouchMove(e) {
        e.preventDefault();
        
        const touch = state.interaction.touch;
        if (!touch.isActive) return;
        
        const touchCount = e.touches.length;
        
        // 更新触摸点位置
        for (let i = 0; i < e.touches.length; i++) {
            const touchPoint = e.touches[i];
            const worldPos = utils.screenToWorld(touchPoint.clientX, touchPoint.clientY);
            
            if (touch.touches.has(touchPoint.identifier)) {
                touch.touches.set(touchPoint.identifier, {
                    id: touchPoint.identifier,
                    clientX: touchPoint.clientX,
                    clientY: touchPoint.clientY,
                    worldX: worldPos.x,
                    worldY: worldPos.y
                });
            }
        }
        
        if (touchCount === 1) {
            handleSingleFingerMove(e.touches[0]);
        } else if (touchCount === 2) {
            handleTwoFingerMove(e.touches[0], e.touches[1]);
        }
    }
    
    function handleTouchEnd(e) {
        e.preventDefault();
        
        const touch = state.interaction.touch;
        if (!touch.isActive) return;
        
        // 清理定时器和进度指示器
        if (touch.longPressTimer) {
            clearTimeout(touch.longPressTimer);
            touch.longPressTimer = null;
        }
        removeLongPressProgressIndicator();
        
        const remainingTouches = e.touches.length;
        
        if (remainingTouches === 0) {
            // 所有触摸点都结束了
            handleTouchComplete();
            
            // 修复移动端编辑状态下画布内容消失问题
            // 如果当前处于编辑状态，强制重绘画布
            if (state.editingItem) {
                setStateDirty();
            }
        } else {
            // 还有触摸点，更新状态
            touch.touches.clear();
            for (let i = 0; i < e.touches.length; i++) {
                const touchPoint = e.touches[i];
                const worldPos = utils.screenToWorld(touchPoint.clientX, touchPoint.clientY);
                touch.touches.set(touchPoint.identifier, {
                    id: touchPoint.identifier,
                    clientX: touchPoint.clientX,
                    clientY: touchPoint.clientY,
                    worldX: worldPos.x,
                    worldY: worldPos.y
                });
            }
        }
    }
    
    function handleTouchCancel(e) {
        e.preventDefault();
        resetTouchState();
    }
    
    // 触摸手势处理函数
    function handleSingleFingerMove(touchPoint) {
        const touch = state.interaction.touch;
        const startPos = touch.startPositions.get(touchPoint.identifier);
        if (!startPos) return;
        
        const deltaX = touchPoint.clientX - startPos.clientX;
        const deltaY = touchPoint.clientY - startPos.clientY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (distance >= touch.dragThreshold && touch.gestureState === 'detecting') {
            // 超过拖拽阈值，确定手势类型
            touch.gestureState = 'active';
            
            // 清除长按定时器
            if (touch.longPressTimer) {
                clearTimeout(touch.longPressTimer);
                touch.longPressTimer = null;
            }
            
            if (touch.hitItem && touch.resizeEdge) {
                // 节点边缘拖拽 - 调整大小
                touch.gestureType = 'resize';
                startTouchResize(touch.hitItem, touch.resizeEdge);
            } else if (touch.hitItem) {
                // 拖拽节点/组
                touch.gestureType = 'drag';
                startTouchDrag(touch.hitItem);
            } else {
                // 框选
                touch.gestureType = 'marquee';
                startTouchMarquee(startPos);
            }
        }
        
        if (touch.gestureState === 'active') {
            if (touch.gestureType === 'drag') {
                updateTouchDrag(touchPoint);
            } else if (touch.gestureType === 'marquee') {
                updateTouchMarquee(touchPoint);
            } else if (touch.gestureType === 'resize') {
                updateTouchResize(touchPoint);
            }
        }
    }
    
    // 开始触摸调整大小
    function startTouchResize(hitItem, resizeEdge) {
        state.interaction.isResizingNode = true;
        state.interaction.resizeNode = hitItem;
        state.interaction.resizeEdge = resizeEdge;
        
        // 记录初始状态用于多选节点同步调整
        const selectedNodes = getSelectedNodes();
        if (selectedNodes.length > 1) {
            state.interaction.resizeInitialStates = selectedNodes.map(node => ({
                node: node,
                initialX: node.x,
                initialY: node.y,
                initialWidth: node.width,
                initialHeight: node.height
            }));
        } else {
            state.interaction.resizeInitialStates = null;
        }
        
        state.interaction.resizeInitialWidth = hitItem.width;
        state.interaction.resizeInitialHeight = hitItem.height;
    }
    
    // 更新触摸调整大小
    function updateTouchResize(touchPoint) {
        const worldPos = utils.screenToWorld(touchPoint.clientX, touchPoint.clientY);
        const interaction = state.interaction;
        const node = interaction.resizeNode;
        const resizeEdge = interaction.resizeEdge;
        const minWidth = state.settings.gridSize * 2;
        const minHeight = state.settings.gridSize * 2;
        
        if (node.type === 'imageNode') {
            const newWidth = Math.max(50, worldPos.x - node.x);
            node.width = utils.snap(newWidth);
            const pureImageHeight = (node.width - 20) / node.imageAspectRatio;
            const lines = utils.getWrappedTextLines(node.text, node.width - 20);
            const textAreaHeight = node.text.trim() ? Math.max(20, lines.length * utils.getFontSize(node.font) * 1.2) : 0;
            node.height = utils.snap(pureImageHeight + textAreaHeight + 20);
        } else {
            if (resizeEdge === 'right') {
                // 右侧调节宽度
                const newWidth = Math.max(minWidth, worldPos.x - node.x);
                const snappedNewWidth = utils.snap(newWidth);
                node.width = snappedNewWidth;
                // 标记为手动调节过宽度
                node.manuallyAdjustedWidth = true;
                
                // 无论高度是否被手动调整过，都重新计算文本换行
                // 但只在高度未被手动调整时更新高度
                updateNodeHeightSmart(node);
                
                // 多选节点宽度同步调整
                if (interaction.resizeInitialStates && interaction.resizeInitialStates.length > 1) {
                    const currentNode = interaction.resizeNode;
                    const initialWidth = interaction.resizeInitialWidth;
                    
                    const widthDelta = snappedNewWidth - initialWidth;
                    interaction.resizeInitialStates.forEach(state => {
                        if (state.node !== currentNode) {
                            const newNodeWidth = Math.max(minWidth, state.initialWidth + widthDelta);
                            state.node.width = utils.snap(newNodeWidth);
                            state.node.manuallyAdjustedWidth = true;
                            // 无论高度是否被手动调整过，都重新计算文本换行
                            updateNodeHeightSmart(state.node);
                        }
                    });
                }
            } else if (resizeEdge === 'left') {
                // 左侧调节宽度
                const newX = Math.min(node.x + node.width - minWidth, worldPos.x);
                const snappedNewX = utils.snap(newX);
                const newWidth = node.x + node.width - snappedNewX;
                node.x = snappedNewX;
                node.width = newWidth;
                // 标记为手动调节过宽度
                node.manuallyAdjustedWidth = true;
                
                // 应用新规则：拖拽调整宽度后智能更新高度（仅在高度未被手动调整时）
                if (node.manuallyAdjustedHeight !== true) {
                    updateNodeHeightSmart(node);
                }
                
                // 多选节点宽度同步调整
                if (interaction.resizeInitialStates && interaction.resizeInitialStates.length > 1) {
                    const currentNode = interaction.resizeNode;
                    const initialWidth = interaction.resizeInitialWidth;
                    
                    const widthDelta = newWidth - initialWidth;
                    interaction.resizeInitialStates.forEach(state => {
                        if (state.node !== currentNode) {
                            const newNodeWidth = Math.max(minWidth, state.initialWidth + widthDelta);
                            const deltaX = state.node.width - newNodeWidth;
                            state.node.x += deltaX;
                            state.node.width = utils.snap(newNodeWidth);
                            state.node.manuallyAdjustedWidth = true;
                            // 无论高度是否被手动调整过，都重新计算文本换行
                            updateNodeHeightSmart(state.node);
                        }
                    });
                }
            } else if (resizeEdge === 'top') {
                // 上侧调节高度
                // 计算文字所需的最小高度
                const textMinHeight = utils.getRequiredHeightForText(node.text, node.width);
                const actualMinHeight = Math.max(minHeight, textMinHeight);
                
                const newY = Math.min(node.y + node.height - actualMinHeight, worldPos.y);
                const snappedNewY = utils.snap(newY);
                const newHeight = node.y + node.height - snappedNewY;
                node.y = snappedNewY;
                node.height = Math.max(actualMinHeight, newHeight);
                // 标记为手动调节过高度
                node.manuallyAdjustedHeight = true;
                
                // 多选节点高度同步调整
                if (interaction.resizeInitialStates && interaction.resizeInitialStates.length > 1) {
                    const currentNode = interaction.resizeNode;
                    const initialHeight = interaction.resizeInitialHeight;
                    
                    const heightDelta = newHeight - initialHeight;
                    interaction.resizeInitialStates.forEach(state => {
                        if (state.node !== currentNode) {
                            const nodeTextMinHeight = utils.getRequiredHeightForText(state.node.text, state.node.width);
                            const nodeActualMinHeight = Math.max(minHeight, nodeTextMinHeight);
                            const newNodeHeight = Math.max(nodeActualMinHeight, state.initialHeight + heightDelta);
                            const deltaY = state.node.height - newNodeHeight;
                            state.node.y += deltaY;
                            state.node.height = utils.snap(newNodeHeight);
                            state.node.manuallyAdjustedHeight = true;
                        }
                    });
                }
            } else if (resizeEdge === 'bottom') {
                // 下侧调节高度
                // 计算文字所需的最小高度
                const textMinHeight = utils.getRequiredHeightForText(node.text, node.width);
                const actualMinHeight = Math.max(minHeight, textMinHeight);
                
                const newHeight = Math.max(actualMinHeight, worldPos.y - node.y);
                node.height = utils.snap(newHeight);
                // 标记为手动调节过高度
                node.manuallyAdjustedHeight = true;
                
                // 多选节点高度同步调整
                if (interaction.resizeInitialStates && interaction.resizeInitialStates.length > 1) {
                    const currentNode = interaction.resizeNode;
                    const initialHeight = interaction.resizeInitialHeight;
                    
                    const heightDelta = newHeight - initialHeight;
                    interaction.resizeInitialStates.forEach(state => {
                        if (state.node !== currentNode) {
                            const nodeTextMinHeight = utils.getRequiredHeightForText(state.node.text, state.node.width);
                            const nodeActualMinHeight = Math.max(minHeight, nodeTextMinHeight);
                            const newNodeHeight = Math.max(nodeActualMinHeight, state.initialHeight + heightDelta);
                            state.node.height = utils.snap(newNodeHeight);
                            state.node.manuallyAdjustedHeight = true;
                        }
                    });
                }
            }
        }
        
        setStateDirty();
        updateStatusBlocks(); // 实时更新状态块大小和位置
    }
    
    function handleTwoFingerMove(touch1, touch2) {
        const touch = state.interaction.touch;
        if (touch.gestureType !== 'pinch') return;
        
        const distance = Math.sqrt(
            Math.pow(touch2.clientX - touch1.clientX, 2) + 
            Math.pow(touch2.clientY - touch1.clientY, 2)
        );
        
        const centerX = (touch1.clientX + touch2.clientX) / 2;
        const centerY = (touch1.clientY + touch2.clientY) / 2;
        
        // 缩放处理
        if (touch.initialDistance > 0) {
            const scaleRatio = distance / touch.initialDistance;
            const newZoom = Math.max(0.1, Math.min(5, touch.initialZoom * scaleRatio));
            
            if (Math.abs(newZoom - state.view.zoom) > 0.01) {
                // 以初始中心点为基准进行缩放
                const worldPosBeforeZoom = touch.initialCenter;
                state.view.zoom = newZoom;
                const worldPosAfterZoom = utils.screenToWorld(centerX, centerY);
                
                state.view.panX += (worldPosAfterZoom.x - worldPosBeforeZoom.x) * state.view.zoom;
                state.view.panY += (worldPosAfterZoom.y - worldPosBeforeZoom.y) * state.view.zoom;
                
                updateCanvasPositionInfo();
                setStateDirty();
            }
        }
        
        // 平移处理（双指拖拽）
        const lastTouch1 = touch.lastPositions.get(touch1.identifier);
        const lastTouch2 = touch.lastPositions.get(touch2.identifier);
        
        if (lastTouch1 && lastTouch2) {
            const lastCenterX = (lastTouch1.clientX + lastTouch2.clientX) / 2;
            const lastCenterY = (lastTouch1.clientY + lastTouch2.clientY) / 2;
            
            const panDeltaX = centerX - lastCenterX;
            const panDeltaY = centerY - lastCenterY;
            
            if (Math.abs(panDeltaX) > 2 || Math.abs(panDeltaY) > 2) {
                state.view.panX += panDeltaX;
                state.view.panY += panDeltaY;
                updateCanvasPositionInfo();
                setStateDirty();
            }
        }
        
        // 更新上次位置
        touch.lastPositions.set(touch1.identifier, {
            clientX: touch1.clientX,
            clientY: touch1.clientY
        });
        touch.lastPositions.set(touch2.identifier, {
            clientX: touch2.clientX,
            clientY: touch2.clientY
        });
        
        // 修复移动端双指操作时编辑框与节点分离问题
        // 复制PC端handleWheel函数的编辑框位置更新逻辑
        if (state.editingItem) {
            const currentLevelNodes = getCurrentLevelNodes();
            const editingNode = currentLevelNodes.find(n => n.id === state.editingItem.id);
            if (editingNode) {
                updateNodeDimensionsRealtime(editingNode, dom.textEditor.value);
            }
        }
    }
    
    function handleTouchDoubleTap(worldPos, hitItem) {
        const touch = state.interaction.touch;
        touch.gestureType = 'double_tap';
        touch.gestureState = 'active';
        
        if (hitItem) {
            // 如果是状态块，特殊处理
            if (hitItem.isStatusBlock) {
                // 双击切换状态块状态
                hitItem.statusIndex = (hitItem.statusIndex + 1) % statusColors.length;
                hitItem.backgroundColor = statusColors[hitItem.statusIndex].color;
                hitItem.text = statusColors[hitItem.statusIndex].status; // 更新状态文字
                hitItem.color = getContrastingColor(statusColors[hitItem.statusIndex].color); // 更新文字颜色
                hitItem.textLines = null; // 清除文本行缓存，确保重新计算文字行
                saveState('切换状态块状态');
                setStateDirty();
            } else {
                // 双击节点/组标签 - 进入编辑模式
                startEditing(hitItem);
            }
        } else {
            // 双击画布空白区域 - 创建节点
            createNode(worldPos.x, worldPos.y);
        }
        
        resetTouchState();
    }
    
    function handleTouchLongPress(worldPos, hitItem) {
        const touch = state.interaction.touch;
        touch.longPressTriggered = true;
        touch.gestureType = 'long_press';
        touch.gestureState = 'active';
        
        // 如果在编辑状态，先停止编辑
        if (state.editingItem) {
            stopEditing();
        }
        
        // 触发振动反馈
        if (navigator.vibrate) {
            navigator.vibrate(50);
        }
        
        // 添加视觉反馈
        addTouchFeedback(worldPos.x, worldPos.y, 'long-press');
        
        // 智能处理长按选择逻辑，支持多选场景
        if (hitItem) {
            // 检查被长按的项目是否已经被选中
            if (!hitItem.isSelected) {
                // 如果未选中，清除其他选择并选中当前项目
                getCurrentLevelNodes().forEach(n => n.isSelected = false);
                getCurrentLevelGroups().forEach(g => g.isSelected = false);
                hitItem.isSelected = true;
                
                // 触发选择变化处理
                handleSelectionChange();
            }
            // 如果已选中，保持当前所有选择状态不变，直接弹出菜单
        }
        
        // 显示上下文菜单
        showTouchContextMenu(worldPos.x, worldPos.y, hitItem);
        
        // 在移动端主动触发 contextmenu 事件，确保菜单正确显示
        if (isMobile() || isTablet()) {
            // 获取触摸点的屏幕坐标
            const touch = state.interaction.touch;
            const firstTouchId = touch.startPositions.keys().next().value;
            const startPos = touch.startPositions.get(firstTouchId);
            if (startPos) {
                // 创建并触发自定义的 contextmenu 事件，使用屏幕显示坐标
                // 直接使用clientX/clientY，因为contextmenu事件需要的是屏幕显示坐标而不是物理像素坐标
                // 使用clientX/clientY属性，这是在handleTouchStart中实际存储的属性名
                const contextMenuEvent = new MouseEvent('contextmenu', {
                    bubbles: true,
                    cancelable: true,
                    clientX: startPos.clientX,
                    clientY: startPos.clientY,
                    button: 2, // 右键
                    buttons: 2 // 右键按下
                });
                dom.canvas.dispatchEvent(contextMenuEvent);
            }
        }
        
        touch.preventContextMenu = true;
    }
    
    function handleTouchComplete() {
        const touch = state.interaction.touch;
        
        if (touch.gestureState === 'detecting' && !touch.longPressTriggered) {
            // 简单的单击
            handleTouchTap();
        }
        
        // 完成拖拽、框选或调整大小
        if (touch.gestureType === 'drag') {
            finishTouchDrag();
        } else if (touch.gestureType === 'marquee') {
            finishTouchMarquee();
        } else if (touch.gestureType === 'resize') {
            finishTouchResize();
        }
        
        resetTouchState();
    }
    
    // 完成触摸调整大小
    function finishTouchResize() {
        // 保存操作历史
        if (state.actionStack.canPush) {
            saveActionToHistory();
        }
        
        // 重置调整大小状态
        state.interaction.isResizingNode = false;
        state.interaction.resizeNode = null;
        state.interaction.resizeEdge = null;
        state.interaction.resizeInitialStates = null;
        
        // 重绘画布以确保更新显示
        setStateDirty();
    }
    
    function handleTouchTap() {
        const touch = state.interaction.touch;
        const firstTouchId = touch.startPositions.keys().next().value;
        const startPos = touch.startPositions.get(firstTouchId);
        if (!startPos) return;
        
        const worldPos = { x: startPos.worldX, y: startPos.worldY };
        
        if (touch.hitItem) {
            // 单击节点/组
            if (touch.hitItem.isSelected) {
                // 已选中 -> 取消选中
                touch.hitItem.isSelected = false;
            } else {
                // 未选中 -> 选中
                touch.hitItem.isSelected = true;
            }
            handleSelectionChange();
        } else {
            // 单击画布空白区域
            // 隐藏所有上下文菜单
            hideAllContextMenus();
            
            if (state.editingItem) {
                // 确认编辑完毕
                stopEditing();
            } else {
                // 取消所有选择
                getCurrentLevelNodes().forEach(n => n.isSelected = false);
                getCurrentLevelGroups().forEach(g => g.isSelected = false);
                handleSelectionChange();
            }
        }
        
        setStateDirty();
    }
    
    function startTouchDrag(hitItem) {
        // 准备拖拽
        if (!hitItem.isSelected) {
            getCurrentLevelNodes().forEach(n => n.isSelected = false);
            getCurrentLevelGroups().forEach(g => g.isSelected = false);
            hitItem.isSelected = true;
        }
        
        const selectedNodes = getSelectedNodes();
        const selectedGroups = getSelectedGroups();
        
        // 添加磁吸功能支持
        let dragCandidates = new Set([...selectedNodes, ...selectedGroups]);
        if (state.settings.magneticNodes) {
            dragCandidates.forEach(item => {
                if (item.type === 'node' || item.type === 'imageNode') {
                    const cluster = state.magneticGroups.find(c => c.has(item.id));
                    if (cluster) {
                        const currentLevelNodes = getCurrentLevelNodes();
                        cluster.forEach(nodeId => {
                            const magneticNode = currentLevelNodes.find(n => n.id === nodeId);
                            if (magneticNode) dragCandidates.add(magneticNode);
                        });
                    }
                }
            });
        }
        state.interaction.draggedItems = Array.from(dragCandidates);
        
        // 设置拖拽偏移
        const touch = state.interaction.touch;
        const firstTouchId = touch.startPositions.keys().next().value;
        const startPos = touch.startPositions.get(firstTouchId);
        
        state.interaction.dragOffsets.clear();
        state.interaction.draggedItems.forEach(item => {
            state.interaction.dragOffsets.set(item.id, {
                x: startPos.worldX - item.x,
                y: startPos.worldY - item.y
            });
        });
        
        state.interaction.isDragging = true;
    }
    
    function updateTouchDrag(touchPoint) {
        const worldPos = utils.screenToWorld(touchPoint.clientX, touchPoint.clientY);
        
        if (state.interaction.draggedItems.length === 0) return;
        
        const primaryItem = state.interaction.draggedItems[0];
        const offset = state.interaction.dragOffsets.get(primaryItem.id) || { x: 0, y: 0 };
        
        let newX = worldPos.x - offset.x;
        let newY = worldPos.y - offset.y;
        
        if (state.settings.snapToGrid) {
            newX = utils.snap(newX);
            newY = utils.snap(newY);
        }
        
        const deltaX = newX - primaryItem.x;
        const deltaY = newY - primaryItem.y;
        
        // 插入模式特殊处理
        if (state.settings.insertMode) {
            // 在插入模式下，清除之前的高亮区域
            state.interaction.insertHighlightRegions = [];
            state.interaction.insertTarget = null;
            state.interaction.insertDirection = null;
            
            // 检测目标节点并计算插入区域
            const currentLevelNodes = getCurrentLevelNodes();
            const draggedNodeIds = new Set(state.interaction.draggedItems.map(item => item.id));
            
            for (const targetNode of currentLevelNodes) {
                // 跳过正在拖拽的节点
                if (draggedNodeIds.has(targetNode.id)) continue;
                
                // 检查鼠标是否在目标节点附近（紧贴判定）
                const proximity = 1; // 与磁吸功能相同的紧贴判定距离
                const expandedTarget = {
                    x: targetNode.x - proximity,
                    y: targetNode.y - proximity,
                    width: targetNode.width + 2 * proximity,
                    height: targetNode.height + 2 * proximity
                };
                
                if (utils.isPointInNode(worldPos.x, worldPos.y, expandedTarget)) {
                    // 计算四个三角形区域
                    const centerX = targetNode.x + targetNode.width / 2;
                    const centerY = targetNode.y + targetNode.height / 2;
                    const relativeX = worldPos.x - centerX;
                    const relativeY = worldPos.y - centerY;
                    
                    // 判断在哪个三角形区域
                    let direction = '';
                    if (Math.abs(relativeX) > Math.abs(relativeY)) {
                        direction = relativeX > 0 ? 'right' : 'left';
                    } else {
                        direction = relativeY > 0 ? 'bottom' : 'top';
                    }
                    
                    // 设置插入目标和方向
                    state.interaction.insertTarget = targetNode;
                    state.interaction.insertDirection = direction;
                    
                    // 创建高亮区域
                    const triangleSize = 20;
                    let highlightRegion = {};
                    
                    switch (direction) {
                        case 'top':
                            highlightRegion = {
                                type: 'triangle',
                                points: [
                                    { x: centerX, y: targetNode.y },
                                    { x: centerX - triangleSize, y: targetNode.y + triangleSize },
                                    { x: centerX + triangleSize, y: targetNode.y + triangleSize }
                                ]
                            };
                            break;
                        case 'bottom':
                            highlightRegion = {
                                type: 'triangle',
                                points: [
                                    { x: centerX, y: targetNode.y + targetNode.height },
                                    { x: centerX - triangleSize, y: targetNode.y + targetNode.height - triangleSize },
                                    { x: centerX + triangleSize, y: targetNode.y + targetNode.height - triangleSize }
                                ]
                            };
                            break;
                        case 'left':
                            highlightRegion = {
                                type: 'triangle',
                                points: [
                                    { x: targetNode.x, y: centerY },
                                    { x: targetNode.x + triangleSize, y: centerY - triangleSize },
                                    { x: targetNode.x + triangleSize, y: centerY + triangleSize }
                                ]
                            };
                            break;
                        case 'right':
                            highlightRegion = {
                                type: 'triangle',
                                points: [
                                    { x: targetNode.x + targetNode.width, y: centerY },
                                    { x: targetNode.x + targetNode.width - triangleSize, y: centerY - triangleSize },
                                    { x: targetNode.x + targetNode.width - triangleSize, y: centerY + triangleSize }
                                ]
                            };
                            break;
                    }
                    
                    state.interaction.insertHighlightRegions = [highlightRegion];
                    break; // 找到第一个目标就停止
                }
            }
        }
        
        // 应用碰撞检测、推动功能或直接移动
        const itemsToMoveInitially = new Set();
        
        // 添加直接拖拽的项目及其关联的状态块
        state.interaction.draggedItems.forEach(item => {
            itemsToMoveInitially.add(item);
            
            // 如果拖拽的是组框，添加组内所有节点
            if (item.type === 'group') {
                getCurrentLevelNodes()
                    .filter(n => n.groupId === item.id)
                    .forEach(node => itemsToMoveInitially.add(node));
            }
            
            // 如果拖拽的是节点，添加与其关联的状态块
            if (!item.isStatusBlock) {
                getCurrentLevelNodes()
                    .filter(n => n.isStatusBlock && n.targetNodeId === item.id)
                    .forEach(statusBlock => itemsToMoveInitially.add(statusBlock));
            }
        });
        
        let finalDelta = { x: deltaX, y: deltaY };
        
        // 插入模式下跳过碰撞检测和推动逻辑
        if (state.settings.insertMode) {
            // 插入模式：直接移动，无视碰撞和推动
            itemsToMoveInitially.forEach(item => {
                item.x += finalDelta.x;
                item.y += finalDelta.y;
                
                // 如果是组，移动组内节点
                if (item.type === 'group') {
                    getCurrentLevelNodes()
                        .filter(n => n.groupId === item.id)
                        .forEach(node => {
                            node.x += finalDelta.x;
                            node.y += finalDelta.y;
                        });
                }
            });
        } else if (state.settings.pushMode) {
            // 推动模式：推动重叠的节点
            const currentLevelNodes = getCurrentLevelNodes();
            
            let pushDelta = { x: 0, y: 0 };
            if (Math.abs(finalDelta.x) > Math.abs(finalDelta.y)) {
                pushDelta.x = finalDelta.x;
            } else {
                pushDelta.y = finalDelta.y;
            }

            const movedThisFrame = new Set(itemsToMoveInitially);
            
            itemsToMoveInitially.forEach(item => {
                item.x += pushDelta.x;
                item.y += pushDelta.y;
                
                // 如果是组，移动组内节点
                if (item.type === 'group') {
                    getCurrentLevelNodes()
                        .filter(n => n.groupId === item.id)
                        .forEach(node => {
                            node.x += pushDelta.x;
                            node.y += pushDelta.y;
                        });
                }
            });
            
            const queue = [...itemsToMoveInitially];
            let safety = 0;
            while(queue.length > 0 && safety < currentLevelNodes.length * 2) {
                const mover = queue.shift();
                safety++;
                
                currentLevelNodes.forEach(staticNode => {
                    if (movedThisFrame.has(staticNode)) return;

                    if (utils.checkOverlap(mover, staticNode)) {
                        staticNode.x += pushDelta.x;
                        staticNode.y += pushDelta.y;
                        movedThisFrame.add(staticNode);
                        queue.push(staticNode);
                    }
                });
            }
        } else {
            // 普通模式：应用碰撞检测（如果开启）
            if (state.settings.collisionDetection) {
                const allMovingNodes = [...itemsToMoveInitially].filter(item => item.type !== 'group');
                const allMovingNodesSet = new Set(allMovingNodes);
                
                // 只在当前层级进行碰撞检测
                const currentLevelNodes = getCurrentLevelNodes();

                if (allMovingNodes.length > 0) {
                    let allowedDx = finalDelta.x;
                    if (allowedDx !== 0) {
                        for (const draggedNode of allMovingNodes) {
                            for (const staticNode of currentLevelNodes) {
                                if (allMovingNodesSet.has(staticNode)) continue;
                                const moverRectX = { x: draggedNode.x + allowedDx, y: draggedNode.y, width: draggedNode.width, height: draggedNode.height };
                                if (utils.checkOverlap(moverRectX, staticNode)) {
                                    if (allowedDx > 0) { allowedDx = Math.min(allowedDx, staticNode.x - (draggedNode.x + draggedNode.width)); }
                                    else { allowedDx = Math.max(allowedDx, (staticNode.x + staticNode.width) - draggedNode.x); }
                                }
                            }
                        }
                    }
                    finalDelta.x = allowedDx;

                    let allowedDy = finalDelta.y;
                    if (allowedDy !== 0) {
                        for (const draggedNode of allMovingNodes) {
                            for (const staticNode of currentLevelNodes) {
                                if (allMovingNodesSet.has(staticNode)) continue;
                                const moverRectY = { x: draggedNode.x + finalDelta.x, y: draggedNode.y + allowedDy, width: draggedNode.width, height: draggedNode.height };
                                if (utils.checkOverlap(moverRectY, staticNode)) {
                                    if (allowedDy > 0) { allowedDy = Math.min(allowedDy, staticNode.y - (draggedNode.y + draggedNode.height)); }
                                    else { allowedDy = Math.max(allowedDy, (staticNode.y + staticNode.height) - draggedNode.y); }
                                }
                            }
                        }
                    }
                    finalDelta.y = allowedDy;
                }
            }
            
            // 移动所有拖拽项目
            itemsToMoveInitially.forEach(item => {
                item.x += finalDelta.x;
                item.y += finalDelta.y;
                
                // 如果是组，移动组内节点
                if (item.type === 'group') {
                    getCurrentLevelNodes()
                        .filter(n => n.groupId === item.id)
                        .forEach(node => {
                            node.x += finalDelta.x;
                            node.y += finalDelta.y;
                        });
                }
            });
        }
        
        setStateDirty();
        updateStatusBlocks(); // 实时更新状态块大小和位置
    }
    
    function finishTouchDrag() {
        if (state.interaction.isDragging) {
            // 插入模式特殊处理
            if (state.settings.insertMode && state.interaction.insertTarget && state.interaction.insertDirection) {
                executeChainInsertion();
            } else {
                // 普通拖拽模式：使用简化的组框关联更新
                updateGroupAssociations();
            }
            updateMagneticGroups();
            saveState('移动对象');
        }
        
        state.interaction.isDragging = false;
        state.interaction.draggedItems = [];
        state.interaction.dragOffsets.clear();
        
        // 清除插入模式的高亮状态
        if (state.settings.insertMode) {
            state.interaction.insertTarget = null;
            state.interaction.insertDirection = null;
            state.interaction.insertHighlightRegions = [];
        }
    }
    
    function startTouchMarquee(startPos) {
        const currentNodes = getCurrentLevelNodes();
        const currentGroups = getCurrentLevelGroups();
        
        // 记录框选开始前的选择状态
        state.interaction.touch.marqueeInitialSelection = {
            nodes: currentNodes.filter(n => n.isSelected).map(n => n.id),
            groups: currentGroups.filter(g => g.isSelected).map(g => g.id)
        };
        
        state.interaction.isMarquee = true;
        state.interaction.marqueeRect = {
            x: startPos.worldX,
            y: startPos.worldY,
            width: 0,
            height: 0
        };
    }
    
    function updateTouchMarquee(touchPoint) {
        const worldPos = utils.screenToWorld(touchPoint.clientX, touchPoint.clientY);
        const touch = state.interaction.touch;
        const firstTouchId = touch.startPositions.keys().next().value;
        const startPos = touch.startPositions.get(firstTouchId);
        
        if (!startPos || !state.interaction.marqueeRect) return;
        
        // 更新框选矩形
        const minX = Math.min(startPos.worldX, worldPos.x);
        const minY = Math.min(startPos.worldY, worldPos.y);
        const maxX = Math.max(startPos.worldX, worldPos.x);
        const maxY = Math.max(startPos.worldY, worldPos.y);
        
        state.interaction.marqueeRect = {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
        };
        
        // 实时更新选择状态
        const currentNodes = getCurrentLevelNodes();
        const currentGroups = getCurrentLevelGroups();
        
        currentNodes.forEach(node => {
            const isInMarquee = utils.checkOverlap(
                { x: node.x, y: node.y, width: node.width, height: node.height },
                state.interaction.marqueeRect
            );
            
            if (isInMarquee) {
                node.isSelected = true;
            }
        });
        
        currentGroups.forEach(group => {
            const isInMarquee = utils.checkOverlap(
                { x: group.x, y: group.y, width: group.width, height: group.height },
                state.interaction.marqueeRect
            );
            
            if (isInMarquee) {
                group.isSelected = true;
            }
        });
        
        setStateDirty();
    }
    
    function finishTouchMarquee() {
        if (state.interaction.isMarquee) {
            handleSelectionChange();
        }
        
        state.interaction.isMarquee = false;
        state.interaction.marqueeRect = null;
        state.interaction.touch.marqueeInitialSelection = null;
    }
    
    function resetTouchState() {
        const touch = state.interaction.touch;
        
        if (touch.longPressTimer) {
            clearTimeout(touch.longPressTimer);
            touch.longPressTimer = null;
        }
        
        if (touch.doubleTapTimer) {
            clearTimeout(touch.doubleTapTimer);
            touch.doubleTapTimer = null;
        }
        
        removeLongPressProgressIndicator();
        
        touch.isActive = false;
        touch.touches.clear();
        touch.startPositions.clear();
        touch.lastPositions.clear();
        touch.gestureType = null;
        touch.gestureState = 'idle';
        touch.longPressTriggered = false;
        touch.preventContextMenu = false;
        touch.hitItem = null;
        touch.initialDistance = 0;
        touch.initialZoom = 1;
        touch.initialCenter = null;
        touch.resizeEdge = null;
        touch.marqueeInitialSelection = null;
    }
    
    // 触摸反馈函数
    function addTouchFeedback(worldX, worldY, type = 'tap') {
        const screenPos = utils.worldToScreen(worldX, worldY);
        
        // 创建反馈元素
        const feedback = document.createElement('div');
        feedback.className = type === 'long-press' ? 'long-press-feedback' : 'touch-feedback';
        
        // 设置位置和大小
        const size = type === 'long-press' ? 30 : 20;
        feedback.style.left = (screenPos.x - size / 2) + 'px';
        feedback.style.top = (screenPos.y - size / 2) + 'px';
        feedback.style.width = size + 'px';
        feedback.style.height = size + 'px';
        
        // 添加到页面
        document.body.appendChild(feedback);
        
        // 动画结束后移除
        const duration = type === 'long-press' ? 300 : 600;
        setTimeout(() => {
            if (feedback.parentNode) {
                feedback.parentNode.removeChild(feedback);
            }
        }, duration);
    }
    
    function addLongPressProgressIndicator(worldX, worldY) {
        const screenPos = utils.worldToScreen(worldX, worldY);
        
        // 创建进度指示器
        const indicator = document.createElement('div');
        indicator.className = 'long-press-progress';
        indicator.style.position = 'absolute';
        indicator.style.left = (screenPos.x - 15) + 'px';
        indicator.style.top = (screenPos.y - 15) + 'px';
        indicator.style.width = '30px';
        indicator.style.height = '30px';
        indicator.style.border = '3px solid rgba(59, 130, 246, 0.3)';
        indicator.style.borderTop = '3px solid #3b82f6';
        indicator.style.borderRadius = '50%';
        indicator.style.animation = 'spin 0.3s linear';
        indicator.style.zIndex = '9999';
        indicator.style.pointerEvents = 'none';
        
        // 添加旋转动画
        const style = document.createElement('style');
        style.textContent = `
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        `;
        document.head.appendChild(style);
        
        document.body.appendChild(indicator);
        
        // 存储引用以便清理
        state.interaction.touch.progressIndicator = indicator;
        
        return indicator;
    }
    
    function removeLongPressProgressIndicator() {
        const indicator = state.interaction.touch.progressIndicator;
        if (indicator && indicator.parentNode) {
            indicator.parentNode.removeChild(indicator);
            state.interaction.touch.progressIndicator = null;
        }
    }

    function handleKeyDown(e) {
        // 最基础的调试信息 - 确认函数被调用
        
        // 恢复动画
        resumeAnimation();
        
        // 调试信息：显示当前状态
        
        // 如果确认对话框正在显示，屏蔽所有快捷键
        if (dom.confirmModalBackdrop.style.display === 'flex') {
            return;
        }
        
        if (dom.themeDropdown.classList.contains('show')) {
            return;
        }

        // 检查是否应该处理搜索导航方向键
        const isSearchBoxFocused = document.activeElement === dom.searchBox;
        const hasSearchResults = state.interaction.searchResults.length > 0;
        
        // 如果搜索框获得焦点或有搜索结果，处理方向键导航
        if ((isSearchBoxFocused || hasSearchResults) && !e.ctrlKey && !e.metaKey && !e.altKey) {
            if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
                e.preventDefault();
                focusOnSearchResult('prev');
                return;
            }
            if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
                e.preventDefault();
                focusOnSearchResult('next');
                return;
            }
        }

        // 检查是否应该阻止快捷键执行
        const isShortcutModalOpen = dom.shortcutModalBackdrop.style.display === 'flex';
        const isShortcutInputFocused = document.activeElement.classList.contains('shortcut-input') || document.activeElement.classList.contains('shortcut-main-input');
        
        if (state.editingItem || document.activeElement === dom.canvasNameInput || document.activeElement === dom.searchBox || (isShortcutModalOpen && isShortcutInputFocused)) {
            const reason = state.editingItem ? 'editingItem' : 
                document.activeElement === dom.canvasNameInput ? 'canvasNameInput' :
                document.activeElement === dom.searchBox ? 'searchBox' :
                (isShortcutModalOpen && isShortcutInputFocused) ? 'shortcutModal' : 'unknown';
            // 快捷键被阻止
            return;
        }

        let shortcutHandled = false;
        
        // 检查所有配置的快捷键
        
        // 添加详细的快捷键匹配调试信息
        const shortcuts = [
            { name: 'save', config: state.settings.saveShortcut, action: () => directSave() },
            { name: 'saveAs', config: state.settings.saveAsShortcut, action: () => saveAs() },
            { name: 'load', config: state.settings.loadShortcut, action: () => dom.loadBtn.click() },
            { name: 'copy', config: state.settings.copyShortcut, action: () => copyToClipboard() },
            { name: 'cut', config: state.settings.cutShortcut, action: () => { copyToClipboard(); deleteSelection(); } },
            { name: 'delete', config: state.settings.deleteShortcut, action: () => deleteSelection() },
            { name: 'undo', config: state.settings.undoShortcut, action: () => undo() },
            { name: 'redo', config: state.settings.redoShortcut, action: () => redo() }
        ];
        
        for (const shortcut of shortcuts) {
            const matches = utils.checkShortcut(e, shortcut.config);
            
            if (matches) {
                e.preventDefault();
                shortcut.action();
                shortcutHandled = true;
                break;
            }
        }
        if (utils.checkShortcut(e, state.settings.selectAllShortcut)) {
            e.preventDefault();
            const now = Date.now();
            if (now - lastAPressTime < 300) {
                // 双击Ctrl+A：选择当前层级的所有节点和组
                getCurrentLevelNodes().forEach(n => n.isSelected = true);
                getCurrentLevelGroups().forEach(g => g.isSelected = true);
                lastAPressTime = 0;
            } else {
                // 单击Ctrl+A：选择当前层级的所有节点
                getCurrentLevelNodes().forEach(n => n.isSelected = true);
                getCurrentLevelGroups().forEach(g => g.isSelected = false);
            }
            lastAPressTime = now;
            handleSelectionChangeWithHistory('全选');
            shortcutHandled = true;
        }
        if (utils.checkShortcut(e, state.settings.createGroupShortcut)) {
            e.preventDefault();
            const selectedNodesForGroup = getSelectedNodes();
            if (selectedNodesForGroup.length > 0) {
                createGroup(selectedNodesForGroup);
            }
            shortcutHandled = true;
        }
        if (utils.checkShortcut(e, state.settings.convertNodeSetShortcut)) {
            e.preventDefault();
            const selectedNodes = getSelectedNodes();
            if (selectedNodes.length > 0) {
                if (selectedNodes.length > 1) {
                    // 创建一个新的节点集，包含所有选中的节点
                    const centerX = selectedNodes.reduce((sum, n) => sum + n.x, 0) / selectedNodes.length;
                    const centerY = selectedNodes.reduce((sum, n) => sum + n.y, 0) / selectedNodes.length;
                    const newNodeSet = createNode(centerX, centerY, "新节点集", 'node');
                    convertNodeToNodeSet(newNodeSet.id);
                    
                    // 将选中的节点移动到新节点集内
                    selectedNodes.forEach(node => {
                        node.parentNodeSetId = newNodeSet.id;
                        node.isSelected = false;
                        newNodeSet.nodeSetData.childNodes.push(node.id);
                    });
                    
                    newNodeSet.isSelected = true;
                    saveState(`创建节点集并包含${selectedNodes.length}个节点`);
                } else if (selectedNodes.length === 1 && !selectedNodes[0].isNodeSet) {
                    // 如果只选中一个普通节点，将其转节点集
                    convertNodeToNodeSet(selectedNodes[0].id);
                }
                setStateDirty();
            }
            shortcutHandled = true;
        }
        if (utils.checkShortcut(e, state.settings.enterNodeSetShortcut)) {
            e.preventDefault();
            const selectedNodes = getSelectedNodes();
            if (selectedNodes.length === 1 && selectedNodes[0].isNodeSet) {
                enterNodeSet(selectedNodes[0].id);
            }
            shortcutHandled = true;
        }

        if (utils.checkShortcut(e, state.settings.alignLeftShortcut)) {
            e.preventDefault();
            alignSelectedNodes('left');
            shortcutHandled = true;
        }
        if (utils.checkShortcut(e, state.settings.alignRightShortcut)) {
            e.preventDefault();
            alignSelectedNodes('right');
            shortcutHandled = true;
        }
        if (utils.checkShortcut(e, state.settings.alignTopShortcut)) {
            e.preventDefault();
            alignSelectedNodes('top');
            shortcutHandled = true;
        }
        if (utils.checkShortcut(e, state.settings.alignBottomShortcut)) {
            e.preventDefault();
            alignSelectedNodes('bottom');
            shortcutHandled = true;
        }
        if (utils.checkShortcut(e, state.settings.snapShortcut)) {
            dom.snapToggleBtn.click();
            shortcutHandled = true;
        }
        if (utils.checkShortcut(e, state.settings.magneticShortcut)) {
            dom.magneticToggleBtn.click();
            shortcutHandled = true;
        }
        if (utils.checkShortcut(e, state.settings.collisionShortcut)) {
            dom.collisionToggleBtn.click();
            shortcutHandled = true;
        }
        if (utils.checkShortcut(e, state.settings.pushShortcut)) {
            dom.pushToggleBtn.click();
            shortcutHandled = true;
        }
        if (utils.checkShortcut(e, state.settings.insertShortcut)) {
            dom.insertToggleBtn.click();
            shortcutHandled = true;
        }
        if (utils.checkShortcut(e, state.settings.focusShortcut)) {
            focusOnSelection();
            shortcutHandled = true;
        }
        
        if (shortcutHandled) {
            e.preventDefault();
            return;
        }
    }
    
    // 直接导入内容函数（不弹窗）
    function processImportContent(text) {
        // 移除可能存在的旧进度弹窗
        const existingProgress = document.getElementById('md-import-progress');
        if (existingProgress && existingProgress.parentNode) {
            existingProgress.parentNode.removeChild(existingProgress);
        }
        
        // 显示导入进度提示
        const progressMessage = document.createElement('div');
        progressMessage.id = 'md-import-progress';
        progressMessage.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 10000;
            text-align: center;
        `;
        progressMessage.innerHTML = '正在导入内容...<br><small>请稍候</small>';
        document.body.appendChild(progressMessage);
        
        // 安全移除进度弹窗的函数
        const removeProgressMessage = () => {
            try {
                const element = document.getElementById('md-import-progress');
                if (element && element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            } catch (e) {
                // 移除进度弹窗出错
            }
        };
        
        // 使用 setTimeout 让进度提示先显示
        setTimeout(() => {
            try {
                // 解析文本内容（支持Markdown和JSON）
                const parsedItems = parseMarkdownText(text);
                
                // 检查解析结果
                if (!parsedItems || parsedItems.length === 0) {
                    throw new Error('无法解析内容或内容为空');
                }
                
                // 计算智能导入位置
                const importPosition = calculateSmartImportPosition();
                
                // 生成节点
                const result = generateNodesFromMarkdown(parsedItems, importPosition);
                
                if (!result || !result.nodes || result.nodes.length === 0) {
                    throw new Error('生成节点失败');
                }
                
                // 清除所有现有节点和组的选中状态
                state.nodes.forEach(node => node.isSelected = false);
                state.groups.forEach(group => group.isSelected = false);
                
                // 合并导入：不清空画布，而是添加新内容
                const existingNodes = [...state.nodes];
                const existingGroups = [...state.groups];
                
                // 设置新导入节点为选中状态，便于后续聚焦
                result.nodes.forEach(node => node.isSelected = true);
                result.groups.forEach(group => group.isSelected = true);
                
                // 添加新生成的节点和组
                state.nodes = [...existingNodes, ...result.nodes];
                state.groups = [...existingGroups, ...result.groups];
                
                // 保存状态并重绘
                saveState('自动导入');
                updateCanvasCountInfo();
                updateCanvasSelectionInfo();
                setStateDirty();
                
                // 使用聚焦功能来自动调整视图到新导入的节点
                 // 延迟执行聚焦，确保状态更新完成
                 setTimeout(() => {
                     focusOnSelection();
                     // 自动聚焦完成
                 }, 100);
                
                // 自动导入完成
                
                // 显示成功提示
                progressMessage.innerHTML = '✓ 导入成功！<br><small>共生成 ' + result.nodes.length + ' 个节点</small>';
                progressMessage.style.background = 'rgba(0, 128, 0, 0.8)';
                
                // 2秒后移除提示
                setTimeout(removeProgressMessage, 2000);
                
            } catch (error) {
                // 自动导入失败
                
                // 显示错误提示
                progressMessage.innerHTML = '✗ 导入失败<br><small>' + (error.message || '未知错误') + '</small>';
                progressMessage.style.background = 'rgba(128, 0, 0, 0.8)';
                
                // 3秒后移除提示
                setTimeout(removeProgressMessage, 3000);
            }
        }, 50);
    }
    
    // 执行普通粘贴函数
    function executeNormalPaste(event, text) {
        // 检查当前焦点元素
        const activeElement = document.activeElement;
        
        // 如果焦点在输入框，让浏览器处理默认粘贴
        if (activeElement && (
            activeElement.tagName === 'INPUT' || 
            activeElement.tagName === 'TEXTAREA' || 
            activeElement.contentEditable === 'true'
        )) {
            // 创建一个新的粘贴事件，让输入框正常处理
            const newEvent = new ClipboardEvent('paste', {
                clipboardData: new DataTransfer()
            });
            newEvent.clipboardData.setData('text/plain', text);
            activeElement.dispatchEvent(newEvent);
            return;
        }
        
        // 如果在画布上，创建文本节点
        const pastePos = utils.screenToWorld(lastMousePos.x, lastMousePos.y);
        pasteFromClipboard(pastePos, text);
    }

    function handlePaste(e) {
        if (document.activeElement === dom.textEditor || 
            document.activeElement === dom.canvasNameInput || 
            document.activeElement === dom.searchBox ||
            document.activeElement.classList.contains('shortcut-main-input')) {
            return;
        }
        e.preventDefault();

        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (item.kind === 'file' && item.type.startsWith('image/')) {
                const file = item.getAsFile();
                const reader = new FileReader();
                
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const pastePos = utils.screenToWorld(lastMousePos.x, lastMousePos.y);
                        getCurrentLevelNodes().forEach(n => n.isSelected = false);
                        getCurrentLevelGroups().forEach(g => g.isSelected = false);
                        const node = createNode(pastePos.x, pastePos.y, "图片", 'imageNode', event.target.result);
                        node.width = utils.snap(Math.max(100, img.width));
                        node.imageAspectRatio = img.width / img.height;
                        const pureImageHeight = (node.width - 20) / node.imageAspectRatio;
                        node.height = utils.snap(pureImageHeight + 40);
                        node.isSelected = true;
                    };
                    img.src = event.target.result;
                };
                
                reader.readAsDataURL(file);
                return; 
            }
        }

        const text = e.clipboardData.getData('text/plain');
        if (text) {
            // 检测是否为可导入内容（Markdown或JSON格式）
            if (isImportableContent(text)) {
                // 阻止默认粘贴行为
                e.preventDefault();
                
                // 使用统一的Markdown导入确认对话框
                const pastePos = utils.screenToWorld(lastMousePos.x, lastMousePos.y);
                showUnifiedMarkdownImportConfirmation(text, {
                    type: 'paste',
                    position: pastePos
                }).then(choice => {
                    handleUnifiedMarkdownImportChoice(text, choice, {
                        type: 'paste',
                        position: pastePos
                    });
                });
                return;
            }
            
            // 普通文本粘贴
            const pastePos = utils.screenToWorld(lastMousePos.x, lastMousePos.y);
            pasteFromClipboard(pastePos, text);
        }
    }

    function handleDrop(e) {
        e.preventDefault();
        const dropPos = utils.screenToWorld(e.clientX, e.clientY);
        
        const file = e.dataTransfer.files[0];
        
        if (file) {
            if (file.type === 'application/json' || file.name.endsWith('.json')) {
                // 检查JSON文件是否包含Markdown格式内容
                const reader = new FileReader();
                reader.onload = (event) => {
                    const jsonContent = event.target.result;
                    
                    // 先检查是否明显是Markdown内容，避免不必要的JSON解析错误日志
                    if (isImportableContent(jsonContent)) {
                        // 检测到Markdown内容
                        showUnifiedMarkdownImportConfirmation(jsonContent, {
                            type: 'drop',
                            position: dropPos
                        }).then(choice => {
                            handleUnifiedMarkdownImportChoice(jsonContent, choice, {
                                type: 'drop',
                                position: dropPos
                            });
                        });
                        return;
                    }
                    
                    try {
                        const jsonData = JSON.parse(jsonContent);
                        
                        // 检查JSON是否包含Markdown格式的层级结构
                        if (isHierarchicalJSON(jsonData)) {
                            // 检测到层级结构JSON文件
                            
                            // 使用统一的Markdown导入确认对话框
                            showUnifiedMarkdownImportConfirmation(jsonContent, {
                                type: 'drop',
                                position: dropPos,
                                isJsonFile: true,
                                jsonData: jsonData,
                                file: file
                            }).then(choice => {
                                if (choice === 'mindmap') {
                                    // 解析为Markdown导图
                                    try {
                                        const importPosition = calculateSmartImportPosition();
                                        const parsedItems = parseJsonStructure(jsonData);
                                        const result = generateNodesFromMarkdown(parsedItems, importPosition);
                                        
                                        if (result) {
                                            const existingNodes = [...state.nodes];
                                            const existingGroups = [...state.groups];
                                            
                                            state.nodes = [...existingNodes, ...result.nodes];
                                            state.groups = [...existingGroups, ...result.groups];
                                            
                                            saveState('JSON-MD导入');
                                            updateCanvasCountInfo();
                                            updateCanvasSelectionInfo();
                                            setStateDirty();
                                            
                                            // 成功导入节点
                                        } else {
                                            mergeFromFile(file, dropPos);
                                        }
                                    } catch (error) {
                                        // 导入失败
                                        mergeFromFile(file, dropPos);
                                    }
                                } else if (choice === 'text') {
                                    // 作为普通JSON导入
                                    mergeFromFile(file, dropPos);
                                }
                                // choice === 'cancel' 时不做任何操作
                            });
                            return;
                        }
                        
                        // 如果不是Markdown格式的JSON，使用原有的mergeFromFile方法
                        mergeFromFile(file, dropPos);
                    } catch (error) {
                        // JSON解析失败
                        alert('文件格式不正确！请拖拽有效的JSON文件。');
                    }
                };
                reader.readAsText(file);
                return;
            }

            if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const node = createNode(dropPos.x, dropPos.y, "图片", 'imageNode', event.target.result);
                        node.width = utils.snap(Math.max(100, img.width));
                        node.imageAspectRatio = img.width / img.height;
                        const pureImageHeight = (node.width - 20) / node.imageAspectRatio;
                        node.height = utils.snap(pureImageHeight + 40);
                        node.isSelected = true;
                        updateCanvasCountInfo();
                        updateCanvasSelectionInfo();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
                return;
            }
        }
        
        const text = e.dataTransfer.getData('text/plain');
        if (text && text.trim()) {
            // 检查拖入的文本是否为Markdown格式
            if (isImportableContent(text)) {
                // 检测到Markdown格式文本
                
                // 使用统一的Markdown导入确认对话框
                showUnifiedMarkdownImportConfirmation(text, {
                    type: 'drop',
                    position: dropPos
                }).then(choice => {
                    handleUnifiedMarkdownImportChoice(text, choice, {
                        type: 'drop',
                        position: dropPos
                    });
                });
                return;
            }
            
            // 如果不是Markdown格式，创建普通文本节点
            createNode(dropPos.x, dropPos.y, text.trim());
            updateCanvasCountInfo();
            updateCanvasSelectionInfo();
        }
    }

    // 移动端长按检测变量
    let enterKeyPressTime = 0;
    let enterKeyTimer = null;
    const LONG_PRESS_DURATION = 500; // 500ms为长按阈值

    function handleTextEditorKeyDown(e) {
        if (e.key === 'Enter') {
            // 检测是否为移动设备
            const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                                   ('ontouchstart' in window) || 
                                   (navigator.maxTouchPoints > 0);
            
            if (isMobileDevice && !e.shiftKey && !e.altKey) {
                // 移动端处理：短按回车换行
                if (enterKeyPressTime === 0) {
                    enterKeyPressTime = Date.now();
                    // 不阻止默认行为，允许换行
                    setTimeout(() => {
                        // 更新节点文本
                        if (state.editingItem && (state.editingItem.type === 'node' || state.editingItem.type === 'imageNode')) {
                            state.editingItem.text = dom.textEditor.value;
                            updateNodeDimensionsSmart(state.editingItem);
                            setStateDirty();
                        }
                    }, 0);
                }
            } else if (!e.altKey && !e.shiftKey) {
                // 桌面端：普通回车结束编辑
                e.preventDefault();
                stopEditing();
            } else if (e.shiftKey) {
                // Shift+Enter换行（桌面端和移动端通用）
                setTimeout(() => {
                    if (state.editingItem && (state.editingItem.type === 'node' || state.editingItem.type === 'imageNode')) {
                        state.editingItem.text = dom.textEditor.value;
                        updateNodeDimensionsSmart(state.editingItem);
                        setStateDirty();
                    }
                }, 0);
            }
        } else if (e.key === 'Escape') {
            // 文本编辑器ESC键停止编辑
            stopEditing();
        }
    }

    // 添加keyup事件处理，重置按键状态
    function handleTextEditorKeyUp(e) {
        if (e.key === 'Enter' && enterKeyPressTime > 0) {
            // 重置状态
            enterKeyPressTime = 0;
        }
    }
    
    function handleDocumentClick(e) {
        const isOutsideContext = !e.target.closest('.context-menu');
        const isOutsideDropdown = !e.target.closest('.dropdown-container');
        const isOutsideThemeDropdown = !e.target.closest('#theme-dropdown') && !e.target.closest('#theme-switcher-btn');

        if (isOutsideContext) {
            hideAllContextMenus();
            // 移动端：同时隐藏所有子菜单
            if (isMobile()) {
                document.querySelectorAll('.context-menu .submenu').forEach(submenu => {
                    submenu.style.display = 'none';
                });
            }
        }
        if (isOutsideDropdown) {
             // 检查主题下拉菜单是否打开
             const wasThemeDropdownOpen = dom.themeDropdown.classList.contains('show');
             if (isOutsideThemeDropdown) {
                 dom.themeDropdown.classList.remove('show');
             }
             
             // 如果主题菜单刚刚关闭，检查是否有高亮的主题需要应用
             if (wasThemeDropdownOpen && isOutsideThemeDropdown) {
                 if (highlightedThemeIndex !== -1) {
                     // 有高亮的主题，应用它并记录历史
                     const themeObjects = themes.filter(t => t.colors);
                     const selectedTheme = themeObjects[highlightedThemeIndex];
                     if (selectedTheme) {
                         applyTheme(selectedTheme, true); // true to set it permanently and record history
                     }
                     // 重置高亮索引
                     removeThemeHighlight();
                     highlightedThemeIndex = -1;
                 } else if (activeTheme) {
                     // 没有高亮主题，恢复原主题（不记录历史，因为只是恢复预览）
                     applyTheme(activeTheme, false, true); // skipHistory = true
                 }
             }
        }
    }
    
    function hideAllContextMenus() {
        document.querySelectorAll('.context-menu').forEach(menu => menu.style.display = 'none');
    }
    
    // 触摸手势专用的右键菜单显示函数
    function showTouchContextMenu(x, y, targetItem) {
        state.interaction.contextMenuPos = { x: x, y: y };
        
        if (targetItem) {
            if (targetItem.type === 'node') {
                showContextMenu(dom.nodeContextMenu, x, y);
            } else if (targetItem.type === 'group') {
                showContextMenu(dom.groupContextMenu, x, y);
            }
        } else {
            showContextMenu(dom.canvasContextMenu, x, y);
        }
    }
    
    // 检测是否为移动端设备
    function isMobile() {
        return window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
    
    // 检测是否为平板设备
    function isTablet() {
        return window.innerWidth > 768 && window.innerWidth <= 1366;
    }
    
    // 调整子菜单位置以防止被截断
    function adjustSubmenuPosition(submenu, parentItem) {
        if (!submenu || !parentItem) return;
        
        // 先显示子菜单以获取其真实尺寸
        const originalDisplay = submenu.style.display;
        submenu.style.display = 'block';
        submenu.style.visibility = 'hidden';
        
        const submenuRect = submenu.getBoundingClientRect();
        const parentRect = parentItem.getBoundingClientRect();
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        // 恢复显示状态
        submenu.style.display = originalDisplay;
        submenu.style.visibility = 'visible';
        
        // 重置位置
        submenu.style.left = '';
        submenu.style.right = '';
        submenu.style.top = '';
        submenu.style.bottom = '';
        submenu.style.position = '';
        
        if (isMobile() || isTablet()) {
            // 移动端和平板端：使用固定定位，避免被父容器截断
            submenu.style.position = 'fixed';
            
            const safeMargin = 20; // 安全边距
            const rightSpace = windowWidth - parentRect.right - safeMargin;
            const leftSpace = parentRect.left - safeMargin;
            
            // 水平位置调整
            if (rightSpace >= submenuRect.width) {
                // 显示在右侧
                submenu.style.left = parentRect.right + 'px';
            } else if (leftSpace >= submenuRect.width) {
                // 显示在左侧
                submenu.style.left = (parentRect.left - submenuRect.width) + 'px';
            } else {
                // 空间都不够，显示在屏幕中央，但保持合理的宽度
                submenu.style.left = safeMargin + 'px';
                // 不强制设置宽度，让CSS控制子菜单宽度
                submenu.style.maxWidth = (windowWidth - 2 * safeMargin) + 'px';
            }
            
            // 垂直位置调整
            const bottomSpace = windowHeight - parentRect.top - safeMargin;
            const topSpace = parentRect.bottom - safeMargin;
            
            if (bottomSpace >= submenuRect.height) {
                // 从父项顶部开始显示
                submenu.style.top = parentRect.top + 'px';
            } else if (topSpace >= submenuRect.height) {
                // 在父项上方显示
                submenu.style.top = (parentRect.bottom - submenuRect.height) + 'px';
            } else {
                // 垂直空间不够，调整高度并添加滚动
                submenu.style.top = safeMargin + 'px';
                submenu.style.maxHeight = (windowHeight - 2 * safeMargin) + 'px';
                submenu.style.overflowY = 'auto';
            }
        } else {
            // PC端：保持原有的相对定位逻辑
            submenu.style.position = 'absolute';
            
            const rightSpace = windowWidth - parentRect.right;
            const leftSpace = parentRect.left;
            
            if (rightSpace >= submenuRect.width || rightSpace >= leftSpace) {
                submenu.style.left = '100%';
                submenu.style.right = 'auto';
            } else {
                submenu.style.left = 'auto';
                submenu.style.right = '100%';
            }
            
            submenu.style.top = '0';
        }
    }
    
    function showContextMenu(menu, x, y) {
        hideAllContextMenus();
        
        // 先显示菜单以获取其尺寸
        menu.style.display = 'block';
        menu.style.left = x + 'px';
        menu.style.top = y + 'px';
        
        // 获取菜单尺寸和窗口尺寸
        const menuRect = menu.getBoundingClientRect();
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        // 移动端优化：考虑安全区域和更大的边距
        const isMobileDevice = isMobile();
        const safeMargin = isMobileDevice ? 20 : 10; // 移动端使用更大的安全边距
        const topSafeArea = isMobileDevice ? 60 : 10; // 考虑移动端顶部工具栏
        const bottomSafeArea = isMobileDevice ? 30 : 10; // 考虑移动端底部安全区域
        
        // 计算调整后的位置
        let adjustedX = x;
        let adjustedY = y;
        
        // 移动端智能定位：优先考虑菜单完全可见
        if (isMobile) {
            // 在移动端，如果菜单会超出屏幕，优先调整到屏幕中央区域
            const availableWidth = windowWidth - 2 * safeMargin;
            const availableHeight = windowHeight - topSafeArea - bottomSafeArea;
            
            // 水平定位优化
            if (menuRect.width > availableWidth) {
                // 菜单太宽，居中显示
                adjustedX = safeMargin;
            } else if (x + menuRect.width > windowWidth - safeMargin) {
                // 右边超出，尝试左对齐到触摸点
                adjustedX = x - menuRect.width;
                // 如果左对齐后还是超出左边界，则贴左边
                if (adjustedX < safeMargin) {
                    adjustedX = safeMargin;
                }
            } else if (x < safeMargin) {
                adjustedX = safeMargin;
            }
            
            // 垂直定位优化
            if (menuRect.height > availableHeight) {
                // 菜单太高，从顶部安全区域开始显示
                adjustedY = topSafeArea;
            } else if (y + menuRect.height > windowHeight - bottomSafeArea) {
                // 下边超出，尝试上对齐到触摸点
                adjustedY = y - menuRect.height;
                // 如果上对齐后还是超出上边界，则贴顶部
                if (adjustedY < topSafeArea) {
                    adjustedY = topSafeArea;
                }
            } else if (y < topSafeArea) {
                adjustedY = topSafeArea;
            }
        } else {
            // 桌面端保持原有逻辑
            // 检查右边缘
            if (x + menuRect.width > windowWidth) {
                adjustedX = windowWidth - menuRect.width - safeMargin;
            }
            
            // 检查下边缘
            if (y + menuRect.height > windowHeight) {
                adjustedY = windowHeight - menuRect.height - safeMargin;
            }
            
            // 检查上边缘
            if (adjustedY < safeMargin) {
                adjustedY = safeMargin;
            }
            
            // 检查左边缘
            if (adjustedX < safeMargin) {
                adjustedX = safeMargin;
            }
        }
        
        // 应用调整后的位置
        menu.style.left = adjustedX + 'px';
        menu.style.top = adjustedY + 'px';
    }
    
    function handleContextMenu(e) {
        e.preventDefault();
        if (state.editingItem) return;

        // 考虑高DPI屏幕，使用实际显示坐标
        const displayX = e.clientX;
        const displayY = e.clientY;
        state.interaction.contextMenuPos = { x: displayX, y: displayY };

        const worldPos = utils.screenToWorld(e.clientX, e.clientY);
        let hitNode = null;
        let hitGroup = null;
        
        const currentNodes = getCurrentLevelNodes();
        const currentGroups = getCurrentLevelGroups();
        
        for (let i = currentNodes.length - 1; i >= 0; i--) {
            if (utils.isPointInNode(worldPos.x, worldPos.y, currentNodes[i])) {
                hitNode = currentNodes[i];
                break;
            }
        }
        if (!hitNode) {
            for (let i = currentGroups.length - 1; i >= 0; i--) {
                const g = currentGroups[i];
                const TITLE_HEIGHT = state.settings.gridSize;
                const PADDING = state.settings.gridSize / 2;
                const groupBounds = {
                    x: g.x - PADDING,
                    y: g.y - PADDING - TITLE_HEIGHT,
                    width: g.width + 2 * PADDING,
                    height: g.height + 2 * PADDING + TITLE_HEIGHT
                };
                if (utils.checkOverlap({ x: worldPos.x, y: worldPos.y, width: 1, height: 1 }, groupBounds)) {
                    hitGroup = g;
                    break;
                }
            }
        }
        
        if (hitNode) {
            if (!hitNode.isSelected) {
                getCurrentLevelNodes().forEach(n => n.isSelected = false);
                getCurrentLevelGroups().forEach(g => g.isSelected = false);
                hitNode.isSelected = true;
                handleSelectionChangeWithHistory('选择节点');
            }
            const singleNodeSelected = getSelectedNodes().length === 1;
            dom.addImageItem.style.display = singleNodeSelected ? 'block' : 'none';
            dom.changeImageItem.style.display = singleNodeSelected && hitNode.type === 'imageNode' ? 'block' : 'none';
            
            // 节点集相关菜单项的显示/隐藏逻辑
            const convertToNodeSetItem = document.getElementById('convert-to-nodeset-item');
            const enterNodeSetItem = document.getElementById('enter-nodeset-item');
            const convertToNodeItem = document.getElementById('convert-to-node-item');
            
            if (singleNodeSelected) {
                if (hitNode.isNodeSet) {
                    // 如果是节点集，显示"进入节点集"和"转普通节点"，隐藏"转节点集"
                    convertToNodeSetItem.style.display = 'none';
                    enterNodeSetItem.style.display = 'block';
                    convertToNodeItem.style.display = 'block';
                } else {
                    // 如果是普通节点，显示"转节点集"，隐藏其他
                    convertToNodeSetItem.style.display = 'block';
                    enterNodeSetItem.style.display = 'none';
                    convertToNodeItem.style.display = 'none';
                }
            } else {
                // 多选或无选择时，隐藏所有节点集相关选项
                convertToNodeSetItem.style.display = 'none';
                enterNodeSetItem.style.display = 'none';
                convertToNodeItem.style.display = 'none';
            }
            
            // 拆分换行和合并换行菜单项的显示逻辑
            const selectedNodes = getSelectedNodes();
            const hasImageNode = selectedNodes.some(node => node.type === 'imageNode');
            
            // 拆分换行：仅在选中单个文本节点且包含换行符时显示
            if (selectedNodes.length === 1 && !hasImageNode && selectedNodes[0].text.includes('\n')) {
                dom.splitLinesItem.style.display = 'block';
            } else {
                dom.splitLinesItem.style.display = 'none';
            }
            
            // 合并换行：仅在选中多个文本节点时显示
            if (selectedNodes.length > 1 && !hasImageNode) {
                dom.mergeLinesItem.style.display = 'block';
            } else {
                dom.mergeLinesItem.style.display = 'none';
            }

            showContextMenu(dom.nodeContextMenu, displayX, displayY);
        } else if (hitGroup) {
            if (!hitGroup.isSelected) {
                getCurrentLevelNodes().forEach(n => n.isSelected = false);
                getCurrentLevelGroups().forEach(g => g.isSelected = false);
                hitGroup.isSelected = true;
                handleSelectionChangeWithHistory('选择组');
            }
            showContextMenu(dom.groupContextMenu, displayX, displayY);
        } else {
            showContextMenu(dom.canvasContextMenu, displayX, displayY);
        }
    }
    
    function setTextAlignment(alignment) {
        const selectedNodes = getSelectedNodes();
        if (selectedNodes.length === 0) {
            showPermissionError("请先选择要设置文字对齐的节点");
            return;
        }
        
        selectedNodes.forEach(node => {
            // 只对文本节点设置文字对齐
            if (node.type !== 'imageNode') {
                node.textAlign = alignment;
            }
        });
        
        saveState(`设置文字${alignment === 'left' ? '左' : alignment === 'right' ? '右' : '居中'}对齐`);
        setStateDirty();
    }
    
    async function handleContextMenuItemClick(action) {
        const selectedNodes = getSelectedNodes();
        const selectedGroups = getSelectedGroups();
        
        switch(action) {
            case 'resize-group-to-fit':
                // 调整选中组的大小以匹配包含的节点
                const levelNodes = getCurrentLevelNodes();
                selectedGroups.forEach(group => {
                    // 获取组内所有节点
                    const groupNodes = levelNodes.filter(n => n.groupId === group.id);
                    if (groupNodes.length > 0) {
                        // 计算组内节点的边界
                        const xCoords = groupNodes.map(n => n.x);
                        const yCoords = groupNodes.map(n => n.y);
                        const rightCoords = groupNodes.map(n => n.x + n.width);
                        const bottomCoords = groupNodes.map(n => n.y + n.height);
                        
                        // 重新设置组的位置和大小
                        group.x = Math.min(...xCoords);
                        group.y = Math.min(...yCoords);
                        group.width = Math.max(...rightCoords) - Math.min(...xCoords);
                        group.height = Math.max(...bottomCoords) - Math.min(...yCoords);
                    }
                });
                saveState('调整组框大小');
                break;
            case 'copy': copyToClipboard(); break;
            case 'cut': copyToClipboard(); deleteSelection(); break;
            case 'copy-style': copyStyle(); break;
            case 'paste-style': pasteStyle(); break;
            case 'clear-selected-style':
                if (activeTheme) {
                    const themeColors = activeTheme.colors;
                    selectedNodes.forEach(node => {
                        node.hasCustomStyle = false;
                        if (!node.isStatusBlock) {
                            node.backgroundColor = themeColors.nodeBg;
                            node.color = themeColors.nodeText;
                        }
                    });
                    selectedGroups.forEach(group => {
                        group.hasCustomStyle = false;
                        group.color = themeColors.group;
                    });
                    saveState('清除选中样式');
                }
                break;
            case 'clear-all-styles':
                if (activeTheme) {
                    const themeColors = activeTheme.colors;
                    state.nodes.forEach(node => {
                        node.hasCustomStyle = false;
                        if (!node.isStatusBlock) {
                            node.backgroundColor = themeColors.nodeBg;
                            node.color = themeColors.nodeText;
                        }
                    });
                    state.groups.forEach(group => {
                        group.hasCustomStyle = false;
                        group.color = themeColors.group;
                    });
                    saveState('清除所有样式');
                }
                break;
            case 'clean-orphaned-nodes':
                // 清理孤立节点 - 实现迭代清理，确保一次操作清理所有孤立节点
                if (!state.nodes || !Array.isArray(state.nodes)) {
                    showCustomAlert('节点数据无效');
                    break;
                }
                
                // 复制原始数据，确保在用户确认前不修改实际状态
                const originalNodes = [...state.nodes];
                const originalConnections = state.connections && Array.isArray(state.connections) ? [...state.connections] : [];
                
                // 用于计算最终要删除的孤立节点
                let tempNodes = [...originalNodes];
                let tempConnections = [...originalConnections];
                
                // 迭代清理过程，直到没有更多孤立节点被删除
                let hasDeletedNodes;
                do {
                    hasDeletedNodes = false;
                    
                    // 构建节点ID映射，优化查找性能
                    const nodeIdMap = new Map(tempNodes.map(node => [node.id, node]));
                    
                    // 在当前节点集合中重新计算引用关系
                    const referencedNodeSetIds = new Set();
                    tempNodes.forEach(node => {
                        if (node.parentNodeSetId) {
                            referencedNodeSetIds.add(node.parentNodeSetId);
                        }
                    });
                    
                    // 找出当前轮次的孤立节点
                    const orphanNodesInThisRound = [];
                    
                    for (const node of tempNodes) {
                        // 跳过状态块节点
                        if (node.isStatusBlock) continue;
                        
                        let isOrphan = false;
                        
                        // 类型1：有parentNodeSetId但父节点集不存在的节点
                        if (node.parentNodeSetId) {
                            const parentNode = nodeIdMap.get(node.parentNodeSetId);
                            if (!parentNode || !parentNode.isNodeSet) {
                                isOrphan = true;
                            }
                        }
                        
                        // 类型2：作为节点集但没有任何子节点引用的孤立节点集
                        if (!isOrphan && node.isNodeSet && !referencedNodeSetIds.has(node.id)) {
                            isOrphan = true;
                        }
                        
                        if (isOrphan) {
                            orphanNodesInThisRound.push(node);
                        }
                    }
                    
                    // 如果本轮找到了孤立节点，则删除它们
                    if (orphanNodesInThisRound.length > 0) {
                        hasDeletedNodes = true;
                        
                        // 获取本轮要删除的节点ID列表
                        const orphanNodeIds = new Set(orphanNodesInThisRound.map(node => node.id));
                        
                        // 从临时节点数组中移除孤立节点
                        tempNodes = tempNodes.filter(node => !orphanNodeIds.has(node.id));
                        
                        // 清除可能引用这些节点的连接
                        tempConnections = tempConnections.filter(conn => 
                            !orphanNodeIds.has(conn.sourceNodeId) && 
                            !orphanNodeIds.has(conn.targetNodeId)
                        );
                    }
                } while (hasDeletedNodes);
                
                // 重新计算孤立节点数量 - 采用直接识别方式确保准确性
                const nodeIdMap = new Map(originalNodes.map(node => [node.id, node]));
                const referencedNodeSetIdsFinal = new Set();
                originalNodes.forEach(node => {
                    if (node.parentNodeSetId) {
                        referencedNodeSetIdsFinal.add(node.parentNodeSetId);
                    }
                });
                
                // 直接识别所有孤立节点，用于计数
                const allOrphanNodes = originalNodes.filter(node => {
                    // 跳过状态块节点
                    if (node.isStatusBlock) return false;
                    
                    // 类型1：有parentNodeSetId但父节点集不存在的节点
                    if (node.parentNodeSetId) {
                        const parentNode = nodeIdMap.get(node.parentNodeSetId);
                        if (!parentNode || !parentNode.isNodeSet) {
                            return true;
                        }
                    }
                    
                    // 类型2：作为节点集但没有任何子节点引用的孤立节点集
                    if (node.isNodeSet && !referencedNodeSetIdsFinal.has(node.id)) {
                        return true;
                    }
                    
                    return false;
                });
                
                // 计算直接识别的孤立节点数量
                const directOrphanCount = allOrphanNodes.length;
                
                // 如果有节点被识别为孤立节点，使用自定义确认对话框
                if (directOrphanCount > 0) {
                    // 创建并显示自定义确认对话框
                    showCustomConfirmDialog(
                        '清理孤立节点', 
                        `发现 ${directOrphanCount} 个孤立节点，确定要清理它们吗？`,
                        () => {
                            // 执行实际的清理操作（使用之前计算好的结果）
                            state.nodes = [...tempNodes];
                            state.connections = [...tempConnections];
                            
                            // 更新画布信息
                            updateCanvasCountInfo();
                            
                            // 保存状态
                            saveState(`清理 ${directOrphanCount} 个孤立节点`);
                        },
                        () => {
                            // 用户取消后的回调 - 不执行任何操作，保留原始状态
                        }
                    );
                } else {
                    // 使用自定义提示对话框
                    showCustomAlert('没有发现孤立节点');
                }
                break;
            case 'sort-alpha': sortAndArrangeNodes('alpha'); break;
            case 'sort-size': sortAndArrangeNodes('size'); break;
            case 'sort-id': sortAndArrangeNodes('id'); break;
            case 'align-left': alignSelectedNodes('left'); break;
            case 'align-right': alignSelectedNodes('right'); break;
            case 'align-top': alignSelectedNodes('top'); break;
            case 'align-bottom': alignSelectedNodes('bottom'); break;
            case 'text-align-left': setTextAlignment('left'); break;
            case 'text-align-center': setTextAlignment('center'); break;
            case 'text-align-right': setTextAlignment('right'); break;
            case 'group': 
                // 右键菜单组点击
                // 选中节点计数
                // 选中节点信息
                // 当前层级节点数
                // 所有选中的节点
                if (selectedNodes.length > 0) {
                    // 创建组操作
                    const result = createGroup(selectedNodes);
                    // 创建组结果
                } else {
                    // 未选中节点，无法创建组
                }
                break;
            case 'convert-to-nodeset':
                if (selectedNodes.length === 1) {
                    convertNodeToNodeSet(selectedNodes[0].id);
                }
                break;
            case 'enter-nodeset':
                if (selectedNodes.length === 1 && selectedNodes[0].isNodeSet) {
                    enterNodeSet(selectedNodes[0].id);
                }
                break;
            case 'convert-to-node':
                if (selectedNodes.length === 1 && selectedNodes[0].isNodeSet) {
                    convertNodeSetToNode(selectedNodes[0].id);
                }
                break;
            case 'delete-node': deleteSelection(); break;
            case 'delete-image':
                selectedNodes.forEach(n => {
                    if (n.type === 'imageNode') {
                        n.imageData = null;
                        n.type = 'node';
                    }
                });
                saveState('删除图片');
                break;
            case 'add-image':
            case 'change-image':
                if(selectedNodes.length === 1) openImageSelector(selectedNodes[0]);
                break;
            case 'split-lines':
                splitNodeByLines();
                break;
            case 'merge-lines':
                mergeNodesByLines();
                break;
            case 'export-markdown':
                exportToMarkdown();
                break;
            case 'reset-node-size':
                resetSelectedNodesSize();
                break;
            case 'delete-group':
                const currentLevelNodes = getCurrentLevelNodes();
                selectedGroups.forEach(group => {
                    group.nodeIds.forEach(id => {
                        const node = currentLevelNodes.find(n => n.id === id);
                        if(node) node.groupId = null;
                    });
                });
                state.groups = state.groups.filter(g => !g.isSelected);
                saveState('解散组');
                break;
            case 'delete-group-nodes':
                const nodesToRemove = new Set();
                selectedGroups.forEach(g => g.nodeIds.forEach(id => nodesToRemove.add(id)));
                state.nodes = state.nodes.filter(n => !nodesToRemove.has(n.id));
                state.groups = state.groups.filter(g => !g.isSelected);
                saveState('删除组和节点');
                break;
            
            // 状态块功能
            case 'add-status-block':
            case 'add-status-block-top':
            case 'add-status-block-bottom':
            case 'add-status-block-left':
            case 'add-status-block-right':
                if (selectedNodes.length > 0) {
                    const direction = action.replace('add-status-block-', '') || 'top';
                    selectedNodes.forEach(node => {
                        addStatusBlock(node, direction);
                    });
                }
                break;
            case 'remove-status-block':
                if (selectedNodes.length > 0) {
                    selectedNodes.forEach(node => {
                        removeStatusBlock(node);
                    });
                }
                break;
            case 'copy-status':
                if (selectedNodes.length > 0) {
                    const firstNode = selectedNodes[0];
                    const statusBlocks = state.nodes.filter(n => 
                        n.isStatusBlock && n.targetNodeId === firstNode.id
                    );
                    if (statusBlocks.length > 0) {
                        // 使用serializeNode函数优化状态块数据存储
                        const statusData = statusBlocks.map(block => {
                            // 使用序列化函数处理状态块数据
                            const serializedBlock = serializeNode(block);
                            // 确保只保留状态块必要的属性
                            return {
                                direction: serializedBlock.position,
                                statusIndex: serializedBlock.statusIndex,
                                backgroundColor: serializedBlock.backgroundColor,
                                text: serializedBlock.text,
                                color: serializedBlock.color
                            };
                        });
                        await dbStorage.save('copiedStatusBlocks', statusData, dbStorage.storeNames.copiedStatusBlocks);
                    }
                }
                break;
            case 'paste-status':
                if (selectedNodes.length > 0) {
                    try {
                        // 使用IndexedDB加载状态块数据
                        const statusData = await dbStorage.load('copiedStatusBlocks', dbStorage.storeNames.copiedStatusBlocks);
                        if (statusData) {
                            selectedNodes.forEach(node => {
                                // 先移除现有状态块
                                const existingStatusBlocks = state.nodes.filter(n => 
                                    n.isStatusBlock && n.targetNodeId === node.id
                                );
                                existingStatusBlocks.forEach(block => {
                                    removeStatusBlock(block);
                                });
                                
                                // 然后添加新的状态块
                                statusData.forEach(data => {
                                    // 准备状态块基础数据
                                    const preparedBlockData = {
                                        // 位置将在下方计算
                                        text: data.text,
                                        backgroundColor: data.backgroundColor,
                                        color: data.color,
                                        statusIndex: data.statusIndex,
                                        position: data.direction,
                                        isStatusBlock: true,
                                        targetNodeId: node.id,
                                        textAlign: 'center',
                                        textVerticalAlign: 'middle',
                                        font: 'bold 10px sans-serif',
                                        hasCustomStyle: true
                                    };
                                    
                                    // 使用deserializeNode函数恢复完整的状态块结构
                                    const newBlock = deserializeNode(preparedBlockData);
                                    
                                    // 设置状态块位置
                                    switch (data.direction) {
                                        case 'top':
                                            newBlock.x = node.x;
                                            newBlock.y = node.y - state.settings.gridSize;
                                            newBlock.width = node.width;
                                            newBlock.height = state.settings.gridSize;
                                            break;
                                        case 'bottom':
                                            newBlock.x = node.x;
                                            newBlock.y = node.y + node.height;
                                            newBlock.width = node.width;
                                            newBlock.height = state.settings.gridSize;
                                            break;
                                        case 'left':
                                            newBlock.x = node.x - state.settings.gridSize;
                                            newBlock.y = node.y;
                                            newBlock.width = state.settings.gridSize;
                                            newBlock.height = node.height;
                                            break;
                                        case 'right':
                                            newBlock.x = node.x + node.width;
                                            newBlock.y = node.y;
                                            newBlock.width = state.settings.gridSize;
                                            newBlock.height = node.height;
                                            break;
                                    }
                                    
                                    // 添加到节点列表
                                    state.nodes.push(newBlock);
                                });
                            });
                            
                            saveState('粘贴状态块');
                            setStateDirty();
                            updateStatusBlocks();
                        }
                    } catch (error) {
                        // 粘贴状态失败
                    }
                }
                break;
            case 'paste':
                navigator.clipboard.readText().then(text => {
                    const pastePos = utils.screenToWorld(state.interaction.contextMenuPos.x, state.interaction.contextMenuPos.y);
                    
                    // 检测是否为可导入内容（Markdown或JSON格式）
                    if (isImportableContent(text)) {
                        // 使用统一的Markdown导入确认对话框
                        showUnifiedMarkdownImportConfirmation(text, {
                            type: 'paste',
                            position: pastePos
                        }).then(choice => {
                            handleUnifiedMarkdownImportChoice(text, choice, {
                                type: 'paste',
                                position: pastePos
                            });
                        });
                    } else {
                        // 普通文本粘贴
                        pasteFromClipboard(pastePos, text);
                    }
                });
                break;
            case 'import-markdown':
                // 显示Markdown导入模态框
                showMdConvertModal();
                break;
            case 'make-square':
                makeNodesSquare();
                break;
        }
        hideAllContextMenus();
        setStateDirty();
    }
    
    // 将选中的节点转换为近似正方形
    function makeNodesSquare() {
        const selectedNodes = getSelectedNodes();
        if (selectedNodes.length === 0) return;
        
        selectedNodes.forEach(node => {
            // 只处理文本节点
            if (node.type === 'imageNode') return;
            
            if (node.text && node.text.trim() !== '') {
                // 使用二分搜索找到使宽度和高度最接近的宽度值
                // 起始范围: 最小50px, 最大500px (可以根据实际需要调整)
                const minWidth = 50;
                const maxWidth = 500;
                const threshold = 10; // 阈值，当宽度和高度差小于这个值时停止搜索
                
                let bestWidth = node.width;
                let bestHeight = utils.getRequiredHeightForText(node.text, node.width);
                let bestDiff = Math.abs(bestWidth - bestHeight);
                
                // 二分搜索
                let low = minWidth;
                let high = maxWidth;
                
                for (let i = 0; i < 20; i++) { // 最多迭代20次
                    const mid = Math.floor((low + high) / 2);
                    const currentHeight = utils.getRequiredHeightForText(node.text, mid);
                    const currentDiff = Math.abs(mid - currentHeight);
                    
                    // 检查是否找到了更好的宽度
                    if (currentDiff < bestDiff) {
                        bestDiff = currentDiff;
                        bestWidth = mid;
                        bestHeight = currentHeight;
                    }
                    
                    // 根据当前宽度和高度的关系调整搜索范围
                    if (mid < currentHeight) {
                        low = mid + 1;
                    } else {
                        high = mid - 1;
                    }
                    
                    // 如果已经足够接近，提前退出
                    if (bestDiff < threshold) break;
                }
                
                // 应用找到的最佳宽度，并清除文本行缓存以强制重新计算
                node.width = utils.snap(bestWidth);
                node.height = utils.getRequiredHeightForText(node.text, node.width);
                node.manuallyAdjustedWidth = true;
                node.manuallyAdjustedHeight = true;
                node.textLines = null;
            }
        });
        
        saveState('转换为正方形节点');
        updateStatusBlocks(); // 立即更新状态块大小和位置
        setStateDirty();
    }
    
    function openImageSelector(node) {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'image/*';
        fileInput.onchange = e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = event => {
                    const img = new Image();
                    img.onload = () => {
                        node.imageData = event.target.result;
                        node.type = 'imageNode';
                        node.imageAspectRatio = img.width / img.height;
                        saveState('添加图片');
                        setStateDirty();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        };
        fileInput.click();
    }
    
    function resetSelectedNodesSize() {
        const selectedNodes = getSelectedNodes();
        if (selectedNodes.length === 0) return;
        
        selectedNodes.forEach(node => {
            if (node.type === 'imageNode') {
                // 对于图片节点，保持原有的图片比例逻辑
                if (node.imageAspectRatio) {
                    const baseSize = state.settings.gridSize * 4; // 基础尺寸
                    if (node.imageAspectRatio > 1) {
                        // 横向图片
                        node.width = utils.snap(baseSize);
                        node.height = utils.snap(baseSize / node.imageAspectRatio);
                    } else {
                        // 纵向图片
                        node.height = utils.snap(baseSize);
                        node.width = utils.snap(baseSize * node.imageAspectRatio);
                    }
                } else {
                    // 没有比例信息的图片，使用默认尺寸
                    node.width = utils.snap(state.settings.gridSize * 4);
                    node.height = utils.snap(state.settings.gridSize * 4);
                }
            } else {
                // 对于文本节点，根据文字内容计算最佳尺寸
                if (node.text && node.text.trim() !== '') {
                    // 使用新规则计算文字所需的宽度
                    const requiredWidth = utils.getTextRequiredWidth(node.text, node.font || 'bold 16px sans-serif');
                    
                    // 设置宽度，确保最小宽度为2个网格
                    node.width = Math.max(state.settings.gridSize * 2, requiredWidth);
                    
                    // 使用新规则计算高度：n行文字 = n+1个网格高度
                    const requiredHeight = utils.getRequiredHeightForText(node.text, node.width);
                    node.height = requiredHeight;
                } else {
                    // 空文本节点，使用默认最小尺寸（2个网格）
                    node.width = state.settings.gridSize * 2;
                    node.height = state.settings.gridSize * 2;
                }
            }
            
            // 重置手动调节标记
            node.manuallyAdjustedWidth = false;
            node.manuallyAdjustedHeight = false;
            
            // 清除文本行缓存，确保重置尺寸后重新计算换行
            node.textLines = null;
        });
        
        saveState('重置节点长宽');
        updateStatusBlocks(); // 立即更新状态块大小和位置
        setStateDirty();
    }
    
    // 拆分换行功能 - 根据\n字符拆分单个文本节点
    function splitNodeByLines() {
        const selectedNodes = getSelectedNodes();
        if (selectedNodes.length !== 1) return;
        
        const node = selectedNodes[0];
        
        // 检查是否为图片节点
        if (node.type === 'imageNode') {
            showToast('不支持图片节点的拆分操作');
            return;
        }
        
        // 检查是否包含换行符
        if (!node.text.includes('\n')) {
            showToast('节点文本中没有换行符');
            return;
        }
        
        // 按换行符拆分文本
        const lines = node.text.split('\n');
        if (lines.length <= 1) return;
        
        // 清除原节点的选中状态
        node.isSelected = false;
        
        // 创建新的节点
        const newNodes = [];
        let currentY = node.y; // 从原节点位置开始
        
        lines.forEach((line, index) => {
            if (line.trim() === '') return; // 跳过空行
            
            const newNode = createNode(
                node.x, 
                currentY, 
                line.trim(), 
                'node', 
                null, 
                node.parentNodeSetId,
                true // skipSaveState
            );
            
            // 保持原节点的样式
            newNode.backgroundColor = node.backgroundColor;
            newNode.color = node.color;
            newNode.font = node.font;
            newNode.hasCustomStyle = node.hasCustomStyle;
            newNode.width = node.width; // 保持相同宽度
            
            // 根据文本内容调整高度
            const requiredHeight = utils.getRequiredHeightForText(newNode.text, newNode.width);
            newNode.height = utils.snap(Math.max(state.settings.gridSize * 2, requiredHeight));
            
            newNode.isSelected = true;
            newNodes.push(newNode);
            
            // 下一个节点的Y坐标 = 当前节点Y坐标 + 当前节点高度（紧贴排列）
            currentY += newNode.height;
        });
        
        // 删除原节点
        const nodeIndex = state.nodes.findIndex(n => n.id === node.id);
        if (nodeIndex !== -1) {
            state.nodes.splice(nodeIndex, 1);
        }
        
        // 如果原节点在组中，需要更新组的节点列表
        if (node.groupId) {
            const group = state.groups.find(g => g.id === node.groupId);
            if (group) {
                // 移除原节点ID
                const nodeIdIndex = group.nodeIds.indexOf(node.id);
                if (nodeIdIndex !== -1) {
                    group.nodeIds.splice(nodeIdIndex, 1);
                }
                // 添加新节点ID
                newNodes.forEach(newNode => {
                    newNode.groupId = node.groupId;
                    group.nodeIds.push(newNode.id);
                });
            }
        }
        
        // 在拆分完成后保存状态
        saveState('拆分换行');
        setStateDirty();
    }
    
    // 合并换行功能 - 按位置排序合并多个文本节点
    function mergeNodesByLines() {
        const selectedNodes = getSelectedNodes();
        if (selectedNodes.length < 2) return;
        
        // 检查是否包含图片节点
        const hasImageNode = selectedNodes.some(node => node.type === 'imageNode');
        if (hasImageNode) {
            showToast('不支持图片节点的合并操作');
            return;
        }
        
        // 按位置排序：先按Y坐标（高低），再按X坐标（左右）
        const sortedNodes = [...selectedNodes].sort((a, b) => {
            if (Math.abs(a.y - b.y) < 10) { // 如果Y坐标相近（容差10像素），按X坐标排序
                return a.x - b.x;
            }
            return a.y - b.y;
        });
        
        // 合并文本，用换行符分隔
        const mergedText = sortedNodes.map(node => node.text.trim()).filter(text => text !== '').join('\n');
        
        // 计算合并后节点的位置（所有节点的中心位置）
        const centerX = sortedNodes.reduce((sum, node) => sum + node.x + node.width / 2, 0) / sortedNodes.length - sortedNodes[0].width / 2;
        const centerY = sortedNodes.reduce((sum, node) => sum + node.y + node.height / 2, 0) / sortedNodes.length - sortedNodes[0].height / 2;
        
        // 使用第一个节点的样式作为基础
        const baseNode = sortedNodes[0];
        
        // 创建合并后的节点
        const mergedNode = createNode(
            utils.snap(centerX),
            utils.snap(centerY),
            mergedText,
            'node',
            null,
            baseNode.parentNodeSetId
        );
        
        // 保持第一个节点的样式
        mergedNode.backgroundColor = baseNode.backgroundColor;
        mergedNode.color = baseNode.color;
        mergedNode.font = baseNode.font;
        mergedNode.hasCustomStyle = baseNode.hasCustomStyle;
        
        // 计算合适的宽度（取所有节点的最大宽度）
        const maxWidth = Math.max(...sortedNodes.map(node => node.width));
        mergedNode.width = utils.snap(maxWidth);
        
        // 根据合并后的文本内容调整高度
        const requiredHeight = utils.getRequiredHeightForText(mergedNode.text, mergedNode.width);
        mergedNode.height = utils.snap(Math.max(state.settings.gridSize * 2, requiredHeight));
        
        // 处理组关系
        const groupIds = [...new Set(sortedNodes.map(node => node.groupId).filter(id => id))];
        if (groupIds.length === 1) {
            // 如果所有节点都在同一个组中，将合并后的节点也加入该组
            mergedNode.groupId = groupIds[0];
            const group = state.groups.find(g => g.id === groupIds[0]);
            if (group) {
                // 移除原节点ID
                sortedNodes.forEach(node => {
                    const nodeIdIndex = group.nodeIds.indexOf(node.id);
                    if (nodeIdIndex !== -1) {
                        group.nodeIds.splice(nodeIdIndex, 1);
                    }
                });
                // 添加新节点ID
                group.nodeIds.push(mergedNode.id);
            }
        }
        
        // 删除原节点
        sortedNodes.forEach(node => {
            const nodeIndex = state.nodes.findIndex(n => n.id === node.id);
            if (nodeIndex !== -1) {
                state.nodes.splice(nodeIndex, 1);
            }
        });
        
        // 选中合并后的节点
        getCurrentLevelNodes().forEach(n => n.isSelected = false);
        mergedNode.isSelected = true;
        
        saveState('合并换行');
        setStateDirty();
    }
    
    // 导出脑图文本功能 - 根据节点横向位置判断缩进级别
    function exportToMarkdown() {
        const selectedNodes = getSelectedNodes();
        if (selectedNodes.length === 0) {
            showToast('请先选择要导出的节点');
            return;
        }
        
        // 检查是否包含图片节点
        const hasImageNode = selectedNodes.some(node => node.type === 'imageNode');
        if (hasImageNode) {
            showToast('不支持包含图片节点的文本导出');
            return;
        }
        
        // 按Y坐标排序节点（从上到下）
        const sortedNodes = [...selectedNodes].sort((a, b) => a.y - b.y);
        
        // 获取所有节点的X坐标，用于确定缩进级别
        const xCoordinates = [...new Set(sortedNodes.map(node => node.x))].sort((a, b) => a - b);
        
        // 生成文本内容
        let textContent = '';
        
        sortedNodes.forEach(node => {
            // 根据X坐标确定缩进级别（最左边的不缩进）
            const levelIndex = xCoordinates.indexOf(node.x);
            
            // 生成对应级别的制表符缩进
            const indentPrefix = '\t'.repeat(levelIndex);
            
            // 添加到文本内容
            textContent += `${indentPrefix}${node.text.trim()}\n`;
        });
        
        // 移除末尾多余的换行符
        textContent = textContent.trim();
        
        // 复制到剪贴板
        navigator.clipboard.writeText(textContent).then(() => {
            showToast(`已导出 ${selectedNodes.length} 个节点为文本格式并复制到剪贴板`, 'success');
        }).catch(err => {
            // 复制到剪贴板失败
            showToast('复制到剪贴板失败，请手动复制', 'error');
            
            // 如果复制失败，显示内容让用户手动复制
            const textarea = document.createElement('textarea');
            textarea.value = textContent;
            textarea.style.position = 'fixed';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            showToast('已通过备用方式复制到剪贴板', 'success');
        });
    }
    
    // 通用提示框函数
    function showToast(message, type = 'error', duration = 1500) {
        const toast = document.createElement('div');
        toast.className = 'custom-toast';
        toast.textContent = message;
        
        // 根据类型设置不同的颜色
        let backgroundColor;
        switch(type) {
            case 'success':
                backgroundColor = 'rgba(34, 197, 94, 0.9)'; // 绿色
                break;
            case 'warning':
                backgroundColor = 'rgba(245, 158, 11, 0.9)'; // 黄色
                break;
            case 'error':
            default:
                backgroundColor = 'rgba(239, 68, 68, 0.9)'; // 红色
                break;
        }
        
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${backgroundColor};
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(8px);
            animation: slideInRight 0.3s ease-out;
        `;
        
        document.body.appendChild(toast);
        
        // 指定时间后自动消失
        setTimeout(() => {
            toast.style.animation = 'slideOutRight 0.3s ease-in';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }, duration);
    }
    
    function showConfirmationModal(message, onConfirm) {
        dom.confirmModalMessage.textContent = message;
        dom.confirmModalBackdrop.style.display = 'flex';
        
        const okHandler = () => {
            onConfirm();
            cleanup();
        };

        const cancelHandler = () => {
            cleanup();
        };

        const cleanup = () => {
            dom.confirmModalBackdrop.style.display = 'none';
            dom.confirmOkBtn.removeEventListener('click', okHandler);
            dom.confirmCancelBtn.removeEventListener('click', cancelHandler);
        };
        
        dom.confirmOkBtn.addEventListener('click', okHandler);
        dom.confirmCancelBtn.addEventListener('click', cancelHandler);
    }
    
    // Markdown导入确认对话框
    function showMarkdownImportConfirmation(text, dropPos) {
        const message = "检测到Markdown格式内容，是否要解析为层级结构？\n选择\"确定\"将解析为节点，选择\"取消\"将作为普通文本导入。";
        
        dom.confirmModalMessage.textContent = message;
        dom.confirmModalBackdrop.style.display = 'flex';
        
        const okHandler = () => {
            // 用户选择解析为Markdown
            try {
                // 使用智能位置计算
                const importPosition = calculateSmartImportPosition();
                
                // 解析Markdown文本
                const parsedItems = parseMarkdownText(text);
                const result = generateNodesFromMarkdown(parsedItems, importPosition);
                
                if (result) {
                    // 合并导入：添加新内容到现有画布
                    const existingNodes = [...state.nodes];
                    const existingGroups = [...state.groups];
                    
                    state.nodes = [...existingNodes, ...result.nodes];
                    state.groups = [...existingGroups, ...result.groups];
                    
                    // 保存状态并重绘
                    saveState('拖入MD导入');
                    updateCanvasCountInfo();
                    updateCanvasSelectionInfo();
                    setStateDirty();
                    
                } else {
                    // 如果Markdown解析失败，回退到普通文本
                    createNode(dropPos.x, dropPos.y, text.trim());
                    updateCanvasCountInfo();
                    updateCanvasSelectionInfo();
                }
            } catch (error) {
                // 如果Markdown导入失败，回退到普通文本导入
                createNode(dropPos.x, dropPos.y, text.trim());
                updateCanvasCountInfo();
                updateCanvasSelectionInfo();
            }
            
            cleanup();
        };

        const cancelHandler = () => {
            // 用户选择作为普通文本导入
            // 用户选择普通文本导入
            createNode(dropPos.x, dropPos.y, text.trim());
            updateCanvasCountInfo();
            updateCanvasSelectionInfo();
            cleanup();
        };

        const cleanup = () => {
            dom.confirmModalBackdrop.style.display = 'none';
            dom.confirmOkBtn.removeEventListener('click', okHandler);
            dom.confirmCancelBtn.removeEventListener('click', cancelHandler);
        };
        
        dom.confirmOkBtn.addEventListener('click', okHandler);
        dom.confirmCancelBtn.addEventListener('click', cancelHandler);
    }
    
    // JSON Markdown导入确认对话框
    function showJsonMarkdownImportConfirmation(jsonData, file, dropPos) {
        const message = "检测到JSON文件包含层级结构，是否要解析为Markdown格式？\n选择\"确定\"将解析为节点，选择\"取消\"将作为普通JSON导入。";
        
        dom.confirmModalMessage.textContent = message;
        dom.confirmModalBackdrop.style.display = 'flex';
        
        const okHandler = () => {
            // 用户选择解析为Markdown
            // 用户确认Markdown解析
            
            try {
                // 使用智能位置计算
                const importPosition = calculateSmartImportPosition();
                
                // 解析并生成节点
                const parsedItems = parseJsonStructure(jsonData);
                const result = generateNodesFromMarkdown(parsedItems, importPosition);
                
                if (result) {
                    // 合并导入：添加新内容到现有画布
                    const existingNodes = [...state.nodes];
                    const existingGroups = [...state.groups];
                    
                    state.nodes = [...existingNodes, ...result.nodes];
                    state.groups = [...existingGroups, ...result.groups];
                    
                    // 保存状态并重绘
                    saveState('JSON-MD导入');
                    updateCanvasCountInfo();
                    updateCanvasSelectionInfo();
                    setStateDirty();
                    
                    // 成功导入节点
                } else {
                    // 如果Markdown解析失败，回退到普通JSON导入
                    mergeFromFile(file, dropPos);
                }
            } catch (error) {
                // 如果Markdown导入失败，回退到普通JSON导入
                mergeFromFile(file, dropPos);
            }
            
            cleanup();
        };

        const cancelHandler = () => {
            // 用户选择作为普通JSON导入
            mergeFromFile(file, dropPos);
            cleanup();
        };

        const cleanup = () => {
            dom.confirmModalBackdrop.style.display = 'none';
            dom.confirmOkBtn.removeEventListener('click', okHandler);
            dom.confirmCancelBtn.removeEventListener('click', cancelHandler);
        };
        
        dom.confirmOkBtn.addEventListener('click', okHandler);
        dom.confirmCancelBtn.addEventListener('click', cancelHandler);
    }
    
    // JSON Markdown加载确认对话框
    function showJsonMarkdownLoadConfirmation(jsonData, file) {
        const message = "检测到JSON文件包含层级结构，是否要解析为Markdown格式？\n选择\"确定\"将解析为节点，选择\"取消\"将作为普通JSON加载。";
        
        dom.confirmModalMessage.textContent = message;
        dom.confirmModalBackdrop.style.display = 'flex';
        
        const okHandler = () => {
            // 用户选择解析为Markdown
            try {
                // 清空当前画布
                state.nodes = [];
                state.groups = [];
                state.magneticGroups = [];
                state.view = { panX: 0, panY: 0, zoom: 1 };
                
                // 使用智能位置计算
                const importPosition = calculateSmartImportPosition();
                
                // 解析并生成节点
                const parsedItems = parseJsonStructure(jsonData);
                const result = generateNodesFromMarkdown(parsedItems, importPosition);
                
                if (result) {
                    state.nodes = result.nodes;
                    state.groups = result.groups;
                    
                    // 设置画布名称
                    dom.canvasNameInput.value = file.name.replace(/\.json$/, '');
                    
                    // 保存状态并重绘
                    saveState('JSON-MD加载');
                    focusOnSelection();
                    updateCanvasCountInfo();
                    updateCanvasSelectionInfo();
                    setStateDirty();
                    
                } else {
                    // 如果Markdown解析失败，显示错误
                    alert('Markdown解析失败！');
                }
            } catch (error) {
                alert('加载失败！');
            }
            
            cleanup();
        };

        const cancelHandler = () => {
            // 用户选择作为普通JSON加载
            try {
                // 尝试作为标准画布格式加载
                state.nodes = jsonData.nodes || [];
                state.groups = jsonData.groups || [];
                state.magneticGroups = (jsonData.magneticGroups || []).map(clusterArray => new Set(clusterArray));
                state.view = jsonData.view || { panX: 0, panY: 0, zoom: 1 };
                dom.canvasNameInput.value = file.name.replace(/\.json$/, '');
                
                saveState('加载项目');
                focusOnSelection();
                updateCanvasCountInfo();
                updateCanvasSelectionInfo();
                setStateDirty();
                // 显示加载成功提示
                showToast('文件加载成功', 'success', 1500);
                // 显示加载成功提示
                showToast('文件加载成功', 'success', 1500);
                // 显示加载成功提示
            showToast('文件加载成功', 'success', 1500);
                // 显示加载成功提示
                showToast('文件加载成功', 'success', 1500);
            } catch (error) {
                alert('加载文件失败！');
            }
            
            cleanup();
        };

        const cleanup = () => {
            dom.confirmModalBackdrop.style.display = 'none';
            dom.confirmOkBtn.removeEventListener('click', okHandler);
            dom.confirmCancelBtn.removeEventListener('click', cancelHandler);
        };
        
        dom.confirmOkBtn.addEventListener('click', okHandler);
        dom.confirmCancelBtn.addEventListener('click', cancelHandler);
    }
    
    // Markdown加载确认对话框
    function showMarkdownLoadConfirmation(markdownContent, file) {
        const message = "检测到文件包含Markdown内容，是否要解析为节点？\n选择\"确定\"将解析为节点，选择\"取消\"将取消加载。";
        
        dom.confirmModalMessage.textContent = message;
        dom.confirmModalBackdrop.style.display = 'flex';
        
        const okHandler = () => {
            // 用户选择解析为Markdown
            // 用户确认Markdown解析
            
            try {
                // 清空当前画布
                state.nodes = [];
                state.groups = [];
                state.magneticGroups = [];
                state.view = { panX: 0, panY: 0, zoom: 1 };
                
                // 使用智能位置计算
                const importPosition = calculateSmartImportPosition();
                
                // 解析并生成节点
                const parsedItems = parseMarkdownText(markdownContent);
                if (!Array.isArray(parsedItems) || parsedItems.length === 0) {
                    // 解析失败
                    alert('解析失败：没有找到有效的标题内容！');
                    return;
                }
                
                const result = generateNodesFromMarkdown(parsedItems, importPosition);
                
                if (result) {
                    state.nodes = result.nodes;
                    state.groups = result.groups;
                    
                    // 设置画布名称
                    dom.canvasNameInput.value = file.name.replace(/\.(md|txt|json)$/, '');
                    
                    // 保存状态并重绘
                    saveState('MD加载');
                    focusOnSelection();
                    updateCanvasCountInfo();
                    updateCanvasSelectionInfo();
                    setStateDirty();
                    
                    // 成功加载节点
                } else {
                    // 如果Markdown解析失败，显示错误
                    alert('Markdown解析失败！');
                }
            } catch (error) {
                // 加载失败
                alert(`加载失败：${error.message || '未知错误'}`);
            }
            
            cleanup();
        };

        const cancelHandler = () => {
            // 用户选择取消加载
            // 用户取消加载
            cleanup();
        };

        const cleanup = () => {
            dom.confirmModalBackdrop.style.display = 'none';
            dom.confirmOkBtn.removeEventListener('click', okHandler);
            dom.confirmCancelBtn.removeEventListener('click', cancelHandler);
        };
        
        dom.confirmOkBtn.addEventListener('click', okHandler);
        dom.confirmCancelBtn.addEventListener('click', cancelHandler);
    }
    
    // Markdown合并确认对话框
    function showMarkdownMergeConfirmation(markdownContent, file, mergeAtPos) {
        const message = "检测到文件包含Markdown内容，是否要解析为节点并合并到当前画布？\n选择\"确定\"将解析为节点并合并，选择\"取消\"将取消操作。";
        
        dom.confirmModalMessage.textContent = message;
        dom.confirmModalBackdrop.style.display = 'flex';
        
        const okHandler = () => {
            // 用户选择解析为Markdown并合并
            // 用户确认Markdown合并
            
            try {
                // 使用智能位置计算或指定位置
                const importPosition = mergeAtPos || calculateSmartImportPosition();
                
                // 解析并生成节点
                const parsedItems = parseMarkdownText(markdownContent);
                if (!Array.isArray(parsedItems) || parsedItems.length === 0) {
                    // 解析失败
                    alert('解析失败：没有找到有效的标题内容！');
                    return;
                }
                
                const result = generateNodesFromMarkdown(parsedItems, importPosition);
                
                if (result) {
                    // 清除当前选择
                    state.nodes.forEach(n => n.isSelected = false);
                    state.groups.forEach(g => g.isSelected = false);
                    
                    // 添加新节点并设为选中状态
                    result.nodes.forEach(node => {
                        node.isSelected = true;
                        state.nodes.push(node);
                    });
                    
                    result.groups.forEach(group => {
                        group.isSelected = true;
                        state.groups.push(group);
                    });
                    
                    // 保存状态并重绘
                    saveState('MD合并');
                    updateCanvasCountInfo();
                    updateCanvasSelectionInfo();
                    setStateDirty();
                    
                    // 成功合并节点
                } else {
                    // 如果Markdown解析失败，显示错误
                    alert('Markdown解析失败！');
                }
            } catch (error) {
                // 合并失败
                alert(`合并失败：${error.message || '未知错误'}`);
            }
            
            cleanup();
        };

        const cancelHandler = () => {
            // 用户选择取消合并
            // 用户取消合并
            cleanup();
        };

        const cleanup = () => {
            dom.confirmModalBackdrop.style.display = 'none';
            dom.confirmOkBtn.removeEventListener('click', okHandler);
            dom.confirmCancelBtn.removeEventListener('click', cancelHandler);
        };
        
        dom.confirmOkBtn.addEventListener('click', okHandler);
        dom.confirmCancelBtn.addEventListener('click', cancelHandler);
    }
    
    // ===================================================================================
    // Unified Markdown Import Confirmation Modal Logic
    // ===================================================================================
    function showUnifiedMarkdownImportConfirmation(text, context = {}) {
        return new Promise((resolve) => {
            // 显示模态框
            dom.markdownImportModalBackdrop.style.display = 'flex';
            
            // 聚焦到Markdown导图按钮
            setTimeout(() => {
                dom.markdownImportMindmapBtn.focus();
            }, 100);
            
            const cleanup = () => {
                dom.markdownImportModalBackdrop.style.display = 'none';
                dom.markdownImportModalBackdrop.removeEventListener('click', backdropClickHandler);
                document.removeEventListener('keydown', escapeHandler);
                dom.markdownImportCancelBtn.removeEventListener('click', cancelHandler);
                dom.markdownImportTextBtn.removeEventListener('click', textHandler);
                dom.markdownImportMindmapBtn.removeEventListener('click', mindmapHandler);
                dom.markdownImportModalCloseBtn.removeEventListener('click', closeHandler);
            };
            
            const cancelHandler = () => {
                cleanup();
                resolve('cancel');
            };
            
            const textHandler = () => {
                cleanup();
                resolve('text');
            };
            
            const mindmapHandler = () => {
                cleanup();
                resolve('mindmap');
            };
            
            const closeHandler = () => {
                cleanup();
                resolve('cancel');
            };
            
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    cancelHandler();
                }
            };
            
            const backdropClickHandler = (e) => {
                if (e.target === dom.markdownImportModalBackdrop) {
                    cancelHandler();
                }
            };
            
            // 添加事件监听器
            dom.markdownImportCancelBtn.addEventListener('click', cancelHandler);
            dom.markdownImportTextBtn.addEventListener('click', textHandler);
            dom.markdownImportMindmapBtn.addEventListener('click', mindmapHandler);
            dom.markdownImportModalCloseBtn.addEventListener('click', closeHandler);
            document.addEventListener('keydown', escapeHandler);
            dom.markdownImportModalBackdrop.addEventListener('click', backdropClickHandler);
        });
    }
    
    // 统一处理Markdown导入选择的函数
    function handleUnifiedMarkdownImportChoice(text, choice, context = {}) {
        try {
            switch (choice) {
                case 'text':
                    // 作为普通文本导入
                    if (context.type === 'paste') {
                        // 粘贴操作
                        const pastePos = context.position || utils.screenToWorld(state.canvas.width / 2, state.canvas.height / 2);
                        pasteFromClipboard(pastePos, text);
                    } else if (context.type === 'drop') {
                        // 拖拽操作
                        const dropPos = context.position || { x: 100, y: 100 };
                        createNode(dropPos.x, dropPos.y, text);
                        saveState('拖拽文本');
                    } else if (context.type === 'load') {
                        // 加载操作 - 清空画布后创建文本节点
                        clearCanvas();
                        createNode(100, 100, text);
                        saveState('加载文本文件');
                    } else if (context.type === 'merge') {
                        // 合并操作 - 直接创建文本节点
                        createNode(100, 100, text);
                        saveState('合并文本文件');
                    }
                    break;
                    
                case 'mindmap':
                    // 解析为Markdown导图
                    if (context.type === 'paste') {
                        // 粘贴操作
                        processImportContent(text);
                    } else if (context.type === 'drop') {
                        // 拖拽操作
                        const dropPos = context.position || { x: 100, y: 100 };
                        const result = generateNodesFromMarkdown(parseMarkdownStructure(text), context.position || { x: 100, y: 100 });
                        const parsedNodes = result ? result.nodes : null;
                        if (parsedNodes && parsedNodes.length > 0) {
                            // 调整节点位置到拖拽位置
                            const offsetX = dropPos.x - parsedNodes[0].x;
                            const offsetY = dropPos.y - parsedNodes[0].y;
                            parsedNodes.forEach(node => {
                                node.x += offsetX;
                                node.y += offsetY;
                            });
                            state.nodes.push(...parsedNodes);
                            saveState('拖拽Markdown导图');
                        }
                    } else if (context.type === 'load') {
                        // 加载操作
                        clearCanvas();
                        const result = generateNodesFromMarkdown(parseMarkdownStructure(text), { x: 100, y: 100 });
                        const parsedNodes = result ? result.nodes : null;
                        if (parsedNodes && parsedNodes.length > 0) {
                            state.nodes.push(...parsedNodes);
                            saveState('加载Markdown文件');
                        }
                    } else if (context.type === 'merge') {
                        // 合并操作
                        const result = generateNodesFromMarkdown(parseMarkdownStructure(text), { x: 100, y: 100 });
                        const parsedNodes = result ? result.nodes : null;
                        if (parsedNodes && parsedNodes.length > 0) {
                            state.nodes.push(...parsedNodes);
                            saveState('合并Markdown文件');
                        }
                    }
                    break;
                    
                case 'cancel':
                default:
                    // 取消导入，不做任何操作
                    // 用户取消导入
                    break;
            }
            
            // 更新画布
            if (choice !== 'cancel') {
                setStateDirty();
            }
        } catch (error) {
            // 处理导入选择出错
            showToast('导入失败：' + (error.message || '未知错误'), 'error');
        }
    }
    
    // ===================================================================================
    // Custom Confirm Modal Logic
    // ===================================================================================
    function showCustomConfirm(message) {
        return new Promise((resolve) => {
            // 设置消息内容
            dom.customConfirmMessage.textContent = message;
            
            // 显示模态框
            dom.customConfirmModalBackdrop.style.display = 'flex';
            
            // 聚焦到确定按钮
            setTimeout(() => {
                dom.customConfirmOkBtn.focus();
            }, 100);
            
            const cleanup = () => {
                dom.customConfirmModalBackdrop.style.display = 'none';
                dom.customConfirmModalBackdrop.removeEventListener('click', backdropClickHandler);
                document.removeEventListener('keydown', escapeHandler);
                dom.customConfirmOkBtn.removeEventListener('click', okHandler);
                dom.customConfirmCancelBtn.removeEventListener('click', cancelHandler);
                dom.customConfirmModalCloseBtn.removeEventListener('click', closeHandler);
            };
            
            const okHandler = () => {
                cleanup();
                resolve(true);
            };
            
            const cancelHandler = () => {
                cleanup();
                resolve(false);
            };
            
            const closeHandler = () => {
                cleanup();
                resolve(false);
            };
            
            const backdropClickHandler = (e) => {
                if (e.target === dom.customConfirmModalBackdrop) {
                    closeHandler();
                }
            };
            
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    closeHandler();
                } else if (e.key === 'Enter') {
                    okHandler();
                }
            };
            
            // 添加事件监听器
            dom.customConfirmOkBtn.addEventListener('click', okHandler);
            dom.customConfirmCancelBtn.addEventListener('click', cancelHandler);
            dom.customConfirmModalCloseBtn.addEventListener('click', closeHandler);
            dom.customConfirmModalBackdrop.addEventListener('click', backdropClickHandler);
            document.addEventListener('keydown', escapeHandler);
        });
    }

    // ===================================================================================
    // Help Modal Logic
    // ===================================================================================
    function showHelpModal(isInitial = false) {
        dom.helpModalBackdrop.style.display = 'flex';
        dom.helpModalCloseBtn.style.display = 'block'; // 始终显示关闭按钮

        const closeHandler = () => {
            hideHelpModal();
            dom.helpModalBackdrop.removeEventListener('click', backdropClickHandler);
            document.removeEventListener('keydown', escapeHandler);
            // Remove copy/paste event listeners
            dom.helpModalBackdrop.removeEventListener('copy', copyPasteHandler);
            dom.helpModalBackdrop.removeEventListener('cut', copyPasteHandler);
            dom.helpModalBackdrop.removeEventListener('paste', copyPasteHandler);
            dom.helpModalBackdrop.removeEventListener('keydown', copyPasteKeyHandler);
        };

        const backdropClickHandler = (e) => {
            if (e.target === dom.helpModalBackdrop) {
                closeHandler();
            }
        };
        
        const escapeHandler = (e) => {
            if (e.key === 'Escape') {
                closeHandler();
            }
        };

        // Allow copy/paste in help modal
        const copyPasteHandler = (e) => {
            e.stopPropagation();
        };

        const copyPasteKeyHandler = (e) => {
            if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'x' || e.key === 'v')) {
                e.stopPropagation();
            }
        };

        // Add copy/paste event listeners to help modal
        dom.helpModalBackdrop.addEventListener('copy', copyPasteHandler);
        dom.helpModalBackdrop.addEventListener('cut', copyPasteHandler);
        dom.helpModalBackdrop.addEventListener('paste', copyPasteHandler);
        dom.helpModalBackdrop.addEventListener('keydown', copyPasteKeyHandler);

        if (isInitial) {
             setTimeout(() => { 
                 dom.helpModalBackdrop.addEventListener('click', backdropClickHandler);
             }, 100);
        } else {
            dom.helpModalBackdrop.addEventListener('click', backdropClickHandler);
        }
        
        document.addEventListener('keydown', escapeHandler);
    }

    function hideHelpModal() {
        dom.helpModalBackdrop.style.display = 'none';
    }


    // ===================================================================================
    // Search Logic
    // ===================================================================================
    function updateSearchUI() {
        const { searchResults, searchIndex } = state.interaction;
        const total = searchResults.length;
        const current = searchIndex > -1 ? searchIndex + 1 : 0;
        dom.searchCount.textContent = `${current} / ${total}`;

        const searchTerm = dom.searchBox.value;
        dom.searchClearBtn.style.display = searchTerm.length > 0 ? 'block' : 'none';
    }

    function handleSearch(e) {
        const searchTerm = e.target.value.toLowerCase().trim();
        state.interaction.searchResults = [];
        state.interaction.searchIndex = -1;
        state.interaction.isNavigatingResults = false; // 重置导航状态，显示所有搜索结果
        
        // 清除所有搜索结果标记
        state.nodes.forEach(n => n.isSearchResult = false);
        state.groups.forEach(g => g.isSearchResult = false);

        if (searchTerm !== '') {
            let nodesToSearch, groupsToSearch;
            
            if (state.interaction.searchScope === 'current') {
                // 当前层级搜索
                nodesToSearch = getCurrentLevelNodes();
                groupsToSearch = getCurrentLevelGroups();
            } else {
                // 全局搜索
                nodesToSearch = state.nodes;
                groupsToSearch = state.groups;
            }
            
            // 搜索节点
            nodesToSearch.forEach(n => {
                if (n && n.text.toLowerCase().includes(searchTerm)) {
                    n.isSearchResult = true;
                    state.interaction.searchResults.push(n);
                }
            });
            
            // 搜索分组（仅在开关开启时）
            if (state.interaction.searchGroups) {
                groupsToSearch.forEach(g => {
                    if (g && g.title.toLowerCase().includes(searchTerm)) {
                        g.isSearchResult = true;
                        state.interaction.searchResults.push(g);
                    }
                });
            }
        }
        
        updateSearchUI();
        setStateDirty();
    }

    function focusOnSearchResult(direction) {
        const { searchResults } = state.interaction;
        if (searchResults.length === 0) return;

        // 标记开始导航搜索结果
        state.interaction.isNavigatingResults = true;

        let { searchIndex } = state.interaction;

        if (direction === 'next') {
            searchIndex++;
            if (searchIndex >= searchResults.length) searchIndex = 0;
        } else if (direction === 'prev') {
            searchIndex--;
            if (searchIndex < 0) searchIndex = searchResults.length - 1;
        }

        state.interaction.searchIndex = searchIndex;

        // 清除所有选中状态（搜索时可能需要跨层级清除）
        if (state.interaction.searchScope === 'global') {
            // 全局搜索时清除所有层级的选中状态
            state.nodes.forEach(n => n.isSelected = false);
            state.groups.forEach(g => g.isSelected = false);
        } else {
            // 当前层级搜索时只清除当前层级
            getCurrentLevelNodes().forEach(n => n.isSelected = false);
            getCurrentLevelGroups().forEach(g => g.isSelected = false);
        }

        const targetItem = searchResults[searchIndex];
        if (targetItem) {
            // 搜索结果聚焦
            
            // 如果是全局搜索，需要导航到目标项目所在的层级
            if (state.interaction.searchScope === 'global') {
                const targetNodeSetId = targetItem.parentNodeSetId || null;
                
                // 目标层导航
                
                // 如果目标项目在不同的层级，导航到该层级
                if (targetNodeSetId !== state.nodeSetNavigation.currentNodeSetId) {
                    if (targetNodeSetId === null) {
                        // 导航到根层级
                        // 导航到根层级
                        navigateToNodeSet(null);
                    } else {
                        // 导航到指定的节点集
                        // 导航到节点集
                        
                        // 确保目标节点集存在
                        const targetNodeSet = state.nodes.find(n => n.id === targetNodeSetId && n.isNodeSet);
                        if (targetNodeSet) {
                            navigateToNodeSet(targetNodeSetId);
                        } else {
                            // 目标节点集未找到
                            // 如果找不到目标节点集，尝试导航到根层级
                            navigateToNodeSet(null);
                        }
                    }
                    
                    // 强制重新渲染以确保导航栏更新
                    setStateDirty();
                }
            }
            
            // 选中目标项目
            targetItem.isSelected = true;
            
            // 聚焦到选中项目
            focusOnSelection();
            
            // 搜索结果成功聚焦
        }
        updateSearchUI();
    }

    // ===================================================================================
    // Initialization
    // ===================================================================================
    function setupColorPickers() {
        const colorPresets = [
            '#ffffff', '#f8fafc', '#f1f5f9', '#e2e8f0', '#cbd5e1', '#94a3b8', '#64748b', '#475569', '#334155',
            '#1e293b', '#0f172a', '#020617', '#000000', '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6',
            '#06b6d4', '#84cc16', '#f97316', '#ec4899', '#6366f1', '#14b8a6', '#d97706', '#b91c1c', '#7e22ce'
        ];

        // Custom Color Picker Class
        class CustomColorPicker {
            constructor(wrapper, type) {
                this.wrapper = wrapper;
                this.type = type;
                this.colorDisplay = wrapper.querySelector('.color-display');
                // 面板现在在body下，通过data-picker-id查找
                this.panel = document.querySelector(`.custom-color-picker-panel[data-picker-id="${type}"]`);
                this.currentColor = { h: 0, s: 100, l: 50 };
                this.currentMode = 'HSL';
                this.isActive = false;
                this.instanceId = 'cp_' + Math.random().toString(36).substr(2, 9); // 生成唯一实例ID
                
                this.init();
            }

            init() {
                this.createPanelContent();
                this.bindEvents();
            }

            createPanelContent() {
                this.panel.innerHTML = `
                    <div class="color-picker-header">
                        <div class="color-picker-title">${this.getTitle()}</div>
                        <div class="color-mode-tabs">
                            <button class="color-mode-tab active" data-mode="HSL">HSL</button>
                            <button class="color-mode-tab" data-mode="RGB">RGB</button>
                            <button class="color-mode-tab" data-mode="HEX">HEX</button>
                        </div>
                    </div>
                    <div class="color-picker-main">
                        <div class="color-area" style="background: hsl(${this.currentColor.h}, 100%, 50%);">
                            <div class="color-area-cursor"></div>
                        </div>
                        <div class="hue-slider-container">
                            <div class="hue-slider">
                                <div class="hue-slider-cursor"></div>
                            </div>
                        </div>
                    </div>
                    <div class="color-inputs">
                        <div class="color-inputs-row">
                            <div class="color-input-group hsl-inputs">
                                <div class="color-input-item">
                                    <label class="color-input-label" for="${this.instanceId}_h">H</label>
                                    <input type="number" class="color-input" id="${this.instanceId}_h" min="0" max="360" value="${this.currentColor.h}">
                                </div>
                                <div class="color-input-item">
                                    <label class="color-input-label" for="${this.instanceId}_s">S</label>
                                    <input type="number" class="color-input" id="${this.instanceId}_s" min="0" max="100" value="${this.currentColor.s}">
                                </div>
                                <div class="color-input-item">
                                    <label class="color-input-label" for="${this.instanceId}_l">L</label>
                                    <input type="number" class="color-input" id="${this.instanceId}_l" min="0" max="100" value="${this.currentColor.l}">
                                </div>
                            </div>
                            <div class="color-input-group rgb-inputs" style="display: none;">
                                <div class="color-input-item">
                                    <label class="color-input-label" for="${this.instanceId}_r">R</label>
                                    <input type="number" class="color-input" id="${this.instanceId}_r" min="0" max="255" value="255">
                                </div>
                                <div class="color-input-item">
                                    <label class="color-input-label" for="${this.instanceId}_g">G</label>
                                    <input type="number" class="color-input" id="${this.instanceId}_g" min="0" max="255" value="128">
                                </div>
                                <div class="color-input-item">
                                    <label class="color-input-label" for="${this.instanceId}_b">B</label>
                                    <input type="number" class="color-input" id="${this.instanceId}_b" min="0" max="255" value="128">
                                </div>
                            </div>
                            <div class="hex-input-group" style="display: none;">
                                <div class="color-input-item">
                                    <label class="color-input-label" for="${this.instanceId}_hex">HEX</label>
                                    <input type="text" class="hex-input" id="${this.instanceId}_hex" value="#ff8080">
                                </div>
                            </div>
                            <div class="color-picker-tools">
                                <button class="eyedropper-btn" title="颜色吸管工具">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75 1.84-1.83z" fill="currentColor"/>
                                        <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z" fill="currentColor"/>
                                        <path d="M16.06 8.19l-1.41-1.41L16.06 5.37l1.41 1.41-1.41 1.41z" fill="currentColor"/>
                                    </svg>
                                </button>
                                <div class="color-preview">
                                    <div class="color-preview-current"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="color-presets">
                        ${colorPresets.map(color => `<div class="color-preset-item" style="background-color: ${color};" data-color="${color}"></div>`).join('')}
                    </div>
                `;
            }

            getTitle() {
                switch(this.type) {
                    case 'node-bg': return '节点背景色';
                    case 'font': return '节点字体';
                    case 'group': return '组颜色';
                    default: return '颜色选择';
                }
            }

            bindEvents() {
                // Color display click
                this.colorDisplay.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.checkPermission()) {
                        this.toggle();
                    } else {
                        this.showPermissionError();
                    }
                });

                // Mode tabs
                this.panel.querySelectorAll('.color-mode-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.switchMode(tab.dataset.mode);
                    });
                });

                // Color area interaction
                const colorArea = this.panel.querySelector('.color-area');
                const colorCursor = this.panel.querySelector('.color-area-cursor');
                let isDraggingColor = false;

                // Mouse events
                colorArea.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    isDraggingColor = true;
                    this.updateColorFromArea(e);
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDraggingColor) {
                        this.updateColorFromArea(e);
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isDraggingColor) {
                        this.applyColor(); // 只在鼠标释放时应用颜色并记录历史
                    }
                    isDraggingColor = false;
                });

                // Touch events for mobile
                colorArea.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    isDraggingColor = true;
                    this.updateColorFromArea(e.touches[0]);
                }, { passive: true });

                colorArea.addEventListener('touchmove', (e) => {
                    e.preventDefault(); // 只在touchmove中阻止默认行为以防止滚动
                    e.stopPropagation();
                    if (isDraggingColor) {
                        this.updateColorFromArea(e.touches[0]);
                    }
                }, { passive: false });

                colorArea.addEventListener('touchend', (e) => {
                    e.stopPropagation();
                    if (isDraggingColor) {
                        this.applyColor(); // 只在触摸结束时应用颜色并记录历史
                    }
                    isDraggingColor = false;
                }, { passive: true });

                // Hue slider interaction
                const hueSlider = this.panel.querySelector('.hue-slider');
                const hueCursor = this.panel.querySelector('.hue-slider-cursor');
                let isDraggingHue = false;

                // Mouse events
                hueSlider.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    isDraggingHue = true;
                    this.updateHueFromSlider(e);
                });

                document.addEventListener('mousemove', (e) => {
                    if (isDraggingHue) {
                        this.updateHueFromSlider(e);
                    }
                });

                document.addEventListener('mouseup', () => {
                    if (isDraggingHue) {
                        this.applyColor(); // 只在鼠标释放时应用颜色并记录历史
                    }
                    isDraggingHue = false;
                });

                // Touch events for mobile
                hueSlider.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    isDraggingHue = true;
                    this.updateHueFromSlider(e.touches[0]);
                }, { passive: true });

                hueSlider.addEventListener('touchmove', (e) => {
                    e.preventDefault(); // 只在touchmove中阻止默认行为以防止滚动
                    e.stopPropagation();
                    if (isDraggingHue) {
                        this.updateHueFromSlider(e.touches[0]);
                    }
                }, { passive: false });

                hueSlider.addEventListener('touchend', (e) => {
                    e.stopPropagation();
                    if (isDraggingHue) {
                        this.applyColor(); // 只在触摸结束时应用颜色并记录历史
                    }
                    isDraggingHue = false;
                }, { passive: true });

                // Input fields
                this.panel.querySelectorAll('.color-input, .hex-input').forEach(input => {
                    input.addEventListener('input', () => {
                        this.updateColorFromInputs();
                    });
                    
                    // Allow copy/paste in color picker inputs
                    input.addEventListener('copy', (e) => {
                        e.stopPropagation();
                    });
                    input.addEventListener('cut', (e) => {
                        e.stopPropagation();
                    });
                    input.addEventListener('paste', (e) => {
                        e.stopPropagation();
                    });
                    input.addEventListener('keydown', (e) => {
                        // 阻止复制粘贴快捷键冒泡
                        if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'x' || e.key === 'v')) {
                            e.stopPropagation();
                        }
                        // 阻止数字和退格键冒泡，避免触发全局快捷键
                        else if (/^\d$/.test(e.key) || e.key === 'Backspace' || e.key === 'Delete') {
                            e.stopPropagation();
                        }
                    });
                });

                // Color presets
                this.panel.querySelectorAll('.color-preset-item').forEach(preset => {
                    preset.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.setColor(preset.dataset.color);
                    });
                });

                // Eyedropper tool
                const eyedropperBtn = this.panel.querySelector('.eyedropper-btn');
                eyedropperBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.activateEyedropper();
                });

                // Close on outside click
                document.addEventListener('click', (e) => {
                    if (!this.wrapper.contains(e.target) && !this.panel.contains(e.target)) {
                        this.close();
                    }
                });

                // Prevent panel clicks from closing
                this.panel.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }

            toggle() {
                if (this.isActive) {
                    this.close();
                } else {
                    this.open();
                }
            }

            open() {
                // Close other pickers
                document.querySelectorAll('.custom-color-picker-panel').forEach(panel => {
                    panel.classList.remove('active');
                });
                
                // 读取当前选中对象的颜色并设置为初始颜色
                this.loadCurrentColor();
                
                // 动态定位取色器面板
                const btnRect = this.colorDisplay.getBoundingClientRect();
                const panelWidth = 280; // 面板宽度
                const panelHeight = 400; // 预估面板高度
                
                // 计算位置，确保不超出视窗
                let left = btnRect.left;
                let top = btnRect.bottom + 8;
                
                // 检查右边界
                if (left + panelWidth > window.innerWidth - 10) {
                    left = window.innerWidth - panelWidth - 10;
                }
                
                // 检查左边界
                if (left < 10) {
                    left = 10;
                }
                
                // 检查底部边界
                if (top + panelHeight > window.innerHeight - 10) {
                    top = btnRect.top - panelHeight - 8;
                }
                
                // 应用位置
                this.panel.style.left = left + 'px';
                this.panel.style.top = top + 'px';
                
                this.panel.classList.add('active');
                this.isActive = true;
                this.updateUI();
            }

            loadCurrentColor() {
                let currentColor = null;
                
                if (this.type === 'node-bg') {
                    const selectedNodes = getSelectedNodes();
                    if (selectedNodes.length > 0) {
                        // 使用第一个选中节点的背景色
                        currentColor = selectedNodes[0].backgroundColor;
                    }
                } else if (this.type === 'font') {
                    const selectedNodes = getSelectedNodes();
                    if (selectedNodes.length > 0) {
                        // 使用第一个选中节点的字体色
                        currentColor = selectedNodes[0].color;
                    }
                } else if (this.type === 'group') {
                    const selectedGroups = getSelectedGroups();
                    if (selectedGroups.length > 0) {
                        // 使用第一个选中组的颜色
                        currentColor = selectedGroups[0].color;
                    }
                }
                
                // 如果找到了当前颜色，则解析并设置
                if (currentColor) {
                    const parsedColor = this.parseColor(currentColor);
                    if (parsedColor) {
                        this.currentColor = parsedColor;
                    }
                }
            }

            parseColor(colorString) {
                // 解析各种颜色格式并转换为HSL
                if (!colorString) return null;
                
                // 处理HSL格式: hsl(h, s%, l%)
                const hslMatch = colorString.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (hslMatch) {
                    return {
                        h: parseInt(hslMatch[1]),
                        s: parseInt(hslMatch[2]),
                        l: parseInt(hslMatch[3])
                    };
                }
                
                // 处理RGB格式: rgb(r, g, b)
                const rgbMatch = colorString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (rgbMatch) {
                    const r = parseInt(rgbMatch[1]);
                    const g = parseInt(rgbMatch[2]);
                    const b = parseInt(rgbMatch[3]);
                    return this.rgbToHsl(r, g, b);
                }
                
                // 处理HEX格式: #rrggbb
                const hexMatch = colorString.match(/^#([0-9A-F]{6})$/i);
                if (hexMatch) {
                    const rgb = this.hexToRgb(colorString);
                    return this.rgbToHsl(rgb.r, rgb.g, rgb.b);
                }
                
                // 处理命名颜色或其他格式，创建临时元素来获取计算后的颜色
                const tempDiv = document.createElement('div');
                tempDiv.style.color = colorString;
                document.body.appendChild(tempDiv);
                const computedColor = window.getComputedStyle(tempDiv).color;
                document.body.removeChild(tempDiv);
                
                // 解析计算后的RGB颜色
                const computedRgbMatch = computedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (computedRgbMatch) {
                    const r = parseInt(computedRgbMatch[1]);
                    const g = parseInt(computedRgbMatch[2]);
                    const b = parseInt(computedRgbMatch[3]);
                    return this.rgbToHsl(r, g, b);
                }
                
                return null;
            }

            close() {
                this.panel.classList.remove('active');
                this.isActive = false;
            }

            checkPermission() {
                if (this.type === 'node-bg' || this.type === 'font') {
                    // 检查是否有选中的节点
                    const selectedNodes = getSelectedNodes();
                    return selectedNodes.length > 0;
                } else if (this.type === 'group') {
                    // 检查是否有选中的组
                    const selectedGroups = getSelectedGroups();
                    return selectedGroups.length > 0;
                }
                return true;
            }

            showPermissionError() {
                // 创建提示弹窗
                const toast = document.createElement('div');
                toast.className = 'permission-toast';
                toast.textContent = '请先选择对象';
                toast.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(239, 68, 68, 0.9);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 500;
                    z-index: 1000;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                    backdrop-filter: blur(8px);
                    animation: slideInRight 0.3s ease-out;
                `;
                
                document.body.appendChild(toast);
                
                // 1秒后自动消失
                setTimeout(() => {
                    toast.style.animation = 'slideOutRight 0.3s ease-in';
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300);
                }, 1000);
            }

            switchMode(mode) {
                this.currentMode = mode;
                this.panel.querySelectorAll('.color-mode-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.mode === mode);
                });

                // Show/hide input groups
                this.panel.querySelector('.hsl-inputs').style.display = mode === 'HSL' ? 'flex' : 'none';
                this.panel.querySelector('.rgb-inputs').style.display = mode === 'RGB' ? 'flex' : 'none';
                this.panel.querySelector('.hex-input-group').style.display = mode === 'HEX' ? 'flex' : 'none';

                this.updateInputs();
            }

            updateColorFromArea(e) {
                const colorArea = this.panel.querySelector('.color-area');
                const rect = colorArea.getBoundingClientRect();
                
                // 修复坐标计算，确保边界处理正确
                let x = e.clientX - rect.left;
                let y = e.clientY - rect.top;
                
                // 确保坐标在有效范围内，但允许到达边界
                x = Math.max(0, Math.min(rect.width - 1, x));
                y = Math.max(0, Math.min(rect.height - 1, y));

                // 使用HSV颜色空间进行计算，然后转换为HSL
                // x轴：从左到右，饱和度从0%到100%
                const saturation = (x / (rect.width - 1)) * 100;
                
                // y轴：从上到下，明度(Value)从100%到0%
                const value = 100 - (y / (rect.height - 1)) * 100;
                
                // 将HSV转换为HSL - 修正转换公式
                const hsvS = saturation / 100;
                const hsvV = value / 100;
                
                // 正确的HSV到HSL转换公式
                const hslL = hsvV * (2 - hsvS) / 2;
                let hslS = 0;
                
                if (hslL > 0 && hslL < 1) {
                    hslS = (hsvV - hslL) / Math.min(hslL, 1 - hslL);
                }
                
                // 确保值在有效范围内
                this.currentColor.s = Math.max(0, Math.min(100, Math.round(hslS * 100)));
                this.currentColor.l = Math.max(0, Math.min(100, Math.round(hslL * 100)));

                this.updateUI();
                this.applyColor(false); // 实时应用颜色变化，但不记录历史
            }

            updateHueFromSlider(e) {
                const hueSlider = this.panel.querySelector('.hue-slider');
                const rect = hueSlider.getBoundingClientRect();
                const y = Math.max(0, Math.min(rect.height, e.clientY - rect.top));
                const h = (y / rect.height) * 360;

                this.currentColor.h = Math.round(h);
                this.updateUI();
                this.applyColor(false); // 实时应用颜色变化，但不记录历史
            }

            updateColorFromInputs() {
                if (this.currentMode === 'HSL') {
                    const h = parseInt(this.panel.querySelector(`#${this.instanceId}_h`).value) || 0;
                    const s = parseInt(this.panel.querySelector(`#${this.instanceId}_s`).value) || 0;
                    const l = parseInt(this.panel.querySelector(`#${this.instanceId}_l`).value) || 0;
                    
                    this.currentColor = { h: Math.max(0, Math.min(360, h)), s: Math.max(0, Math.min(100, s)), l: Math.max(0, Math.min(100, l)) };
                } else if (this.currentMode === 'RGB') {
                    const r = parseInt(this.panel.querySelector(`#${this.instanceId}_r`).value) || 0;
                    const g = parseInt(this.panel.querySelector(`#${this.instanceId}_g`).value) || 0;
                    const b = parseInt(this.panel.querySelector(`#${this.instanceId}_b`).value) || 0;
                    
                    this.currentColor = this.rgbToHsl(Math.max(0, Math.min(255, r)), Math.max(0, Math.min(255, g)), Math.max(0, Math.min(255, b)));
                } else if (this.currentMode === 'HEX') {
                    const hex = this.panel.querySelector(`#${this.instanceId}_hex`).value;
                    if (/^#[0-9A-F]{6}$/i.test(hex)) {
                        const rgb = this.hexToRgb(hex);
                        this.currentColor = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
                    }
                }

                this.updateUI();
                this.applyColor(false); // 实时应用颜色变化，但不记录历史
            }

            setColor(color) {
                const rgb = this.hexToRgb(color);
                this.currentColor = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
                this.updateUI();
                this.applyColor(false); // 实时应用颜色变化，但不记录历史
            }

            updateUI() {
                // Update color area background
                const colorArea = this.panel.querySelector('.color-area');
                colorArea.style.backgroundColor = `hsl(${this.currentColor.h}, 100%, 50%)`;

                // Update cursors
                const colorCursor = this.panel.querySelector('.color-area-cursor');
                const hueCursor = this.panel.querySelector('.hue-slider-cursor');
                
                // 将HSL转换回HSV坐标来正确定位光标
                // 首先将HSL转换为HSV
                const hslS = this.currentColor.s / 100;
                const hslL = this.currentColor.l / 100;
                
                // HSL到HSV的转换公式
                const hsvV = hslL + hslS * Math.min(hslL, 1 - hslL);
                let hsvS = 0;
                if (hsvV > 0) {
                    hsvS = 2 * (1 - hslL / hsvV);
                }
                
                // 根据HSV值计算光标位置
                // x轴：饱和度 (0-100%)
                const cursorX = hsvS * 100;
                // y轴：明度值，从上到下是100%到0%
                const cursorY = 100 - (hsvV * 100);
                
                colorCursor.style.left = `${cursorX}%`;
                colorCursor.style.top = `${cursorY}%`;
                hueCursor.style.top = `${(this.currentColor.h / 360) * 100}%`;

                // Update inputs
                this.updateInputs();

                // Update color display
                const hslColor = `hsl(${this.currentColor.h}, ${this.currentColor.s}%, ${this.currentColor.l}%)`;
                this.colorDisplay.style.backgroundColor = hslColor;
                
                // Update preview
                const preview = this.panel.querySelector('.color-preview-current');
                if (preview) {
                    preview.style.backgroundColor = hslColor;
                }
            }

            updateInputs() {
                if (this.currentMode === 'HSL') {
                    this.panel.querySelector(`#${this.instanceId}_h`).value = this.currentColor.h;
                    this.panel.querySelector(`#${this.instanceId}_s`).value = this.currentColor.s;
                    this.panel.querySelector(`#${this.instanceId}_l`).value = this.currentColor.l;
                } else if (this.currentMode === 'RGB') {
                    const rgb = this.hslToRgb(this.currentColor.h, this.currentColor.s, this.currentColor.l);
                    this.panel.querySelector(`#${this.instanceId}_r`).value = rgb.r;
                    this.panel.querySelector(`#${this.instanceId}_g`).value = rgb.g;
                    this.panel.querySelector(`#${this.instanceId}_b`).value = rgb.b;
                } else if (this.currentMode === 'HEX') {
                    const rgb = this.hslToRgb(this.currentColor.h, this.currentColor.s, this.currentColor.l);
                    const hex = this.rgbToHex(rgb.r, rgb.g, rgb.b);
                    this.panel.querySelector(`#${this.instanceId}_hex`).value = hex;
                }
            }

            applyColor(saveHistory = true) {
                const hslColor = `hsl(${this.currentColor.h}, ${this.currentColor.s}%, ${this.currentColor.l}%)`;
                
                // Apply to selected elements
                if (this.type === 'node-bg') {
                    getSelectedNodes().forEach(n => {
                        n.backgroundColor = hslColor;
                        n.hasCustomStyle = true;
                    });
                    if (saveHistory) saveState('修改节点背景色');
                } else if (this.type === 'font') {
                    getSelectedNodes().forEach(n => {
                        n.color = hslColor;
                        n.hasCustomStyle = true;
                    });
                    if (saveHistory) saveState('修改节点字体');
                } else if (this.type === 'group') {
                    getSelectedGroups().forEach(g => {
                        g.color = hslColor;
                        g.hasCustomStyle = true;
                    });
                    if (saveHistory) saveState('修改组颜色');
                }
                
                setStateDirty();
            }

            activateEyedropper() {
                if ('EyeDropper' in window) {
                    const eyeDropper = new EyeDropper();
                    eyeDropper.open().then(result => {
                        this.setColor(result.sRGBHex);
                    }).catch(err => {
                        // 用户取消颜色选择
                    });
                } else {
                    alert('您的浏览器不支持颜色吸管工具');
                }
            }

            // Color conversion utilities
            hslToRgb(h, s, l) {
                h /= 360;
                s /= 100;
                l /= 100;
                
                const a = s * Math.min(l, 1 - l);
                const f = n => {
                    const k = (n + h / (1/12)) % 12;
                    return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                };
                
                return {
                    r: Math.round(f(0) * 255),
                    g: Math.round(f(8) * 255),
                    b: Math.round(f(4) * 255)
                };
            }

            rgbToHsl(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h /= 6;
                }

                return {
                    h: Math.round(h * 360),
                    s: Math.round(s * 100),
                    l: Math.round(l * 100)
                };
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }

            rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }
        }

        // Initialize custom color pickers
        document.querySelectorAll('.custom-color-picker-wrapper').forEach(wrapper => {
            const pickerId = wrapper.dataset.pickerId;
            new CustomColorPicker(wrapper, pickerId);
        });
    }

    function setupHistoryPanel() {
        const historyBtn = document.getElementById('history-snapshot-btn');
        
        if (!historyBtn) return;
        
        // Only keep the click functionality to show the new modal window
        historyBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showNewHistoryModal();
        });
    }

    function setupNewHistoryModal() {
        if (!dom.newHistoryModal || !dom.newHistoryModalContent || !dom.newHistoryModalHeader || !dom.newHistoryModalCloseBtn) return;
        
        // Close button event
        dom.newHistoryModalCloseBtn.addEventListener('click', hideNewHistoryModal);
        
        // Click outside to close (but allow canvas interaction)
        dom.newHistoryModal.addEventListener('click', (e) => {
            if (e.target === dom.newHistoryModal) {
                hideNewHistoryModal();
            }
        });
        
        // Prevent modal content clicks from closing the modal
        dom.newHistoryModalContent.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // Dragging functionality
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let initialModalPosition = { x: 0, y: 0 };
        
        dom.newHistoryModalHeader.addEventListener('mousedown', (e) => {
            isDragging = true;
            
            // Get the current actual position of the modal on screen
            const rect = dom.newHistoryModalContent.getBoundingClientRect();
            initialModalPosition.x = rect.left;
            initialModalPosition.y = rect.top;
            
            // Calculate offset from mouse to modal's current position
            dragOffset.x = e.clientX - initialModalPosition.x;
            dragOffset.y = e.clientY - initialModalPosition.y;
            
            // Reset positioning to use absolute coordinates
            dom.newHistoryModalContent.style.left = '0px';
            dom.newHistoryModalContent.style.top = '0px';
            dom.newHistoryModalContent.style.transform = `translate(${initialModalPosition.x}px, ${initialModalPosition.y}px)`;
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', handleDragEnd);
            e.preventDefault();
        });
        
        function handleDrag(e) {
            if (!isDragging) return;
            
            // Calculate new position based on mouse movement
            const x = e.clientX - dragOffset.x;
            const y = e.clientY - dragOffset.y;
            
            // Apply position directly without any boundary restrictions
            // Allow complete freedom of movement across the entire canvas
            dom.newHistoryModalContent.style.transform = `translate(${x}px, ${y}px)`;
        }
        
        function handleDragEnd() {
            isDragging = false;
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', handleDragEnd);
        }
        
        // Keyboard navigation
        dom.newHistoryModal.addEventListener('keydown', (e) => {
            if (dom.newHistoryModal.style.display === 'none') return;
            
            const items = dom.newHistoryList.querySelectorAll('.new-history-item');
            const currentIndex = selectedHistoryIndex;
            let newIndex = currentIndex;
            
            switch (e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    if (currentIndex > 0) {
                        newIndex = currentIndex - 1;
                    } else {
                        newIndex = history.length - 1; // Wrap to last item
                    }
                    break;
                    
                case 'ArrowDown':
                    e.preventDefault();
                    if (currentIndex < history.length - 1) {
                        newIndex = currentIndex + 1;
                    } else {
                        newIndex = 0; // Wrap to first item
                    }
                    break;
                    
                case 'Enter':
                    e.preventDefault();
                    if (selectedHistoryIndex >= 0) {
                        jumpToHistoryState(selectedHistoryIndex);
                        hideNewHistoryModal();
                    }
                    break;
                    
                case 'Escape':
                    e.preventDefault();
                    hideNewHistoryModal();
                    break;
            }
            
            if (newIndex !== currentIndex) {
                selectedHistoryIndex = newIndex;
                updateHistorySelection();
                
                // Scroll selected item into view
                const selectedItem = items[history.length - 1 - newIndex];
                if (selectedItem) {
                    selectedItem.scrollIntoView({ block: 'nearest' });
                }
            }
        });
        
        // Make modal focusable for keyboard navigation
        dom.newHistoryModal.setAttribute('tabindex', '-1');
    }

    function setupShortcutInputs() {
        const setupListener = (input, settingKey) => {
            input.addEventListener('keydown', e => {
                e.preventDefault();
                 if (e.key === ' ') {
                     input.value = 'space';
                     state.settings[settingKey] = 'space';
                     return;
                 }
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    input.value = '';
                    state.settings[settingKey] = '';
                    return;
                }
                const keys = [];
                if (e.ctrlKey || e.metaKey) keys.push('ctrl');
                if (e.shiftKey) keys.push('shift');
                if (e.altKey) keys.push('alt');
                if (!['Control', 'Shift', 'Alt', 'Meta', ' '].includes(e.key)) {
                    keys.push(e.key.toLowerCase());
                }
                if(keys.length > 0) {
                    const shortcutStr = keys.join('+');
                    input.value = shortcutStr;
                    state.settings[settingKey] = shortcutStr;
                }
            });
        };
        // 快捷键输入框已移除，现在都在快捷键配置面板中配置
    }
    
    // 快捷键配置功能
    function setupShortcutConfiguration() {
        // 快捷键配置按钮事件
        dom.shortcutConfigBtn.addEventListener('click', showShortcutModal);
        
        // 关闭按钮事件
        dom.shortcutModalCloseBtn.addEventListener('click', hideShortcutModal);
        dom.shortcutModalBackdrop.addEventListener('click', (e) => {
            if (e.target === dom.shortcutModalBackdrop) {
                hideShortcutModal();
            }
        });
        
        // 重置和保存按钮事件
        dom.shortcutResetBtn.addEventListener('click', resetShortcutsToDefault);
        dom.shortcutSaveBtn.addEventListener('click', saveShortcutConfiguration);
        
        // ESC键关闭模态框
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && dom.shortcutModalBackdrop.style.display === 'flex') {
                hideShortcutModal();
            }
        });
    }
    
    function showShortcutModal() {
        populateShortcutConfiguration();
        dom.shortcutModalBackdrop.style.display = 'flex';
    }
    
    function hideShortcutModal() {
        dom.shortcutModalBackdrop.style.display = 'none';
    }
    
    function populateShortcutConfiguration() {
        const shortcuts = [
            // 文件操作
            { name: '保存', key: 'saveShortcut', description: '保存当前画布', defaultValue: 'ctrl+s' },
            { name: '另存', key: 'saveAsShortcut', description: '另存为新文件', defaultValue: 'ctrl+shift+s' },
            { name: '加载', key: 'loadShortcut', description: '加载文件', defaultValue: 'ctrl+o' },
            { name: '历史', key: 'historyShortcut', description: '显示历史记录', defaultValue: 'ctrl+h' },
            
            // 编辑操作
            { name: '复制', key: 'copyShortcut', description: '复制选中的节点', defaultValue: 'ctrl+c' },
            { name: '剪切', key: 'cutShortcut', description: '剪切选中的节点', defaultValue: 'ctrl+x' },
            { name: '删除', key: 'deleteShortcut', description: '删除选中的节点', defaultValue: 'delete' },
            { name: '撤销', key: 'undoShortcut', description: '撤销上一步操作', defaultValue: 'ctrl+z' },
            { name: '重做', key: 'redoShortcut', description: '重做操作', defaultValue: 'ctrl+y' },
            { name: '全选', key: 'selectAllShortcut', description: '选择所有节点', defaultValue: 'ctrl+a' },
            
            // 节点操作
            { name: '打组', key: 'createGroupShortcut', description: '将选中节点创建为组', defaultValue: 'ctrl+g' },
            { name: '转为集', key: 'convertNodeSetShortcut', description: '转换为节点集', defaultValue: 'ctrl+q' },
            { name: '进入集', key: 'enterNodeSetShortcut', description: '进入选中的节点集', defaultValue: 'q' },
            
            // 对齐操作
            { name: '左对齐', key: 'alignLeftShortcut', description: '选中节点左对齐', defaultValue: 'ctrl+arrowleft' },
            { name: '右对齐', key: 'alignRightShortcut', description: '选中节点右对齐', defaultValue: 'ctrl+arrowright' },
            { name: '上对齐', key: 'alignTopShortcut', description: '选中节点上对齐', defaultValue: 'ctrl+arrowup' },
            { name: '下对齐', key: 'alignBottomShortcut', description: '选中节点下对齐', defaultValue: 'ctrl+arrowdown' },
            
            // 功能切换
            { name: '吸附', key: 'snapShortcut', description: '开启/关闭网格吸附功能' },
            { name: '磁吸', key: 'magneticShortcut', description: '开启/关闭节点磁吸效果' },
            { name: '碰撞', key: 'collisionShortcut', description: '开启/关闭节点碰撞检测' },
            { name: '推动', key: 'pushShortcut', description: '开启/关闭节点推动模式' },
            { name: '插入', key: 'insertShortcut', description: '开启/关闭智能插入模式' },
            { name: '聚焦', key: 'focusShortcut', description: '聚焦到选中的节点' }
        ];
        
        dom.shortcutConfigContent.innerHTML = '';
        
        shortcuts.forEach(shortcut => {
            const item = document.createElement('div');
            item.className = 'shortcut-config-item';
            
            const currentValue = state.settings[shortcut.key] || shortcut.defaultValue || '';
            const keys = currentValue.toLowerCase().split('+').filter(k => k);
            
            // 解析修饰键和主键
            const hasCtrl = keys.includes('ctrl');
            const hasShift = keys.includes('shift');
            const hasAlt = keys.includes('alt');
            const mainKey = keys.find(k => !['ctrl', 'shift', 'alt'].includes(k)) || '';
            
            item.innerHTML = `
                <div class="shortcut-function-name">
                    <div style="font-weight: 500;">${shortcut.name}</div>
                </div>
                <div class="shortcut-inputs-new">
                    <div class="modifier-switches">
                        <div class="modifier-switch ${hasCtrl ? 'active' : ''}" data-key="${shortcut.key}" data-modifier="ctrl">
                            <span class="switch-label">Ctrl</span>
                            <div class="switch-toggle">
                                <div class="switch-slider"></div>
                            </div>
                        </div>
                        <div class="modifier-switch ${hasShift ? 'active' : ''}" data-key="${shortcut.key}" data-modifier="shift">
                            <span class="switch-label">Shift</span>
                            <div class="switch-toggle">
                                <div class="switch-slider"></div>
                            </div>
                        </div>
                        <div class="modifier-switch ${hasAlt ? 'active' : ''}" data-key="${shortcut.key}" data-modifier="alt">
                            <span class="switch-label">Alt</span>
                            <div class="switch-toggle">
                                <div class="switch-slider"></div>
                            </div>
                        </div>
                    </div>
                    <div class="main-key-input">
                        <label class="key-label" for="shortcut-${shortcut.key}">Key:</label>
                        <input type="text" id="shortcut-${shortcut.key}" class="shortcut-main-input" data-key="${shortcut.key}" value="${convertArrowKeyDisplay(mainKey)}" placeholder="按键" readonly>
                    </div>
                </div>
            `;
            
            dom.shortcutConfigContent.appendChild(item);
        });
        
        // 为修饰键开关添加事件监听器
        document.querySelectorAll('.modifier-switch').forEach(switchEl => {
            switchEl.addEventListener('click', handleModifierSwitch);
        });
        
        // 为主键输入框添加事件监听器
        document.querySelectorAll('.shortcut-main-input').forEach(input => {
            input.addEventListener('keydown', handleMainKeyInput);
            input.addEventListener('focus', () => {
                input.style.backgroundColor = 'var(--btn-inactive)';
            });
            input.addEventListener('blur', () => {
                input.style.backgroundColor = 'var(--input-bg)';
            });
        });
    }
    
    // 转换方向键显示
    function convertArrowKeyDisplay(keyValue) {
        const arrowKeyMap = {
            'arrowup': '↑',
            'arrowdown': '↓',
            'arrowleft': '←',
            'arrowright': '→'
        };
        return arrowKeyMap[keyValue] || keyValue;
    }
    
    // 转换方向键回原始值（用于保存）
    function convertArrowKeyToOriginal(displayValue) {
        const reverseArrowKeyMap = {
            '↑': 'arrowup',
            '↓': 'arrowdown',
            '←': 'arrowleft',
            '→': 'arrowright'
        };
        return reverseArrowKeyMap[displayValue] || displayValue;
    }

    function handleModifierSwitch(e) {
        const switchEl = e.currentTarget;
        const key = switchEl.dataset.key;
        const modifier = switchEl.dataset.modifier;
        
        // 切换开关状态
        switchEl.classList.toggle('active');
        
        // 更新快捷键值
        updateNewShortcutValue(key);
    }
    
    function handleMainKeyInput(e) {
        e.preventDefault();
        const input = e.target;
        const key = input.dataset.key;
        
        // 清空输入
        if (e.key === 'Delete' || e.key === 'Backspace') {
            input.value = '';
            updateNewShortcutValue(key);
            return;
        }
        
        // 处理空格键
        if (e.key === ' ') {
            input.value = 'space';
            updateNewShortcutValue(key);
            return;
        }
        
        // 忽略修饰键单独按下
        if (['Control', 'Shift', 'Alt', 'Meta'].includes(e.key)) {
            return;
        }
        
        // 设置主键值
        let keyValue = e.key.toLowerCase();
        
        // 处理特殊键名
        const keyMap = {
            'arrowup': 'arrowup',
            'arrowdown': 'arrowdown',
            'arrowleft': 'arrowleft',
            'arrowright': 'arrowright',
            'escape': 'escape',
            'enter': 'enter',
            'tab': 'tab'
        };
        
        if (keyMap[keyValue]) {
            keyValue = keyMap[keyValue];
        }
        
        // 显示转换后的方向键符号
        input.value = convertArrowKeyDisplay(keyValue);
        updateNewShortcutValue(key);
    }
    
    function updateNewShortcutValue(key) {
        // 获取修饰键状态
        const modifierSwitches = document.querySelectorAll(`[data-key="${key}"][data-modifier]`);
        const mainInput = document.querySelector(`[data-key="${key}"].shortcut-main-input`);
        
        let shortcutParts = [];
        
        // 添加修饰键
        modifierSwitches.forEach(switchEl => {
            if (switchEl.classList.contains('active')) {
                shortcutParts.push(switchEl.dataset.modifier);
            }
        });
        
        // 添加主键
        if (mainInput && mainInput.value.trim()) {
            // 将显示的箭头符号转换回原始值
            const originalKey = convertArrowKeyToOriginal(mainInput.value.trim());
            shortcutParts.push(originalKey);
        }
        
        const shortcutValue = shortcutParts.join('+');
        
        // 临时更新（不保存到设置中）
        const tempSettings = { ...state.settings };
        tempSettings[key] = shortcutValue;
    }
    
    // 初始化快捷键配置（从 localStorage 加载或使用默认值）
    async function initializeShortcuts() {
        const defaultShortcuts = {
            // 文件操作
            saveShortcut: 'ctrl+s',
            saveAsShortcut: 'ctrl+shift+s',
            loadShortcut: 'ctrl+o',
            historyShortcut: 'ctrl+h',
            
            // 编辑操作
            copyShortcut: 'ctrl+c',
            cutShortcut: 'ctrl+x',
            deleteShortcut: 'delete',
            undoShortcut: 'ctrl+z',
            redoShortcut: 'ctrl+y',
            selectAllShortcut: 'ctrl+a',
            
            // 节点操作
            createGroupShortcut: 'ctrl+g',
            convertNodeSetShortcut: 'ctrl+q',
            enterNodeSetShortcut: 'q',
            
            // 对齐操作
            alignLeftShortcut: 'ctrl+arrowleft',
            alignRightShortcut: 'ctrl+arrowright',
            alignTopShortcut: 'ctrl+arrowup',
            alignBottomShortcut: 'ctrl+arrowdown',
            
            // 功能切换
            snapShortcut: '',
            magneticShortcut: '',
            collisionShortcut: '',
            pushShortcut: '',
            insertShortcut: 'i',
            focusShortcut: 'space'
        };
        
        // 尝试从 IndexedDB 加载快捷键配置
        try {
            const savedShortcuts = await dbStorage.load('shortcutConfiguration', dbStorage.storeNames.shortcutConfiguration);
            if (savedShortcuts) {
                // 合并保存的配置和默认配置（确保所有快捷键都有值）
                Object.keys(defaultShortcuts).forEach(key => {
                    state.settings[key] = savedShortcuts[key] !== undefined ? savedShortcuts[key] : defaultShortcuts[key];
                });
            } else {
                // 使用默认配置
                Object.keys(defaultShortcuts).forEach(key => {
                    state.settings[key] = defaultShortcuts[key];
                });
            }
        } catch (error) {
            // 出错时使用默认配置
            Object.keys(defaultShortcuts).forEach(key => {
                state.settings[key] = defaultShortcuts[key];
            });
        }
        


    }

    function resetShortcutsToDefault() {
        const defaultShortcuts = {
            // 文件操作
            saveShortcut: 'ctrl+s',
            saveAsShortcut: 'ctrl+shift+s',
            loadShortcut: 'ctrl+o',
            historyShortcut: 'ctrl+h',
            
            // 编辑操作
            copyShortcut: 'ctrl+c',
            cutShortcut: 'ctrl+x',
            deleteShortcut: 'delete',
            undoShortcut: 'ctrl+z',
            redoShortcut: 'ctrl+y',
            selectAllShortcut: 'ctrl+a',
            
            // 节点操作
            createGroupShortcut: 'ctrl+g',
            convertNodeSetShortcut: 'ctrl+q',
            enterNodeSetShortcut: 'q',
            
            // 对齐操作
            alignLeftShortcut: 'ctrl+arrowleft',
            alignRightShortcut: 'ctrl+arrowright',
            alignTopShortcut: 'ctrl+arrowup',
            alignBottomShortcut: 'ctrl+arrowdown',
            
            // 功能切换
            snapShortcut: '',
            magneticShortcut: '',
            collisionShortcut: '',
            pushShortcut: '',
            insertShortcut: 'i',
            focusShortcut: 'space'
        };
        
        Object.keys(defaultShortcuts).forEach(key => {
            state.settings[key] = defaultShortcuts[key];
        });
        if (dom.snapShortcutInput) dom.snapShortcutInput.value = defaultShortcuts.snapShortcut;
        if (dom.magneticShortcutInput) dom.magneticShortcutInput.value = defaultShortcuts.magneticShortcut;
        if (dom.collisionShortcutInput) dom.collisionShortcutInput.value = defaultShortcuts.collisionShortcut;
        if (dom.pushShortcutInput) dom.pushShortcutInput.value = defaultShortcuts.pushShortcut;
        if (dom.insertShortcutInput) dom.insertShortcutInput.value = defaultShortcuts.insertShortcut;
        if (dom.focusShortcutInput) dom.focusShortcutInput.value = defaultShortcuts.focusShortcut;
        
        // 重新填充配置面板
        populateShortcutConfiguration();
        
        setStateDirty();
    }
    
    function saveShortcutConfiguration() {
        // 收集所有快捷键配置
        const shortcuts = [
            'saveShortcut', 'saveAsShortcut', 'loadShortcut', 'historyShortcut',
            'copyShortcut', 'cutShortcut', 'deleteShortcut', 
            'undoShortcut', 'redoShortcut', 'selectAllShortcut',
            'createGroupShortcut', 'convertNodeSetShortcut', 'enterNodeSetShortcut',
            'alignLeftShortcut', 'alignRightShortcut', 'alignTopShortcut', 'alignBottomShortcut',
            'snapShortcut', 'magneticShortcut', 'collisionShortcut', 'pushShortcut', 'insertShortcut', 'focusShortcut'
        ];
        
        shortcuts.forEach(key => {
            // 获取修饰键状态
            const modifierSwitches = document.querySelectorAll(`[data-key="${key}"][data-modifier]`);
            const mainInput = document.querySelector(`[data-key="${key}"].shortcut-main-input`);
            
            let shortcutParts = [];
            
            // 添加修饰键
            modifierSwitches.forEach(switchEl => {
                if (switchEl.classList.contains('active')) {
                    shortcutParts.push(switchEl.dataset.modifier);
                }
            });
            
            // 添加主键
            if (mainInput && mainInput.value.trim()) {
                // 将显示的箭头符号转换回原始值
                const originalKey = convertArrowKeyToOriginal(mainInput.value.trim());
                shortcutParts.push(originalKey);
            }
            
            const shortcutValue = shortcutParts.join('+');
            state.settings[key] = shortcutValue;
            
            // 同步更新原有的快捷键输入框（如果存在）
            const originalInput = document.getElementById(key.replace('Shortcut', '-shortcut'));
            if (originalInput) {
                originalInput.value = shortcutValue;
            }
        });
        
        // 保存到 IndexedDB
        try {
            const shortcutConfig = {};
            shortcuts.forEach(key => {
                shortcutConfig[key] = state.settings[key];
            });
            dbStorage.save('shortcutConfiguration', shortcutConfig, dbStorage.storeNames.shortcutConfiguration);
        } catch (error) {
            // 保存快捷键配置失败
        }
        
        setStateDirty();
        hideShortcutModal();
        
        // 显示保存成功提示
        showPermissionError('快捷键配置已保存');
    }
    
    function setupToggleButtons() {
        const createToggle = (btn, settingKey, action) => {
            if (state.settings[settingKey]) {
                btn.classList.add('active');
            }
            btn.addEventListener('click', () => {
                state.settings[settingKey] = !state.settings[settingKey];
                btn.classList.toggle('active');
                if (action) action();
                setStateDirty();
            });
        };

        createToggle(dom.gridToggleBtn, 'showGrid');
        createToggle(dom.snapToggleBtn, 'snapToGrid');
        createToggle(dom.magneticToggleBtn, 'magneticNodes', updateMagneticGroups);
        createToggle(dom.collisionToggleBtn, 'collisionDetection');
        createToggle(dom.pushToggleBtn, 'pushMode');
        createToggle(dom.insertToggleBtn, 'insertMode');
        

    }

    // ===================================================================================
    // THEME SWITCHER LOGIC
    // ===================================================================================

    let highlightedThemeIndex = -1;
    let activeTheme = null;

    const themes = [
        { category: "默认主题" },
        { name: "默认主题", colors: { menuBarBg: "#FFFFFF", nodeBg: "#C0CCD8", nodeText: "#FFFFFF", group: "#CFCFCF", canvas: "#F3F4F6", grid: "#E5E7EB", inputBg: "#F9FAFB", btnActive: "#F5F5F5", btnInactive: "#D2D5DB", toggleOn: "#8BC34A", toggleOff: "#ABABAB", textColor: "#111827", toggleTextColor: "#FFFFFF", clearBtn: "#DB5247" } },

{
  "name": "夜晚深色",
  "colors": {
    "menuBarBg": "#1A1A1A",       // 顶部菜单栏
    "nodeBg": "#242424",          // 节点背景
    "nodeText": "#9E9E9E",        // 节点文字
    "group": "#303030",           // 分组背景
    "canvas": "#121212",          // 画布背景
    "grid": "#1E1E1E",            // 网格线
    "inputBg": "#1E1E1E",         // 输入框背景
    "btnActive": "#2E2E2E",       // 激活按钮（极低饱和淡绿）
    "btnInactive": "#1A1A1A",     // 按钮未激活态
    "toggleOn": "#336d2c",        // 开关开启（纯灰）
    "toggleOff": "#3A3A3A",       // 开关关闭
    "textColor": "#9E9E9E",       // 普通文字
    "toggleTextColor": "#9E9E9E", // 开关文字
    "clearBtn": "#5f3735"         // 清除按钮（极低饱和淡红）
  }
},

        { category: "原创精选主题" },
        { name: "1午夜黑红", colors: { menuBarBg: "#2C2C2C", nodeBg: "#E74C3C", nodeText: "#FFFFFF", group: "#FFFFFF", canvas: "#1E1E1E", grid: "#3A3A3A", inputBg: "#3A3A3A", btnActive: "#E74C3C", btnInactive: "#5A5A5A", toggleOn: "#E74C3C", toggleOff: "#555555", textColor: "#EAEAEA", clearBtn: "#E74C3C" } },
        { name: "2商务深蓝", colors: { menuBarBg: "#212C3D", nodeBg: "#3498DB", nodeText: "#FFFFFF", group: "#3498DB", canvas: "#1A222F", grid: "#333E4F", inputBg: "#1A222F", btnActive: "#3498DB", btnInactive: "#4A5568", toggleOn: "#3498DB", toggleOff: "#5A6578", textColor: "#E2E8F0", clearBtn: "#E53935" } },
        { name: "3石墨灰金", colors: { menuBarBg: "#333333", nodeBg: "#D4AC0D", nodeText: "#2B2B2B", group: "#D4AC0D", canvas: "#2B2B2B", grid: "#444444", inputBg: "#2B2B2B", btnActive: "#D4AC0D", btnInactive: "#555555", toggleOn: "#D4AC0D", toggleOff: "#616161", textColor: "#F5F5F5", clearBtn: "#E4572E" } },
        { name: "4复古棕褐", colors: { menuBarBg: "#4A413A", nodeBg: "#D5C6B1", nodeText: "#3E352F", group: "#D5C6B1", canvas: "#3E352F", grid: "#5A514A", inputBg: "#3E352F", btnActive: "#A1887F", btnInactive: "#6D4C41", toggleOn: "#A1887F", toggleOff: "#5D4037", textColor: "#D5C6B1", clearBtn: "#C62828" } },
        { name: "5暗夜罗兰", colors: { menuBarBg: "#2C2A3E", nodeBg: "#9B59B6", nodeText: "#FFFFFF", group: "#FFFFFF", canvas: "#211F30", grid: "#3E3C50", inputBg: "#211F30", btnActive: "#9B59B6", btnInactive: "#4A466D", toggleOn: "#9B59B6", toggleOff: "#5B587A", textColor: "#EDE7F6", clearBtn: "#EF476F" } },
        { name: "6深海幽绿", colors: { menuBarBg: "#1E3A3A", nodeBg: "#1ABC9C", nodeText: "#142C2C", group: "#1ABC9C", canvas: "#142C2C", grid: "#2E4A4A", inputBg: "#142C2C", btnActive: "#1ABC9C", btnInactive: "#2E4A4A", toggleOn: "#1ABC9C", toggleOff: "#3C6464", textColor: "#B2DFDB", clearBtn: "#F05D5E" } },
        { name: "7科技蓝黑", colors: { menuBarBg: "#0D1117", nodeBg: "#3081F7", nodeText: "#FFFFFF", group: "#3081F7", canvas: "#010409", grid: "#21262D", inputBg: "#21262D", btnActive: "#3081F7", btnInactive: "#30363D", toggleOn: "#3081F7", toggleOff: "#30363D", textColor: "#C9D1D9", clearBtn: "#DA3633" } },
        { name: "8碳素纤维", colors: { menuBarBg: "#222222", nodeBg: "#4F4F4F", nodeText: "#EAEAEA", group: "#FFFFFF", canvas: "#1C1C1C", grid: "#353535", inputBg: "#353535", btnActive: "#4F4F4F", btnInactive: "#3A3A3A", toggleOn: "#616161", toggleOff: "#3A3A3A", textColor: "#E0E0E0", clearBtn: "#B00020" } },
        { name: "9星空灰色", colors: { menuBarBg: "#4B4E6D", nodeBg: "#F2CC8F", nodeText: "#3D405B", group: "#F2CC8F", canvas: "#3D405B", grid: "#5C5F7E", inputBg: "#3D405B", btnActive: "#8D99AE", btnInactive: "#5C5F7E", toggleOn: "#8D99AE", toggleOff: "#5C5F7E", textColor: "#EDF2F4", clearBtn: "#D90429" } },
        { name: "10熔岩橙色", colors: { menuBarBg: "#3D1B13", nodeBg: "#F39C12", nodeText: "#FFFFFF", group: "#F39C12", canvas: "#2E140D", grid: "#4D2C21", inputBg: "#4D2C21", btnActive: "#F39C12", btnInactive: "#5A382E", toggleOn: "#F39C12", toggleOff: "#5A382E", textColor: "#FFE0B2", clearBtn: "#D9534F" } },
        { name: "11经典白板", colors: { menuBarBg: "#F5F5F5", nodeBg: "#4A90E2", nodeText: "#FFFFFF", group: "#4A90E2", canvas: "#FFFFFF", grid: "#EAEAEA", inputBg: "#FFFFFF", btnActive: "#4A90E2", btnInactive: "#BDBDBD", toggleOn: "#4A90E2", toggleOff: "#BDBDBD", textColor: "#212121", clearBtn: "#E53935" } },
        { name: "12米白信纸", colors: { menuBarBg: "#FDFBF6", nodeBg: "#7D6E60", nodeText: "#FDFBF6", group: "#7D6E60", canvas: "#F8F5F0", grid: "#EFEBE4", inputBg: "#F8F5F0", btnActive: "#7D6E60", btnInactive: "#D7CCC8", toggleOn: "#7D6E60", toggleOff: "#D7CCC8", textColor: "#5D4037", clearBtn: "#A13333" } },
        { name: "13清新薄荷", colors: { menuBarBg: "#F0FDF4", nodeBg: "#2ECC71", nodeText: "#FFFFFF", group: "#2ECC71", canvas: "#F7FEFA", grid: "#E6F4EA", inputBg: "#FFFFFF", btnActive: "#2ECC71", btnInactive: "#C8E6C9", toggleOn: "#2ECC71", toggleOff: "#BDBDBD", textColor: "#1B5E20", clearBtn: "#EF5350" } },
        { name: "14淡雅灰调", colors: { menuBarBg: "#EAECEE", nodeBg: "#5D6D7E", nodeText: "#FFFFFF", group: "#5D6D7E", canvas: "#F4F6F7", grid: "#D5DBDB", inputBg: "#FFFFFF", btnActive: "#5D6D7E", btnInactive: "#CFD8DC", toggleOn: "#5D6D7E", toggleOff: "#CFD8DC", textColor: "#263238", clearBtn: "#D32F2F" } },
        { name: "15柔和粉彩", colors: { menuBarBg: "#FFF0F5", nodeBg: "#F08080", nodeText: "#FFFFFF", group: "#F08080", canvas: "#FFF6F9", grid: "#FEEAF0", inputBg: "#FFFFFF", btnActive: "#F08080", btnInactive: "#FFCDD2", toggleOn: "#F08080", toggleOff: "#E1E1E1", textColor: "#5D4037", clearBtn: "#E91E63" } },
        { name: "16天青蓝色", colors: { menuBarBg: "#EBF5FB", nodeBg: "#5DADE2", nodeText: "#FFFFFF", group: "#5DADE2", canvas: "#F2F8FC", grid: "#D6EAF8", inputBg: "#FFFFFF", btnActive: "#5DADE2", btnInactive: "#BEE0F5", toggleOn: "#5DADE2", toggleOff: "#CFD8DC", textColor: "#0D47A1", clearBtn: "#E53935" } },
        { name: "17极简主义", colors: { menuBarBg: "#FAFAFA", nodeBg: "#212121", nodeText: "#FFFFFF", group: "#BDBDBD", canvas: "#FFFFFF", grid: "#F0F0F0", inputBg: "#F0F0F0", btnActive: "#424242", btnInactive: "#E0E0E0", toggleOn: "#424242", toggleOff: "#E0E0E0", textColor: "#212121", clearBtn: "#D32F2F" } },
        { name: "18原木自然", colors: { menuBarBg: "#F3EFE9", nodeBg: "#8D6E63", nodeText: "#FFFFFF", group: "#8D6E63", canvas: "#F9F6F1", grid: "#EAE3D9", inputBg: "#F9F6F1", btnActive: "#8D6E63", btnInactive: "#D7CCC8", toggleOn: "#8D6E63", toggleOff: "#D7CCC8", textColor: "#4E342E", clearBtn: "#BF360C" } },
        { name: "19薰衣草紫", colors: { menuBarBg: "#F3EFFF", nodeBg: "#9575CD", nodeText: "#FFFFFF", group: "#9575CD", canvas: "#F8F4FF", grid: "#EADDFF", inputBg: "#EDE7F6", btnActive: "#9575CD", btnInactive: "#D1C4E9", toggleOn: "#9575CD", toggleOff: "#D1C4E9", textColor: "#311B92", clearBtn: "#D81B60" } },
        { name: "20温暖杏色", colors: { menuBarBg: "#FFF3E0", nodeBg: "#FFA726", nodeText: "#FFFFFF", group: "#FFA726", canvas: "#FFFAF0", grid: "#FFEBCD", inputBg: "#FFF8E1", btnActive: "#FFA726", btnInactive: "#FFCC80", toggleOn: "#FFA726", toggleOff: "#FFCC80", textColor: "#E65100", clearBtn: "#E53935" } },
        { name: "21珊瑚橙色", colors: { menuBarBg: "#FBEAE5", nodeBg: "#FF6F61", nodeText: "#FFFFFF", group: "#FF6F61", canvas: "#FEF5F3", grid: "#FADCD3", inputBg: "#FEF5F3", btnActive: "#FF6F61", btnInactive: "#FFAB91", toggleOn: "#FF6F61", toggleOff: "#FFCCBC", textColor: "#BF360C", clearBtn: "#FF6F61" } },
        { name: "22宁静蓝绿", colors: { menuBarBg: "#E0F2F1", nodeBg: "#00897B", nodeText: "#FFFFFF", group: "#00897B", canvas: "#E8F5F5", grid: "#B2DFDB", inputBg: "#B2DFDB", btnActive: "#00897B", btnInactive: "#A7C4C2", toggleOn: "#00897B", toggleOff: "#B2DFDB", textColor: "#004D40", clearBtn: "#D32F2F" } },
        { name: "23复古报纸", colors: { menuBarBg: "#EFEBE2", nodeBg: "#BF360C", nodeText: "#F5F1E9", group: "#BF360C", canvas: "#F5F1E9", grid: "#E3DCD0", inputBg: "#F5F1E9", btnActive: "#A1887F", btnInactive: "#D7CCC8", toggleOn: "#A1887F", toggleOff: "#D7CCC8", textColor: "#3E2723", clearBtn: "#BF360C" } },
        { name: "24莫兰迪色", colors: { menuBarBg: "#D4D8E3", nodeBg: "#8791B3", nodeText: "#FFFFFF", group: "#8791B3", canvas: "#E8E9F0", grid: "#C9CDD8", inputBg: "#E8E9F0", btnActive: "#8791B3", btnInactive: "#C5CAE9", toggleOn: "#8791B3", toggleOff: "#C5CAE9", textColor: "#2A3B57", clearBtn: "#C94C4C" } },
        { name: "25抹茶拿铁", colors: { menuBarBg: "#F1F8E9", nodeBg: "#7CB342", nodeText: "#FFFFFF", group: "#7CB342", canvas: "#F5F9F1", grid: "#E3EDD8", inputBg: "#DCEDC8", btnActive: "#7CB342", btnInactive: "#C5E1A5", toggleOn: "#7CB342", toggleOff: "#C5E1A5", textColor: "#33691E", clearBtn: "#E53935" } },
        { name: "26璀璨宝石", colors: { menuBarBg: "#2C3E50", nodeBg: "#E67E22", nodeText: "#FFFFFF", group: "#E67E22", canvas: "#212F3D", grid: "#3E5369", inputBg: "#34495E", btnActive: "#E67E22", btnInactive: "#536979", toggleOn: "#E67E22", toggleOff: "#536979", textColor: "#ECF0F1", clearBtn: "#E74C3C" } },
        { name: "27日落余晖", colors: { menuBarBg: "#5D3A4B", nodeBg: "#FAD02E", nodeText: "#4E2F3E", group: "#FAD02E", canvas: "#4E2F3E", grid: "#6B4759", inputBg: "#4E2F3E", btnActive: "#B49A5A", btnInactive: "#6B4759", toggleOn: "#B49A5A", toggleOff: "#6B4759", textColor: "#FCE4EC", clearBtn: "#C24949" } },
        { name: "28青花瓷色", colors: { menuBarBg: "#EDF2F8", nodeBg: "#2962FF", nodeText: "#FFFFFF", group: "#2962FF", canvas: "#F4F7FA", grid: "#E3E9F1", inputBg: "#FFFFFF", btnActive: "#2962FF", btnInactive: "#B3E5FC", toggleOn: "#2962FF", toggleOff: "#CFD8DC", textColor: "#0D47A1", clearBtn: "#D50000" } },
        { name: "29秋日枫叶", colors: { menuBarBg: "#FBE9E7", nodeBg: "#D84315", nodeText: "#FFFFFF", group: "#D84315", canvas: "#FDF3F1", grid: "#F8D8D3", inputBg: "#FFFAF9", btnActive: "#D84315", btnInactive: "#FFCCBC", toggleOn: "#D84315", toggleOff: "#FFCCBC", textColor: "#BF360C", clearBtn: "#D84315" } },
        { name: "30柔和彩虹", colors: { menuBarBg: "#E1F5FE", nodeBg: "#FF8A80", nodeText: "#FFFFFF", group: "#FF8A80", canvas: "#EBF8FF", grid: "#D0EBFA", inputBg: "#FFFFFF", btnActive: "#81D4FA", btnInactive: "#B3E5FC", toggleOn: "#81D4FA", toggleOff: "#B3E5FC", textColor: "#01579B", clearBtn: "#FF8A80" } },
        { category: "表格提供主题" },
        { name: "31经典红色", colors: { menuBarBg: "#37474F", nodeBg: "#FFFFFF", nodeText: "#212121", group: "#E53935", canvas: "#FAFAFA", grid: "#EEEEEE", inputBg: "#455A64", btnActive: "#607D8B", btnInactive: "#546E7A", toggleOn: "#607D8B", toggleOff: "#546E7A", textColor: "#ECEFF1", clearBtn: "#E53935" } },
        { name: "32大地棕色", colors: { menuBarBg: "#5D4037", nodeBg: "#FFECB3", nodeText: "#3E2723", group: "#6D4C41", canvas: "#FFF8E1", grid: "#FFE082", inputBg: "#6D4C41", btnActive: "#8D6E63", btnInactive: "#795548", toggleOn: "#8D6E63", toggleOff: "#795548", textColor: "#D7CCC8", clearBtn: "#BF360C" } },
        { name: "33中性米色", colors: { menuBarBg: "#757575", nodeBg: "#FAFAFA", nodeText: "#424242", group: "#BDBDBD", canvas: "#F5F5F5", grid: "#E0E0E0", inputBg: "#9E9E9E", btnActive: "#BDBDBD", btnInactive: "#9E9E9E", toggleOn: "#BDBDBD", toggleOff: "#9E9E9E", textColor: "#FFFFFF", clearBtn: "#EF5350" } },
        { name: "34现代灰色", colors: { menuBarBg: "#424242", nodeBg: "#EEEEEE", nodeText: "#212121", group: "#757575", canvas: "#212121", grid: "#424242", inputBg: "#212121", btnActive: "#757575", btnInactive: "#616161", toggleOn: "#757575", toggleOff: "#616161", textColor: "#E0E0E0", clearBtn: "#D32F2F" } },
        { name: "35深红紫色", colors: { menuBarBg: "#311B92", nodeBg: "#EDE7F6", nodeText: "#4527A0", group: "#D32F2F", canvas: "#EDE7F6", grid: "#D1C4E9", inputBg: "#512DA8", btnActive: "#7E57C2", btnInactive: "#5E35B1", toggleOn: "#7E57C2", toggleOff: "#5E35B1", textColor: "#D1C4E9", clearBtn: "#D32F2F" } },
        { name: "36柔和粉色", colors: { menuBarBg: "#880E4F", nodeBg: "#FCE4EC", nodeText: "#560027", group: "#EC407A", canvas: "#F3E5F5", grid: "#E1BEE7", inputBg: "#AD1457", btnActive: "#D81B60", btnInactive: "#C2185B", toggleOn: "#D81B60", toggleOff: "#C2185B", textColor: "#F8BBD0", clearBtn: "#EC407A" } },
        { name: "37经典纯黑", colors: { menuBarBg: "#212121", nodeBg: "#424242", nodeText: "#FFFFFF", group: "#000000", canvas: "#121212", grid: "#212121", inputBg: "#000000", btnActive: "#424242", btnInactive: "#313131", toggleOn: "#424242", toggleOff: "#313131", textColor: "#BDBDBD", clearBtn: "#B00020" } },
        { name: "38活力红色", colors: { menuBarBg: "#B71C1C", nodeBg: "#FFEBEE", nodeText: "#7B1FA2", group: "#F44336", canvas: "#FFEBEE", grid: "#EF9A9A", inputBg: "#D32F2F", btnActive: "#F44336", btnInactive: "#E53935", toggleOn: "#F44336", toggleOff: "#E53935", textColor: "#FFCDD2", clearBtn: "#F44336" } },
        { name: "39经典冷灰", colors: { menuBarBg: "#455A64", nodeBg: "#CFD8DC", nodeText: "#263238", group: "#78909C", canvas: "#ECEFF1", grid: "#CFD8DC", inputBg: "#546E7A", btnActive: "#78909C", btnInactive: "#607D8B", toggleOn: "#78909C", toggleOff: "#607D8B", textColor: "#CFD8DC", clearBtn: "#D32F2F" } },
        { name: "40海洋蓝色", colors: { menuBarBg: "#1565C0", nodeBg: "#E3F2FD", nodeText: "#0D47A1", group: "#2196F3", canvas: "#E8F5E9", grid: "#BBDEFB", inputBg: "#1976D2", btnActive: "#2196F3", btnInactive: "#1E88E5", toggleOn: "#2196F3", toggleOff: "#1E88E5", textColor: "#BBDEFB", clearBtn: "#E53935" } },
        { name: "41森林绿色", colors: { menuBarBg: "#2E7D32", nodeBg: "#E8F5E9", nodeText: "#1B5E20", group: "#4CAF50", canvas: "#F1F8E9", grid: "#DCEDC8", inputBg: "#388E3C", btnActive: "#4CAF50", btnInactive: "#43A047", toggleOn: "#4CAF50", toggleOff: "#43A047", textColor: "#C8E6C9", clearBtn: "#D32F2F" } },
        { name: "42神秘紫色", colors: { menuBarBg: "#4527A0", nodeBg: "#EDE7F6", nodeText: "#311B92", group: "#673AB7", canvas: "#F3E5F5", grid: "#E1BEE7", inputBg: "#512DA8", btnActive: "#673AB7", btnInactive: "#5E35B1", toggleOn: "#673AB7", toggleOff: "#5E35B1", textColor: "#D1C4E9", clearBtn: "#C2185B" } },
        { name: "43经典深绿", colors: { menuBarBg: "#1B5E20", nodeBg: "#DCEDC8", nodeText: "#33691E", group: "#388E3C", canvas: "#F1F8E9", grid: "#C5E1A5", inputBg: "#2E7D32", btnActive: "#388E3C", btnInactive: "#2E7D32", toggleOn: "#388E3C", toggleOff: "#2E7D32", textColor: "#A5D6A7", clearBtn: "#E65100" } },
        { name: "44经典亮白", colors: { menuBarBg: "#F5F5F5", nodeBg: "#FFFFFF", nodeText: "#212121", group: "#FAFAFA", canvas: "#FFFFFF", grid: "#F5F5F5", inputBg: "#EEEEEE", btnActive: "#2196F3", btnInactive: "#E0E0E0", toggleOn: "#2196F3", toggleOff: "#E0E0E0", textColor: "#424242", clearBtn: "#F44336" } },
        { name: "45经典深紫", colors: { menuBarBg: "#4A148C", nodeBg: "#F3E5F5", nodeText: "#6A1B9A", group: "#9C27B0", canvas: "#EDE7F6", grid: "#D1C4E9", inputBg: "#6A1B9A", btnActive: "#8E24AA", btnInactive: "#7B1FA2", toggleOn: "#8E24AA", toggleOff: "#7B1FA2", textColor: "#E1BEE7", clearBtn: "#D81B60" } },
        { name: "46经典亮蓝", colors: { menuBarBg: "#0277BD", nodeBg: "#E1F5FE", nodeText: "#01579B", group: "#03A9F4", canvas: "#E3F2FD", grid: "#B3E5FC", inputBg: "#0288D1", btnActive: "#03A9F4", btnInactive: "#039BE5", toggleOn: "#03A9F4", toggleOff: "#039BE5", textColor: "#B3E5FC", clearBtn: "#F44336" } },
        { name: "47经典亮粉", colors: { menuBarBg: "#AD1457", nodeBg: "#FCE4EC", nodeText: "#880E4F", group: "#E91E63", canvas: "#FFEBEE", grid: "#F8BBD0", inputBg: "#C2185B", btnActive: "#E91E63", btnInactive: "#D81B60", toggleOn: "#E91E63", toggleOff: "#D81B60", textColor: "#F8BBD0", clearBtn: "#E91E63" } },
        { name: "48清新青色", colors: { menuBarBg: "#00695C", nodeBg: "#E0F2F1", nodeText: "#004D40", group: "#009688", canvas: "#E0F7FA", grid: "#B2DFDB", inputBg: "#00796B", btnActive: "#009688", btnInactive: "#00897B", toggleOn: "#009688", toggleOff: "#00897B", textColor: "#B2DFDB", clearBtn: "#D32F2F" } },
        { name: "49酸橙绿色", colors: { menuBarBg: "#33691E", nodeBg: "#F9FBE7", nodeText: "#827717", group: "#8BC34A", canvas: "#F1F8E9", grid: "#DCEDC8", inputBg: "#558B2F", btnActive: "#7CB342", btnInactive: "#689F38", toggleOn: "#7CB342", toggleOff: "#689F38", textColor: "#DCEDC8", clearBtn: "#EF6C00" } },
        { name: "50经典靛蓝", colors: { menuBarBg: "#303F9F", nodeBg: "#E8EAF6", nodeText: "#1A237E", group: "#3F51B5", canvas: "#E8EAF6", grid: "#C5CAE9", inputBg: "#3949AB", btnActive: "#3F51B5", btnInactive: "#3949AB", toggleOn: "#3F51B5", toggleOff: "#3949AB", textColor: "#C5CAE9", clearBtn: "#D32F2F" } },
        { name: "51经典暗红", colors: { menuBarBg: "#C62828", nodeBg: "#EFEBE9", nodeText: "#B71C1C", group: "#F44336", canvas: "#EFEBE9", grid: "#D7CCC8", inputBg: "#B71C1C", btnActive: "#E53935", btnInactive: "#D32F2F", toggleOn: "#E53935", toggleOff: "#D32F2F", textColor: "#FFCDD2", clearBtn: "#F44336" } },
        { name: "52暖琥珀色", colors: { menuBarBg: "#EF6C00", nodeBg: "#FFF3E0", nodeText: "#E65100", group: "#FF9800", canvas: "#FFF8E1", grid: "#FFE082", inputBg: "#F57C00", btnActive: "#FF9800", btnInactive: "#FB8C00", toggleOn: "#FF9800", toggleOff: "#FB8C00", textColor: "#FFE0B2", clearBtn: "#D84315" } },
        { name: "53经典冷青", colors: { menuBarBg: "#0097A7", nodeBg: "#E0F7FA", nodeText: "#006064", group: "#00BCD4", canvas: "#E0F7FA", grid: "#B2EBF2", inputBg: "#00838F", btnActive: "#00BCD4", btnInactive: "#00ACC1", toggleOn: "#00BCD4", toggleOff: "#00ACC1", textColor: "#B2EBF2", clearBtn: "#E53935" } },
        { name: "54经典深棕", colors: { menuBarBg: "#4E342E", nodeBg: "#D7CCC8", nodeText: "#3E2723", group: "#795548", canvas: "#EFEBE9", grid: "#D7CCC8", inputBg: "#5D4037", btnActive: "#795548", btnInactive: "#6D4C41", toggleOn: "#795548", toggleOff: "#6D4C41", textColor: "#BCAAA4", clearBtn: "#BF360C" } },
        { name: "55经典浅灰", colors: { menuBarBg: "#616161", nodeBg: "#FAFAFA", nodeText: "#212121", group: "#9E9E9E", canvas: "#F5F5F5", grid: "#E0E0E0", inputBg: "#757575", btnActive: "#9E9E9E", btnInactive: "#757575", toggleOn: "#9E9E9E", toggleOff: "#757575", textColor: "#FAFAFA", clearBtn: "#D32F2F" } },
        { name: "56经典深蓝", colors: { menuBarBg: "#0D47A1", nodeBg: "#E3F2FD", nodeText: "#1A237E", group: "#2196F3", canvas: "#E8EAF6", grid: "#C5CAE9", inputBg: "#1976D2", btnActive: "#2196F3", btnInactive: "#1E88E5", toggleOn: "#2196F3", toggleOff: "#1E88E5", textColor: "#90CAF9", clearBtn: "#D50000" } },
        { name: "57经典青绿", colors: { menuBarBg: "#004D40", nodeBg: "#E0F2F1", nodeText: "#00695C", group: "#009688", canvas: "#E0F7FA", grid: "#B2DFDB", inputBg: "#00695C", btnActive: "#00796B", btnInactive: "#00695C", toggleOn: "#00796B", toggleOff: "#00695C", textColor: "#80CBC4", clearBtn: "#C62828" } },
        { name: "58经典深粉", colors: { menuBarBg: "#880E4F", nodeBg: "#FCE4EC", nodeText: "#AD1457", group: "#E91E63", canvas: "#F3E5F5", grid: "#E1BEE7", inputBg: "#AD1457", btnActive: "#C2185B", btnInactive: "#AD1457", toggleOn: "#C2185B", toggleOff: "#AD1457", textColor: "#F48FB1", clearBtn: "#E91E63" } },
        { name: "59经典亮黄", colors: { menuBarBg: "#F57F17", nodeBg: "#FFFDE7", nodeText: "#F9A825", group: "#FFEB3B", canvas: "#FFFDE7", grid: "#FFF59D", inputBg: "#F9A825", btnActive: "#FBC02D", btnInactive: "#F9A825", toggleOn: "#FBC02D", toggleOff: "#F9A825", textColor: "#FFFDE7", clearBtn: "#EF6C00" } },
        { name: "60活力橙色", colors: { menuBarBg: "#EF6C00", nodeBg: "#FFF3E0", nodeText: "#E65100", group: "#FF9800", canvas: "#FFEBEE", grid: "#FFCCBC", inputBg: "#F57C00", btnActive: "#FB8C00", btnInactive: "#F57C00", toggleOn: "#FB8C00", toggleOff: "#F57C00", textColor: "#FFE0B2", clearBtn: "#D84315" } },
        { category: "JSON提供主题" },
        { name: "61深灰红线", colors: { menuBarBg: "#1F2937", nodeBg: "#FFFFFF", nodeText: "#111827", group: "#2C3E50", canvas: "#111827", grid: "#1A2432", inputBg: "#111827", btnActive: "#4B5563", btnInactive: "#374151", toggleOn: "#4B5563", toggleOff: "#374151", textColor: "#D1D5DB", clearBtn: "#EF4444" } },
        { name: "62黑金复古", colors: { menuBarBg: "#2B2B2B", nodeBg: "#EADBB7", nodeText: "#2B2B2B", group: "#8C6A32", canvas: "#141414", grid: "#1E1E1E", inputBg: "#141414", btnActive: "#8C6A32", btnInactive: "#4A4A4A", toggleOn: "#8C6A32", toggleOff: "#4A4A4A", textColor: "#EADBB7", clearBtn: "#D32F2F" } },
        { name: "63奶油抹茶", colors: { menuBarBg: "#8B8F7A", nodeBg: "#F6F2E6", nodeText: "#334155", group: "#BFC5AA", canvas: "#EFE9D9", grid: "#E6E0D0", inputBg: "#BFC5AA", btnActive: "#A7AB99", btnInactive: "#BFC5AA", toggleOn: "#A7AB99", toggleOff: "#BFC5AA", textColor: "#F6F2E6", clearBtn: "#C0392B" } },
        { name: "64墨蓝卡其", colors: { menuBarBg: "#0F3D57", nodeBg: "#E9E2D0", nodeText: "#0B2230", group: "#2E5E72", canvas: "#0B1A23", grid: "#14252E", inputBg: "#0B1A23", btnActive: "#2E5E72", btnInactive: "#1D3C4B", toggleOn: "#2E5E72", toggleOff: "#1D3C4B", textColor: "#E9E2D0", clearBtn: "#E74C3C" } },
        { name: "65森林薄雾", colors: { menuBarBg: "#355E3B", nodeBg: "#E7F1EA", nodeText: "#1E3A2C", group: "#4A7452", canvas: "#0F2417", grid: "#183021", inputBg: "#2A4B2F", btnActive: "#4A7452", btnInactive: "#2A4B2F", toggleOn: "#4A7452", toggleOff: "#2A4B2F", textColor: "#A4C3A2", clearBtn: "#D32F2F" } },
        { name: "66靛青奶白", colors: { menuBarBg: "#1C2A44", nodeBg: "#FFFFFF", nodeText: "#1C2A44", group: "#2A3E66", canvas: "#0C1424", grid: "#141C2C", inputBg: "#0C1424", btnActive: "#2A3E66", btnInactive: "#141C2C", toggleOn: "#2A3E66", toggleOff: "#141C2C", textColor: "#E0E0E0", clearBtn: "#E53935" } },
        { name: "67木质拿铁", colors: { menuBarBg: "#6F4E37", nodeBg: "#FBF5EC", nodeText: "#3B2F2A", group: "#9B7B5A", canvas: "#F3E8D9", grid: "#EADFCC", inputBg: "#D3C5B3", btnActive: "#9B7B5A", btnInactive: "#C3B09C", toggleOn: "#9B7B5A", toggleOff: "#C3B09C", textColor: "#3B2F2A", clearBtn: "#BF360C" } },
        { name: "68青灰珊瑚", colors: { menuBarBg: "#355C7D", nodeBg: "#FFFFFF", nodeText: "#243B55", group: "#6C8BAC", canvas: "#0E1A26", grid: "#172330", inputBg: "#172330", btnActive: "#6C8BAC", btnInactive: "#4E6A85", toggleOn: "#6C8BAC", toggleOff: "#4E6A85", textColor: "#F0F8FF", clearBtn: "#F87575" } },
        { name: "69煤灰琥珀", colors: { menuBarBg: "#2A2E35", nodeBg: "#F2E2C4", nodeText: "#2A2E35", group: "#B38A4B", canvas: "#16181D", grid: "#1E2228", inputBg: "#1E2228", btnActive: "#B38A4B", btnInactive: "#4A4E55", toggleOn: "#B38A4B", toggleOff: "#4A4E55", textColor: "#DCDCDC", clearBtn: "#E57373" } },
        { name: "70象牙红心", colors: { menuBarBg: "#A4322E", nodeBg: "#FFFFFF", nodeText: "#1A1A1A", group: "#C54C46", canvas: "#F7F7F7", grid: "#EEEEEE", inputBg: "#B84642", btnActive: "#C54C46", btnInactive: "#B84642", toggleOn: "#C54C46", toggleOff: "#B84642", textColor: "#FFEBEE", clearBtn: "#C54C46" } },
        { name: "71黛青月白", colors: { menuBarBg: "#0F4C5C", nodeBg: "#EAF2F4", nodeText: "#0F2F36", group: "#2D6F7E", canvas: "#092A33", grid: "#12343D", inputBg: "#12343D", btnActive: "#2D6F7E", btnInactive: "#1A4B56", toggleOn: "#2D6F7E", toggleOff: "#1A4B56", textColor: "#B2DFDB", clearBtn: "#E57373" } },
        { name: "72葡萄薰衣", colors: { menuBarBg: "#4C3A74", nodeBg: "#EEEAF6", nodeText: "#342655", group: "#6B58A1", canvas: "#221B35", grid: "#2B2440", inputBg: "#3B2D5D", btnActive: "#6B58A1", btnInactive: "#3B2D5D", toggleOn: "#6B58A1", toggleOff: "#3B2D5D", textColor: "#D1C4E9", clearBtn: "#D81B60" } },
        { name: "73深夜青绿", colors: { menuBarBg: "#0B4F4A", nodeBg: "#E7FFFB", nodeText: "#0B3030", group: "#137A72", canvas: "#031F1E", grid: "#0C2A29", inputBg: "#0C2A29", btnActive: "#137A72", btnInactive: "#0E5E58", toggleOn: "#137A72", toggleOff: "#0E5E58", textColor: "#A7FFEB", clearBtn: "#E53935" } },
        { name: "74暖灰粘土", colors: { menuBarBg: "#534B43", nodeBg: "#EEE7E1", nodeText: "#2D2926", group: "#7A6F65", canvas: "#1E1A17", grid: "#272320", inputBg: "#272320", btnActive: "#7A6F65", btnInactive: "#3A342F", toggleOn: "#7A6F65", toggleOff: "#3A342F", textColor: "#D7CCC8", clearBtn: "#BF360C" } },
        { name: "75海军蓝调", colors: { menuBarBg: "#0A3556", nodeBg: "#EAF2FA", nodeText: "#0A2033", group: "#185A8A", canvas: "#061A2B", grid: "#0E2334", inputBg: "#0E2334", btnActive: "#185A8A", btnInactive: "#0E2334", toggleOn: "#185A8A", toggleOff: "#0E2334", textColor: "#B3E5FC", clearBtn: "#E53935" } },
        { name: "76青石橘粉", colors: { menuBarBg: "#2D3E40", nodeBg: "#FFE4D9", nodeText: "#3A2A27", group: "#5A7477", canvas: "#121A1B", grid: "#1A2324", inputBg: "#1A2324", btnActive: "#5A7477", btnInactive: "#3D5A5D", toggleOn: "#5A7477", toggleOff: "#3D5A5D", textColor: "#E0F2F1", clearBtn: "#D9534F" } },
        { name: "77石墨青蓝", colors: { menuBarBg: "#1E293B", nodeBg: "#E2E8F0", nodeText: "#0F172A", group: "#334155", canvas: "#0B1220", grid: "#141A27", inputBg: "#0F172A", btnActive: "#334155", btnInactive: "#141A27", toggleOn: "#334155", toggleOff: "#141A27", textColor: "#94A3B8", clearBtn: "#EF4444" } },
        { name: "78薄荷拿铁", colors: { menuBarBg: "#2B7A78", nodeBg: "#F1FFFD", nodeText: "#234E52", group: "#3AAFA9", canvas: "#0E2D2C", grid: "#163736", inputBg: "#174C4A", btnActive: "#3AAFA9", btnInactive: "#174C4A", toggleOn: "#3AAFA9", toggleOff: "#174C4A", textColor: "#DEF2F1", clearBtn: "#FE6D73" } },
        { name: "79沙海暮色", colors: { menuBarBg: "#7F5539", nodeBg: "#FFF2E2", nodeText: "#4A2F1E", group: "#B08968", canvas: "#2B1D14", grid: "#35261C", inputBg: "#553A2A", btnActive: "#B08968", btnInactive: "#553A2A", toggleOn: "#B08968", toggleOff: "#553A2A", textColor: "#EFEBE9", clearBtn: "#BF360C" } },
        { name: "80冰蓝钴蓝", colors: { menuBarBg: "#1E5AA7", nodeBg: "#F2F7FF", nodeText: "#0E2A5A", group: "#3E7BCE", canvas: "#0A1A33", grid: "#12223B", inputBg: "#12223B", btnActive: "#3E7BCE", btnInactive: "#12223B", toggleOn: "#3E7BCE", toggleOff: "#12223B", textColor: "#D4E3F7", clearBtn: "#D32F2F" } },
        { name: "81青绿琉璃", colors: { menuBarBg: "#116466", nodeBg: "#E9FFFB", nodeText: "#103638", group: "#2C7873", canvas: "#0A2425", grid: "#132D2E", inputBg: "#132D2E", btnActive: "#2C7873", btnInactive: "#132D2E", toggleOn: "#2C7873", toggleOff: "#132D2E", textColor: "#D4EFEF", clearBtn: "#FF6B6B" } },
        { name: "82黑板粉笔", colors: { menuBarBg: "#21412A", nodeBg: "#F3F8F1", nodeText: "#263A2B", group: "#3C6E47", canvas: "#0F2415", grid: "#172D1E", inputBg: "#172D1E", btnActive: "#3C6E47", btnInactive: "#172D1E", toggleOn: "#3C6E47", toggleOff: "#172D1E", textColor: "#C8E6C9", clearBtn: "#E57373" } },
        { name: "83石英玫瑰", colors: { menuBarBg: "#7A284B", nodeBg: "#FCE9F0", nodeText: "#3E1628", group: "#A34D6E", canvas: "#2E0F1D", grid: "#371626", inputBg: "#371626", btnActive: "#A34D6E", btnInactive: "#371626", toggleOn: "#A34D6E", toggleOff: "#371626", textColor: "#F8BBD0", clearBtn: "#E91E63" } },
        { name: "84钢蓝琥珀", colors: { menuBarBg: "#243B53", nodeBg: "#F6E3C6", nodeText: "#243B53", group: "#3A5168", canvas: "#0F1C2A", grid: "#172332", inputBg: "#172332", btnActive: "#3A5168", btnInactive: "#172332", toggleOn: "#3A5168", toggleOff: "#172332", textColor: "#D4E3F7", clearBtn: "#E57373" } },
        { name: "85橄榄砂岩", colors: { menuBarBg: "#5A6A3A", nodeBg: "#F0F3E4", nodeText: "#37401F", group: "#7E8F58", canvas: "#232914", grid: "#2C321C", inputBg: "#3A442A", btnActive: "#7E8F58", btnInactive: "#3A442A", toggleOn: "#7E8F58", toggleOff: "#3A442A", textColor: "#E6EECE", clearBtn: "#D32F2F" } },
        { name: "86深梅奶灰", colors: { menuBarBg: "#5B3A5D", nodeBg: "#EEE8F1", nodeText: "#2F2230", group: "#7B5A7D", canvas: "#221924", grid: "#2B222D", inputBg: "#3A2A3C", btnActive: "#7B5A7D", btnInactive: "#3A2A3C", toggleOn: "#7B5A7D", toggleOff: "#3A2A3C", textColor: "#E1BEE7", clearBtn: "#C2185B" } },
        { name: "87煤黑青柠", colors: { menuBarBg: "#1F1F1F", nodeBg: "#F3FFF1", nodeText: "#163417", group: "#3E6B3E", canvas: "#0D0D0D", grid: "#151515", inputBg: "#0D0D0D", btnActive: "#3E6B3E", btnInactive: "#294529", toggleOn: "#3E6B3E", toggleOff: "#294529", textColor: "#E0E0E0", clearBtn: "#E53935" } },
        { name: "88牛仔芥末", colors: { menuBarBg: "#2D4B73", nodeBg: "#FFF2CC", nodeText: "#2D2411", group: "#456C9A", canvas: "#0F1A28", grid: "#172230", inputBg: "#172230", btnActive: "#456C9A", btnInactive: "#172230", toggleOn: "#456C9A", toggleOff: "#172230", textColor: "#D4E3F7", clearBtn: "#EF6C00" } },
        { name: "89可可象牙", colors: { menuBarBg: "#4A2C2A", nodeBg: "#FFF8F0", nodeText: "#2C1A18", group: "#6A433F", canvas: "#170F0E", grid: "#201716", inputBg: "#201716", btnActive: "#6A433F", btnInactive: "#201716", toggleOn: "#6A433F", toggleOff: "#201716", textColor: "#D7CCC8", clearBtn: "#BF360C" } },
        { name: "90青灰珀白", colors: { menuBarBg: "#34515E", nodeBg: "#ECF2F6", nodeText: "#1D2F36", group: "#4B6B78", canvas: "#121C22", grid: "#1A242A", inputBg: "#1A242A", btnActive: "#4B6B78", btnInactive: "#1A242A", toggleOn: "#4B6B78", toggleOff: "#1A242A", textColor: "#B0C4DE", clearBtn: "#D9534F" } }
    ];

    function removeThemeHighlight() {
        const highlighted = dom.themeDropdown.querySelector('.theme-item.highlighted');
        if (highlighted) {
            highlighted.classList.remove('highlighted');
        }
    }

    function handleThemeKeyDown(e) {
        if (!dom.themeDropdown.classList.contains('show')) {
            return;
        }

        const items = Array.from(dom.themeDropdown.querySelectorAll('.theme-item'));
        if (items.length === 0) return;

        let newIndex = highlightedThemeIndex;
        let changed = false;

        if (e.key === 'ArrowDown') {
            e.preventDefault();
            newIndex = (newIndex + 1) % items.length;
            changed = true;
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            newIndex = (newIndex - 1 + items.length) % items.length;
            changed = true;
        } else if (e.key === 'Enter') {
            e.preventDefault();
            if (highlightedThemeIndex !== -1 && items[highlightedThemeIndex]) {
                const themeObjects = themes.filter(t => t.colors);
                const selectedTheme = themeObjects[highlightedThemeIndex];
                applyTheme(selectedTheme, true); // true to set it permanently
                dom.themeDropdown.classList.remove('show');
            }
        } else if (e.key === 'Escape') {
            dom.themeDropdown.classList.remove('show');
            if(activeTheme) applyTheme(activeTheme, false, true); // skipHistory = true，因为只是恢复预览
        }

        if (changed && newIndex !== highlightedThemeIndex) {
            removeThemeHighlight();
            highlightedThemeIndex = newIndex;
            const newItem = items[highlightedThemeIndex];
            newItem.classList.add('highlighted');
            // Apply theme directly on arrow key navigation (preview only, don't record history)
            const themeObjects = themes.filter(t => t.colors);
            applyTheme(themeObjects[highlightedThemeIndex], false); // false to preview only, don't record
            newItem.scrollIntoView({ block: 'nearest' });
        }
    }

    function applyTheme(theme, isPermanent = false, skipHistory = false) {
        const themeColors = theme.colors;
        
        if (isPermanent) {
            activeTheme = theme;
            state.settings.currentThemeName = theme.name;
            // Update theme button text to show current theme name
            dom.themeSwitcherBtn.textContent = theme.name;
            
            // 添加到操作历史记录（除非是撤销/重做操作）
            if (!skipHistory) {
                saveState(`切换主题: ${theme.name}`);
                // 永久切换主题时保存到IndexedDB
                try {
                    dbStorage.save('canvasActiveTheme', activeTheme, dbStorage.storeNames.canvasActiveTheme);
                } catch (error) {
                    // 保存主题到IndexedDB失败
                }
            }
        }
        
        // Store theme colors for components to use
        state.settings.themeColors = themeColors;
        
        // 清除文字缓存，因为主题切换可能改变字体大小
        clearTextCache();
        
        // 清除每个节点自己的textLines缓存，确保字体大小正确更新
        state.nodes.forEach(node => {
            node.textLines = null;
        });

        // Set CSS variables for dynamic theme support
        const root = document.documentElement;
        root.style.setProperty('--canvas-bg', themeColors.canvas);
        root.style.setProperty('--text-color', themeColors.textColor);
        root.style.setProperty('--menu-bar-bg', themeColors.menuBarBg);
        root.style.setProperty('--input-bg', themeColors.inputBg);
        root.style.setProperty('--btn-active', themeColors.btnActive);
        root.style.setProperty('--btn-inactive', themeColors.btnInactive);
        root.style.setProperty('--context-menu-bg', themeColors.menuBarBg);
        root.style.setProperty('--node-border', themeColors.btnInactive);

        // Apply canvas-related colors
        document.body.style.backgroundColor = themeColors.canvas;
        dom.canvas.style.backgroundColor = themeColors.canvas;
        
        // 更新所有非自定义样式节点的颜色为当前主题颜色
        state.nodes.forEach(node => {
            if (!node.hasCustomStyle && !node.isStatusBlock) {
                node.backgroundColor = themeColors.nodeBg;
                node.color = themeColors.nodeText;
            }
        });
        state.settings.gridColor = themeColors.grid;

        // Always update color displays to reflect current theme
        dom.nodeBgColorDisplay.style.backgroundColor = themeColors.nodeBg;
        dom.fontColorDisplay.style.backgroundColor = themeColors.nodeText;
        dom.groupColorDisplay.style.backgroundColor = themeColors.group;
        
        // Update canvas info display color to contrast with canvas background
        updateCanvasInfoColor();
        
        // Apply colors to all existing nodes and groups that don't have custom styles
        // 状态块不受主题影响
        state.nodes.forEach(node => {
            if (!node.hasCustomStyle && !node.isStatusBlock) {
                node.backgroundColor = themeColors.nodeBg;
                node.color = themeColors.nodeText;
                // Apply node stroke color
                node.strokeColor = themeColors.nodeStroke || themeColors.nodeBg;
            }
        });
        state.groups.forEach(group => {
            if (!group.hasCustomStyle) {
                group.color = themeColors.group;
            }
        });

        // Generate and inject CSS for UI components
        const dynamicStyles = `
            #toolbar { background-color: ${themeColors.menuBarBg}; }
            .control-label, #search-count,
            #theme-dropdown .theme-category, .context-menu-item { color: ${themeColors.textColor}; }
            
            .shortcut-input, #canvas-name-input { 
                background-color: ${themeColors.inputBg}; 
                color: ${themeColors.textColor};
                border-color: ${themeColors.btnInactive};
            }
            
            .control-btn {
                background-color: ${themeColors.btnInactive};
                color: ${themeColors.textColor};
            }
            
            #undo-btn:not(:disabled), #redo-btn:not(:disabled) {
                background-color: ${themeColors.btnActive};
            }
            
            #save-btn, #save-as-btn, #load-btn, #merge-btn, #export-module-btn, 
            #history-snapshot-btn, #md-convert-btn, #shortcut-config-btn,
            #search-prev-btn, #search-next-btn, #confirm-cancel-btn, #theme-switcher-btn, #help-btn, #help-modal-ok-btn, #focus-btn {
                background-color: ${themeColors.btnActive};
            }

            #clear-btn, #confirm-ok-btn {
                 background-color: ${themeColors.clearBtn};
                 color: ${themeColors.textColor};
            }

            .toggle-btn {
                background-color: ${themeColors.toggleOff};
                color: ${themeColors.toggleTextColor || '#EAEAEA'}; /* 从主题配置中读取开关按钮文字颜色 */
            }
            .toggle-btn.active {
                background-color: ${themeColors.toggleOn || '#4F9F54'};
                color: ${themeColors.toggleTextColor || '#EAEAEA'}; /* 从主题配置中读取开关按钮文字颜色 */
            }
            
            /* Context menu background color */
            .context-menu {
                background-color: ${themeColors.contextMenuBg || themeColors.menuBarBg || themeColors.btnActive};
            }
            
            /* Context menu item hover effects with higher specificity */
            .context-menu .context-menu-item:hover {
                background-color: ${themeColors.btnActive} !important;
                color: ${themeColors.textColor} !important;
            }
            
            .context-menu .submenu .context-menu-item:hover {
                background-color: ${themeColors.btnActive} !important;
                color: ${themeColors.textColor} !important;
            }
            
            .context-menu .context-menu-item.has-submenu:hover,
            .context-menu .context-menu-item.has-submenu:focus-within {
                background-color: ${themeColors.btnActive} !important;
                color: ${themeColors.textColor} !important;
            }
        `;
        
        document.getElementById('dynamic-theme-styles').innerHTML = dynamicStyles;
        
        // Update history modal if it's open
        if (dom.newHistoryModal && dom.newHistoryModal.style.display === 'block') {
            generateNewHistoryList();
        }
        
        setStateDirty();
    }



    function setupThemeSwitcher() {
        const fragment = document.createDocumentFragment();
        const themeObjects = themes.filter(t => t.colors);

        themes.forEach(theme => {
            if (theme.category) {
                const categoryEl = document.createElement('div');
                categoryEl.className = 'theme-category';
                categoryEl.textContent = theme.category;
                fragment.appendChild(categoryEl);
            } else {
                const itemEl = document.createElement('div');
                itemEl.className = 'theme-item';
                itemEl.textContent = theme.name;

                itemEl.addEventListener('mouseenter', () => applyTheme(theme, false));

                itemEl.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent dropdown from closing
                    applyTheme(theme, true); // Set permanently
                    
                    const clickedIndex = themeObjects.findIndex(t => t.name === theme.name);
                    if (clickedIndex !== -1) {
                        removeThemeHighlight();
                        highlightedThemeIndex = clickedIndex;
                        itemEl.classList.add('highlighted');
                    }
                    dom.themeDropdown.classList.remove('show');
                });
                fragment.appendChild(itemEl);
            }
        });
        dom.themeDropdown.appendChild(fragment);

        dom.themeDropdown.addEventListener('mouseleave', () => {
            if (activeTheme) applyTheme(activeTheme, false, true); // skipHistory = true，因为只是恢复预览
        });

        dom.themeSwitcherBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isVisible = dom.themeDropdown.classList.toggle('show');
            if (isVisible) {
                // 动态定位主题下拉菜单
                const btnRect = dom.themeSwitcherBtn.getBoundingClientRect();
                const dropdownWidth = Math.round(btnRect.width * 0.75); // 下拉菜单宽度为按钮宽度的0.75倍
                const dropdownHeight = 300; // 预估下拉菜单高度
                
                // 设置下拉菜单的宽度
                dom.themeDropdown.style.width = dropdownWidth + 'px';
                
                // 计算位置，确保不超出视窗
                let left = btnRect.right - dropdownWidth;
                let top = btnRect.bottom + 8;
                
                // 检查右边界
                if (left < 10) {
                    left = 10;
                }
                
                // 检查底部边界
                if (top + dropdownHeight > window.innerHeight - 10) {
                    top = btnRect.top - dropdownHeight - 8;
                }
                
                // 应用位置
                dom.themeDropdown.style.left = left + 'px';
                dom.themeDropdown.style.top = top + 'px';
                
                removeThemeHighlight();
                const themeItems = Array.from(dom.themeDropdown.querySelectorAll('.theme-item'));
                const currentThemeIdx = themeObjects.findIndex(theme => theme.name === state.settings.currentThemeName);

                if (currentThemeIdx !== -1) {
                    highlightedThemeIndex = currentThemeIdx;
                    const currentItem = themeItems[highlightedThemeIndex];
                    currentItem.classList.add('highlighted');
                    currentItem.scrollIntoView({ block: 'nearest' });
                } else {
                    highlightedThemeIndex = -1;
                }
            }
        });
    }

    // ===================================================================================
    // Canvas Info Display Functions
    // ===================================================================================
    
    function updateCanvasPositionInfo() {
        const x = Math.round(state.view.panX);
        const y = Math.round(state.view.panY);
        const zoom = Math.round(state.view.zoom * 100);
        dom.canvasPositionInfo.textContent = `画布位置: (${x}, ${y}) | 缩放比例: ${zoom}%`;
    }
    
    function updateCanvasCountInfo() {
        // 只统计当前视图层级可见的节点和组
        const currentLevelNodes = getCurrentLevelNodes();
        const currentLevelGroups = getCurrentLevelGroups();
        
        // 计算非状态块的节点数量
        const currentNodeCount = currentLevelNodes.filter(node => !node.isStatusBlock).length;
        const currentGroupCount = currentLevelGroups.length;
        
        // 计算全局有效非状态块节点数量 - 只统计那些要么在根层级，要么属于某个有效节点集的子节点
        const totalNodeCount = state.nodes.filter(node => {
            if (node.isStatusBlock) return false; // 排除状态块
            if (!node.parentNodeSetId) return true; // 根层级节点有效
            // 检查父节点集是否存在且有效
            const parentNodeSet = state.nodes.find(n => n.id === node.parentNodeSetId && n.isNodeSet);
            return !!parentNodeSet; // 只有当父节点集存在时才认为该节点有效
        }).length;
        
        // 计算孤立未渲染节点数量 - 有parentNodeSetId但父节点集不存在的节点
        const orphanNodeCount = state.nodes.filter(node => {
            if (node.isStatusBlock) return false; // 排除状态块
            if (!node.parentNodeSetId) return false; // 根层级节点不是孤立节点
            // 检查父节点集是否不存在或无效
            const parentNodeSet = state.nodes.find(n => n.id === node.parentNodeSetId && n.isNodeSet);
            return !parentNodeSet; // 父节点集不存在则为孤立节点
        }).length;
        
        dom.canvasCountInfo.textContent = `当前画布: ${currentNodeCount}节点 | 全局: ${totalNodeCount}节点 | 孤立: ${orphanNodeCount}节点`;
    }
    
    function updateCanvasInfoColor() {
        // Get current canvas background color
        const canvasColor = state.settings.themeColors ? state.settings.themeColors.canvas : '#0B1220';
        
        // Calculate inverse color for better contrast
        const inverseColor = getInverseColor(canvasColor);
        
        // Apply the inverse color to canvas info display
        const canvasInfo = document.getElementById('canvas-info');
        if (canvasInfo) {
            canvasInfo.style.color = inverseColor;
        }
    }

    // ===================================================================================
    // Node Set Functions
    // ===================================================================================
    
    function updateBreadcrumbNavigation() {
        if (!dom.breadcrumbContainer) {
            // 面包屑容器未找到
            return;
        }
        

        
        // 清空现有面包屑
        dom.breadcrumbContainer.innerHTML = '';
        
        // 添加根节点
        const rootItem = document.createElement('span');
        rootItem.className = 'breadcrumb-item root-item';
        rootItem.dataset.nodesetId = 'root';
        rootItem.innerHTML = `
            <span class="breadcrumb-icon">🏠</span>
            <span class="breadcrumb-text">根画布</span>
        `;
        
        // 如果当前在根层级，标记为当前项
        if (state.nodeSetNavigation.currentNodeSetId === null) {
            rootItem.classList.add('current');
        }
        
        rootItem.addEventListener('click', () => navigateToNodeSet(null));
        dom.breadcrumbContainer.appendChild(rootItem);
        
        // 添加导航路径中的每个节点集
        state.nodeSetNavigation.navigationPath.forEach((nodeSetId, index) => {
            // 添加分隔符
            const separator = document.createElement('span');
            separator.className = 'breadcrumb-separator';
            separator.textContent = '>';
            dom.breadcrumbContainer.appendChild(separator);
            
            // 查找节点集
            const nodeSet = state.nodes.find(n => n.id === nodeSetId && n.isNodeSet);
            if (nodeSet) {
                const item = document.createElement('span');
                item.className = 'breadcrumb-item';
                item.dataset.nodesetId = nodeSetId;
                
                // 如果是当前层级，标记为当前项
                if (nodeSetId === state.nodeSetNavigation.currentNodeSetId) {
                    item.classList.add('current');
                }
                
                item.innerHTML = `
                    <span class="breadcrumb-icon">📁</span>
                    <span class="breadcrumb-text">${nodeSet.text}</span>
                `;
                
                item.addEventListener('click', () => navigateToNodeSet(nodeSetId));
                dom.breadcrumbContainer.appendChild(item);
            }
        });
        
        // 显示或隐藏导航栏
        // 如果有节点集存在或者当前在导航路径中，就显示导航栏
        const hasNodeSets = state.nodes.some(node => node.isNodeSet);
        const shouldShow = hasNodeSets || state.nodeSetNavigation.navigationPath.length > 0;
        
        if (shouldShow) {
            dom.nodeSetNavigation.style.display = 'block';
            // 更新导航位置
            updateNavigationPosition();
        } else {
            dom.nodeSetNavigation.style.display = 'none';
        }
    }
    
    // 清除所有选中状态和搜索状态，防止描边残留
    function clearAllSelectionAndSearchStates() {
        
        // 清除所有节点的选中状态和搜索状态
        state.nodes.forEach(node => {
            node.isSelected = false;
            // 在搜索导航期间不清除搜索结果状态
            if (!state.interaction.isNavigatingResults) {
                node.isSearchResult = false;
            }
            // 清除可能的高亮状态
            if (node.isHighlighted !== undefined) {
                node.isHighlighted = false;
            }
            // 清除可能的悬停状态
            if (node.isHovered !== undefined) {
                node.isHovered = false;
            }
            // 清除可能的动画状态
            if (node.animationState !== undefined) {
                node.animationState = null;
            }
        });
        
        // 清除所有组的选中状态和搜索状态
        state.groups.forEach(group => {
            group.isSelected = false;
            // 在搜索导航期间不清除搜索结果状态
            if (!state.interaction.isNavigatingResults) {
                group.isSearchResult = false;
            }
            // 清除可能的高亮状态
            if (group.isHighlighted !== undefined) {
                group.isHighlighted = false;
            }
            // 清除可能的悬停状态
            if (group.isHovered !== undefined) {
                group.isHovered = false;
            }
            // 清除可能的动画状态
            if (group.animationState !== undefined) {
                group.animationState = null;
            }
        });
        
        // 清除搜索相关状态（在搜索导航期间保留）
        if (!state.interaction.isNavigatingResults) {
            state.searchResults = [];
            state.currentSearchIndex = -1;
        }
        
        // 清除呼吸灯节点集合
        state.animation.breathingNodes.clear();
        
        // 清除所有动画状态
        if (state.animation) {
            state.animation.breathingNodes.clear();
            if (state.animation.activeAnimations) {
                state.animation.activeAnimations.clear();
            }
        }
        
        // 清除交互状态，防止描边残留
        state.interaction.isMarquee = false;
        state.interaction.isDragging = false;
        state.interaction.dragPrepared = false;
        state.interaction.isPanning = false;
        state.interaction.isResizingNode = false;
        state.interaction.isResizingGroup = false;
        state.interaction.isMerging = false;
        
        // 清除触摸状态
        if (typeof touchState !== 'undefined') {
            touchState.isTouchDragging = false;
            touchState.preventClick = false;
            // 清除长按定时器
            if (touchState.longPressTimer) {
                clearTimeout(touchState.longPressTimer);
                touchState.longPressTimer = null;
            }
        }
        
        // 清除搜索框内容
        if (dom.searchInput) {
            dom.searchInput.value = '';
        }
        
        // 重置画布上下文状态 - 更全面的重置
        if (ctx) {
            // 重置线条样式
            ctx.setLineDash([]);
            ctx.lineDashOffset = 0;
            ctx.lineWidth = 1;
            
            // 重置颜色和透明度
            ctx.globalAlpha = 1.0;
            ctx.strokeStyle = '#000000';
            ctx.fillStyle = '#000000';
            
            // 重置变换矩阵
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // 重置合成模式
            ctx.globalCompositeOperation = 'source-over';
            
            // 重置阴影
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // 重置文本样式
            ctx.textAlign = 'start';
            ctx.textBaseline = 'alphabetic';
        }
        
        // 强制重新渲染以确保描边清除
        state.isDirty = true;
        

    }

    function navigateToNodeSet(nodeSetId) {
        // 保存当前视图状态
        if (state.nodeSetNavigation.currentNodeSetId !== nodeSetId) {
            saveCurrentViewState();
            
            // 清除所有选中状态和搜索状态，防止描边残留
            clearAllSelectionAndSearchStates();
            
            // 更新导航状态
            if (nodeSetId === null) {
                // 返回根层级
                state.nodeSetNavigation.currentNodeSetId = null;
                state.nodeSetNavigation.navigationPath = [];
            } else {
                // 进入指定节点集
                const targetIndex = state.nodeSetNavigation.navigationPath.indexOf(nodeSetId);
                if (targetIndex >= 0) {
                    // 如果目标在路径中，截断到该位置
                    state.nodeSetNavigation.navigationPath = state.nodeSetNavigation.navigationPath.slice(0, targetIndex + 1);
                } else {
                    // 如果目标不在路径中，添加到路径末尾
                    state.nodeSetNavigation.navigationPath.push(nodeSetId);
                }
                state.nodeSetNavigation.currentNodeSetId = nodeSetId;
            }
            
            // 恢复目标层级的视图状态
            restoreViewState(nodeSetId);
            
            // 更新面包屑导航
            updateBreadcrumbNavigation();
            
            // 保存状态到历史记录
            const nodeSet = nodeSetId ? state.nodes.find(n => n.id === nodeSetId) : null;
            const actionDesc = nodeSetId ? `进入节点集: ${nodeSet?.text || '未知'}` : '返回根画布';
            saveState(actionDesc);
            
            // 更新画布尺寸信息，确保坐标转换准确
            resizeCanvas();
            
            // 刷新节点数量显示
            updateCanvasCountInfo();
            
            setStateDirty();
        }
    }
    
    function saveCurrentViewState() {
        const currentId = state.nodeSetNavigation.currentNodeSetId;
        const viewState = {
            nodeSetId: currentId,
            view: { ...state.view }
        };
        
        // 移除已存在的相同层级状态
        state.nodeSetNavigation.viewStack = state.nodeSetNavigation.viewStack.filter(
            vs => vs.nodeSetId !== currentId
        );
        
        // 添加当前状态
        state.nodeSetNavigation.viewStack.push(viewState);
    }
    
    function restoreViewState(nodeSetId) {
        const viewState = state.nodeSetNavigation.viewStack.find(vs => vs.nodeSetId === nodeSetId);
        if (viewState) {
            state.view = { ...viewState.view };
        } else {
            // 如果没有保存的视图状态，重置为默认
            state.view = { panX: 0, panY: 0, zoom: 1 };
        }
    }
    
    function convertNodeToNodeSet(nodeId) {
        const node = state.nodes.find(n => n.id === nodeId);
        if (!node || node.isNodeSet) return;
        
        // 转节点集
        node.isNodeSet = true;
        node.nodeSetData = {
            childNodes: [],
            childGroups: [],
            view: { panX: 0, panY: 0, zoom: 1 }
        };
        
        saveState(`转节点集: ${node.text}`);
        setStateDirty();
        
        // 更新导航栏显示
        updateBreadcrumbNavigation();
    }
    
    function convertNodeSetToNode(nodeId) {
        const node = state.nodes.find(n => n.id === nodeId);
        if (!node || !node.isNodeSet) return;
        
        // 检查是否有子内容
        const hasChildren = node.nodeSetData.childNodes.length > 0 || node.nodeSetData.childGroups.length > 0;
        
        if (hasChildren) {
            showConfirmationModal(
                "转普通节点将丢失节点集内的所有内容，确定要继续吗？",
                () => {
                    // 执行转换
                    node.isNodeSet = false;
                    node.nodeSetData = {
                        childNodes: [],
                        childGroups: [],
                        view: { panX: 0, panY: 0, zoom: 1 }
                    };
                    
                    saveState(`转普通节点: ${node.text}`);
                    setStateDirty();
                    
                    // 更新导航栏显示
                    updateBreadcrumbNavigation();
                }
            );
        } else {
            // 没有子内容，直接转换
            node.isNodeSet = false;
            node.nodeSetData = {
                childNodes: [],
                childGroups: [],
                view: { panX: 0, panY: 0, zoom: 1 }
            };
            
            saveState(`转普通节点: ${node.text}`);
            setStateDirty();
            
            // 更新导航栏显示
            updateBreadcrumbNavigation();
        }
    }
    
    function enterNodeSet(nodeId) {
        const node = state.nodes.find(n => n.id === nodeId);
        if (!node || !node.isNodeSet) return;
        
        navigateToNodeSet(nodeId);
    }
    
    function exitCurrentNodeSet() {
        if (state.nodeSetNavigation.currentNodeSetId === null) {
            return; // 已经在根层级，无法退出
        }
        
        // 获取当前导航路径
        const currentPath = state.nodeSetNavigation.navigationPath;
        if (currentPath.length <= 1) {
            // 如果路径长度为1或0，返回根层级
            navigateToNodeSet(null);
        } else {
            // 返回上一层级
            const parentNodeSetId = currentPath[currentPath.length - 2];
            navigateToNodeSet(parentNodeSetId);
        }
    }
    
    function getCurrentLevelNodes() {
        let baseNodes = [];
        
        if (state.nodeSetNavigation.currentNodeSetId === null) {
            // 在根层级，返回所有没有父节点集的节点，排除状态块
            baseNodes = state.nodes.filter(n => !n.parentNodeSetId && !n.isStatusBlock);
        } else {
            // 在节点集内，返回该节点集的子节点
            const currentNodeSet = state.nodes.find(n => n.id === state.nodeSetNavigation.currentNodeSetId);
            if (currentNodeSet && currentNodeSet.isNodeSet) {
                baseNodes = currentNodeSet.nodeSetData.childNodes.map(childId => 
                    state.nodes.find(n => n.id === childId)
                ).filter(Boolean);
            }
        }
        
        // 收集所有与当前层级节点相关的状态块
        const nodeIds = new Set(baseNodes.map(n => n.id));
        const statusBlocks = state.nodes.filter(n => 
            n.isStatusBlock && nodeIds.has(n.targetNodeId)
        );
        
        // 返回基本节点和它们的状态块
        return [...baseNodes, ...statusBlocks];
    }
    
    function getCurrentLevelGroups() {
        let baseGroups = [];
        
        if (state.nodeSetNavigation.currentNodeSetId === null) {
            // 在根层级，返回所有没有父节点集的组
            baseGroups = state.groups.filter(g => !g.parentNodeSetId);
        } else {
            // 在节点集内，返回该节点集的子组
            const currentNodeSet = state.nodes.find(n => n.id === state.nodeSetNavigation.currentNodeSetId);
            if (currentNodeSet && currentNodeSet.isNodeSet) {
                baseGroups = currentNodeSet.nodeSetData.childGroups.map(childId => 
                    state.groups.find(g => g.id === childId)
                ).filter(Boolean);
            }
        }
        
        return baseGroups;
    }
    
    function updateCanvasSelectionInfo() {
        const selectedNodes = getSelectedNodes();
        const selectedGroups = getSelectedGroups();
        
        // 如果只选中了组
        if (selectedGroups.length > 0 && selectedNodes.length === 0) {
            if (selectedGroups.length === 1) {
                const group = selectedGroups[0];
                const x = Math.round(group.x);
                const y = Math.round(group.y);
                dom.canvasSelectionInfo.textContent = `选中组坐标: (${x}, ${y})`;
            } else {
                // 计算选中组的中心点坐标
                let totalX = 0, totalY = 0;
                selectedGroups.forEach(group => {
                    totalX += group.x + group.width / 2;
                    totalY += group.y + group.height / 2;
                });
                const centerX = Math.round(totalX / selectedGroups.length);
                const centerY = Math.round(totalY / selectedGroups.length);
                dom.canvasSelectionInfo.textContent = `选中组坐标: X: ${centerX}, Y: ${centerY}（模块中心点）`;
            }
        }
        // 如果只选中了节点
        else if (selectedNodes.length > 0 && selectedGroups.length === 0) {
            if (selectedNodes.length === 1) {
                const node = selectedNodes[0];
                const x = Math.round(node.x);
                const y = Math.round(node.y);
                dom.canvasSelectionInfo.textContent = `选中节点坐标: (${x}, ${y})`;
            } else {
                // 计算选中节点的中心点坐标
                let totalX = 0, totalY = 0;
                selectedNodes.forEach(node => {
                    totalX += node.x + node.width / 2;
                    totalY += node.y + node.height / 2;
                });
                const centerX = Math.round(totalX / selectedNodes.length);
                const centerY = Math.round(totalY / selectedNodes.length);
                dom.canvasSelectionInfo.textContent = `选中节点坐标: X: ${centerX}, Y: ${centerY}（模块中心点）`;
            }
        }
        // 如果同时选中了节点和组
        else if (selectedNodes.length > 0 && selectedGroups.length > 0) {
            // 计算所有选中对象的中心点坐标
            let totalX = 0, totalY = 0, totalCount = 0;
            
            selectedNodes.forEach(node => {
                totalX += node.x + node.width / 2;
                totalY += node.y + node.height / 2;
                totalCount++;
            });
            
            selectedGroups.forEach(group => {
                totalX += group.x + group.width / 2;
                totalY += group.y + group.height / 2;
                totalCount++;
            });
            
            const centerX = Math.round(totalX / totalCount);
            const centerY = Math.round(totalY / totalCount);
            dom.canvasSelectionInfo.textContent = `选中对象坐标: X: ${centerX}, Y: ${centerY}（模块中心点）`;
        }
        // 如果什么都没选中
        else {
            dom.canvasSelectionInfo.textContent = `选中节点坐标: 未选中`;
        }
    }



    // ===================================================================================
    // Text Rendering Optimization
    // ===================================================================================
    function getTextCacheKey(text, fontSize, maxWidth, fontFamily = 'sans-serif') {
        return `${text}_${fontSize}_${maxWidth}_${fontFamily}`;
    }
    
    function getCachedTextLines(text, fontSize, maxWidth, fontFamily = 'sans-serif') {
        const cacheKey = getTextCacheKey(text, fontSize, maxWidth, fontFamily);
        return textLineCache.get(cacheKey);
    }
    
    function setCachedTextLines(text, fontSize, maxWidth, lines, fontFamily = 'sans-serif') {
        const cacheKey = getTextCacheKey(text, fontSize, maxWidth, fontFamily);
        textLineCache.set(cacheKey, lines);
        
        // 限制缓存大小，避免内存泄漏
        if (textLineCache.size > 1000) {
            const firstKey = textLineCache.keys().next().value;
            textLineCache.delete(firstKey);
        }
    }
    
    function clearTextCache() {
        textLineCache.clear();
    }

    // ===================================================================================
    // High DPI Support
    // ===================================================================================
    function setupHighDPICanvas() {
        const rect = dom.canvas.getBoundingClientRect();
        const displayWidth = window.innerWidth;
        const displayHeight = window.innerHeight;
        
        // 设置Canvas的实际像素尺寸
        dom.canvas.width = displayWidth * devicePixelRatio;
        dom.canvas.height = displayHeight * devicePixelRatio;
        
        // 设置Canvas的CSS显示尺寸
        dom.canvas.style.width = displayWidth + 'px';
        dom.canvas.style.height = displayHeight + 'px';
        
        // 缩放绘图上下文以匹配设备像素比
        ctx.scale(devicePixelRatio, devicePixelRatio);
        canvasScale = devicePixelRatio;
        
        // 设置文字渲染优化
        ctx.textBaseline = 'top';
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
    }
    
    function resizeCanvas() {
        setupHighDPICanvas();
        renderCanvas();
    }

    // ===================================================================================
    // Initialization
    // ===================================================================================
    // 保存项目状态到localStorage
    async function saveToLocalStorage() {
        try {
            // 使用IndexedDB保存项目数据
            await saveToIndexedDB();
        } catch (error) {
            // 保存项目数据到localStorage失败
        }
    }

    // IndexedDB 存储管理器
    class IndexedDBStorage {
        constructor() {
            this.dbName = 'CanvasAppDB';
            this.dbVersion = 1;
            this.storeNames = {
                projectData: 'projectData',
                copiedStatusBlocks: 'copiedStatusBlocks',
                shortcutConfiguration: 'shortcutConfiguration',
                canvasActiveTheme: 'canvasActiveTheme'
            };
        }

        // 打开数据库连接
        openDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(this.dbName, this.dbVersion);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // 创建所有需要的存储对象
                    Object.values(this.storeNames).forEach(storeName => {
                        if (!db.objectStoreNames.contains(storeName)) {
                            db.createObjectStore(storeName);
                        }
                    });
                };
            });
        }

        // 保存数据到指定的存储对象
        async save(key, value, storeName) {
            try {
                const db = await this.openDB();
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                
                const request = store.put(value, key);
                
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        db.close();
                        resolve();
                    };
                    request.onerror = () => {
                        db.close();
                        reject(request.error);
                    };
                });
            } catch (error) {
                // 保存数据到IndexedDB失败
                throw error;
            }
        }

        // 从指定的存储对象加载数据
        async load(key, storeName) {
            try {
                const db = await this.openDB();
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                
                const request = store.get(key);
                
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        db.close();
                        resolve(request.result);
                    };
                    request.onerror = () => {
                        db.close();
                        reject(request.error);
                    };
                });
            } catch (error) {
                // 从IndexedDB加载数据失败
                return null;
            }
        }

        // 删除指定存储对象中的数据
        async remove(key, storeName) {
            try {
                const db = await this.openDB();
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                
                const request = store.delete(key);
                
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => {
                        db.close();
                        resolve();
                    };
                    request.onerror = () => {
                        db.close();
                        reject(request.error);
                    };
                });
            } catch (error) {
                // 从IndexedDB删除数据失败
                throw error;
            }
        }
    }

    // 创建IndexedDB存储实例
    const dbStorage = new IndexedDBStorage();

    // 从IndexedDB加载项目状态
    async function loadFromIndexedDB() {
        try {
            const savedData = await dbStorage.load('default', dbStorage.storeNames.projectData);
            if (savedData) {
                // 加载节点和组
                state.nodes = savedData.nodes ? savedData.nodes.map(n => deserializeNode(n)) : [];
                state.groups = savedData.groups ? savedData.groups.map(g => deserializeGroup(g)) : [];
                
                // 加载磁吸组
                state.magneticGroups = (savedData.magneticGroups || []).map(clusterArray => new Set(clusterArray));
                
                // 加载视图状态
                if (savedData.view) {
                    state.view = { ...savedData.view };
                }
                
                // 加载节点集导航状态
                if (savedData.nodeSetNavigation) {
                    state.nodeSetNavigation = { ...savedData.nodeSetNavigation };
                }
                
                // 加载主题
                if (savedData.activeTheme) {
                    activeTheme = { ...savedData.activeTheme };
                    state.settings.currentThemeName = activeTheme.name;
                    applyTheme(activeTheme, false, true); // skipHistory = true
                }
                
                // 更新状态块位置和尺寸
                updateStatusBlocks();
                
                console.log('Project loaded from IndexedDB');
                return true;
            }
        } catch (error) {
            // 从IndexedDB加载项目数据失败
        }
        return false;
    }
    
    // 保存项目数据到IndexedDB
    async function saveToIndexedDB() {
        try {
            const projectData = {
                nodes: state.nodes.map(n => serializeNode(n)),
                groups: state.groups.map(g => serializeGroup(g)),
                magneticGroups: state.magneticGroups.map(cluster => Array.from(cluster)),
                view: state.view,
                nodeSetNavigation: state.nodeSetNavigation,
                activeTheme: activeTheme,
                timestamp: Date.now()
            };
            await dbStorage.save('default', projectData, dbStorage.storeNames.projectData);
            console.log('Project saved to IndexedDB');
        } catch (error) {
            // 保存项目数据到IndexedDB失败
        }
    }

    async function initialize() {
        setupHighDPICanvas();
        
        setupEventListeners();
        setupToggleButtons();
        
        // 初始化快捷键配置（已包含IndexedDB逻辑）
        await initializeShortcuts();
        
        // 初始化自动保存系统
        await initializeAutoSave();
        
        history = [];
        historyIndex = -1;
        
        // 尝试从IndexedDB加载项目数据
        const projectLoaded = await loadFromIndexedDB();
        
        // 如果没有加载到项目数据，应用默认设置
        if (!projectLoaded) {
            // Apply a default theme on startup
            activeTheme = themes.find(t => t.name === "默认主题");
            if (activeTheme) {
                applyTheme(activeTheme, true, true); // skipHistory = true，因为是初始化
            }
            saveState('初始状态');
        } else {
            // 加载项目后保存初始状态
            saveState('从localStorage加载项目');
        }
        
        setupThemeSwitcher();

        // Initialize canvas info display
        updateCanvasPositionInfo();
        updateCanvasCountInfo();
        updateCanvasSelectionInfo();
        updateCanvasInfoColor();



        // Initialize navigation bar
        updateBreadcrumbNavigation();

        // 初始化动画系统
        state.animation.time = Date.now();
        state.isDirty = true; // 确保首次渲染
        
        renderLoop();
        showHelpModal(true); // Show help on first load
        
        // 初始化导航位置
        setTimeout(() => {
            updateNavigationPosition();
        }, 100); // 延迟执行确保DOM完全渲染
    }
    
    // 更新层级导航位置的函数
    function updateNavigationPosition() {
        const toolbar = document.getElementById('toolbar');
        const navigation = document.querySelector('.nodeset-navigation');
        
        if (toolbar && navigation) {
            // 获取toolbar的实际高度
            const toolbarHeight = toolbar.offsetHeight;
            // 设置层级导航的top位置，添加2px的间距
            navigation.style.top = (toolbarHeight + 2) + 'px';
        }
    }

    function setupEventListeners() {
        window.addEventListener('resize', () => {
            resizeCanvas();
            setStateDirty();
            // 窗口大小变化时更新导航位置
            updateNavigationPosition();
        });

        dom.canvas.addEventListener('mousedown', handleMouseDown);
        
        // 添加专门的canvas点击事件监听器来处理blur逻辑
        dom.canvas.addEventListener('mousedown', (e) => {
            // 处理canvas鼠标按下事件
            
            // 如果canvas名称输入框处于活动状态，则blur它
            if (document.activeElement === dom.canvasNameInput) {
                // 失去焦点，自动确认输入内容
                dom.canvasNameInput.blur();
            }
            
            // 如果搜索输入框处于活动状态，则blur它
            if (document.activeElement === dom.searchBox) {
                // 失去焦点，自动确认输入内容
                dom.searchBox.blur();
            }
        });
        
        // 注意：canvas的touchstart blur逻辑已经集成到handleTouchStart函数中
        
        // 添加全局mousedown监听器来处理输入框的blur
        document.addEventListener('mousedown', (e) => {
            // 处理全局鼠标按下事件
            
            // 检查画布名称输入框是否处于编辑状态，如果是则自动确认并退出编辑状态
            // 但只有当点击的不是输入框本身时才执行
            if (document.activeElement === dom.canvasNameInput && e.target !== dom.canvasNameInput) {
                // 失去焦点，自动确认输入内容
                dom.canvasNameInput.blur(); // 失去焦点，自动确认输入内容
            }
            
            // 检查搜索输入框是否处于编辑状态，如果是则自动确认并退出编辑状态
            // 但只有当点击的不是搜索框本身或其相关元素时才执行
            if (document.activeElement === dom.searchBox && 
                e.target !== dom.searchBox && 
                !e.target.closest('#search-container') &&
                !e.target.closest('#search-btn') &&
                !e.target.closest('#search-clear-btn')) {
                // 失去焦点，自动确认输入内容
                dom.searchBox.blur(); // 失去焦点，自动确认输入内容
            }
            
            // 检查是否需要关闭取色器面板
            const isOutsideColorPicker = !e.target.closest('.custom-color-picker-wrapper');
            if (isOutsideColorPicker) {
                // 关闭取色器面板
                document.querySelectorAll('.custom-color-picker-wrapper').forEach(wrapper => {
                    wrapper.classList.remove('active');
                });
            }
        });
        
        // 添加全局touchstart监听器来处理输入框的blur（移动端支持）
        document.addEventListener('touchstart', (e) => {
            // 调试日志：跟踪全局touchstart事件
            // 全局触摸开始触发
            
            // 检查画布名称输入框是否处于编辑状态，如果是则自动确认并退出编辑状态
            // 但只有当触摸的不是输入框本身时才执行
            if (document.activeElement === dom.canvasNameInput && e.target !== dom.canvasNameInput) {
                // 全局触摸开始使画布名称输入框失焦
                dom.canvasNameInput.blur(); // 失去焦点，自动确认输入内容
            }
            
            // 检查搜索输入框是否处于编辑状态，如果是则自动确认并退出编辑状态
            // 但只有当触摸的不是搜索框本身或其相关元素时才执行
            if (document.activeElement === dom.searchBox && 
                e.target !== dom.searchBox && 
                !e.target.closest('#search-container') &&
                !e.target.closest('#search-btn') &&
                !e.target.closest('#search-clear-btn')) {
                // 全局触摸开始使搜索框失焦
                dom.searchBox.blur(); // 失去焦点，自动确认输入内容
            }
            
            // 检查是否需要关闭取色器面板
            const globalColorPickerPanels = document.querySelectorAll('.custom-color-picker-panel');
            const globalClosestColorPicker = e.target.closest('.custom-color-picker-panel') || e.target.closest('.custom-color-picker-wrapper');
            const isOutsideColorPicker = !globalClosestColorPicker;
            
            // 全局触摸开始的颜色选择器调试
            
            if (isOutsideColorPicker) {
                // 全局触摸开始关闭颜色选择器
                globalColorPickerPanels.forEach((panel, index) => {
                    const wasActive = panel.classList.contains('active');
                    panel.classList.remove('active');
                    // 全局颜色选择器面板状态
                });
            }
            
            // 检查是否需要关闭主题下拉菜单
            const isOutsideThemeDropdown = !e.target.closest('#theme-dropdown') && !e.target.closest('#theme-switcher-btn');
            if (isOutsideThemeDropdown && dom.themeDropdown.classList.contains('show')) {
                // 全局触摸开始关闭主题下拉菜单
                dom.themeDropdown.classList.remove('show');
            }
        }, { passive: true });
        dom.canvas.addEventListener('mousemove', handleMouseMove);
        dom.canvas.addEventListener('mouseup', handleMouseUp);
        dom.canvas.addEventListener('dblclick', handleDoubleClick);
        dom.canvas.addEventListener('wheel', handleWheel, { passive: false });
        dom.canvas.addEventListener('contextmenu', handleContextMenu);
        
        // 添加触摸事件处理
        dom.canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        dom.canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        dom.canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        dom.canvas.addEventListener('touchcancel', handleTouchCancel, { passive: false });
        
        // 添加toolbar触摸和鼠标滑动功能
        let toolbarScrollState = {
            isScrolling: false,
            startX: 0,
            scrollLeft: 0,
            hasMoved: false,
            isDragging: false, // 用于鼠标拖动
            velocity: 0, // 滚动速度
            lastX: 0, // 上一次的X坐标
            lastTime: 0, // 上一次的时间戳
            animationId: null // 动画ID
        };
        
        // 惯性滚动动画函数
        function startInertiaScroll() {
            if (toolbarScrollState.animationId) {
                cancelAnimationFrame(toolbarScrollState.animationId);
            }
            
            const friction = 0.95; // 摩擦系数，值越小减速越快
            const minVelocity = 0.5; // 最小速度阈值
            
            function animate() {
                if (Math.abs(toolbarScrollState.velocity) < minVelocity) {
                    toolbarScrollState.velocity = 0;
                    toolbarScrollState.animationId = null;
                    return;
                }
                
                // 检查工具栏是否可以滚动
                const canScroll = dom.toolbar.scrollWidth > dom.toolbar.clientWidth;
                if (canScroll) {
                    const newScrollLeft = dom.toolbar.scrollLeft + toolbarScrollState.velocity;
                    
                    // 边界检查
                    const maxScroll = dom.toolbar.scrollWidth - dom.toolbar.clientWidth;
                    if (newScrollLeft >= 0 && newScrollLeft <= maxScroll) {
                        dom.toolbar.scrollLeft = newScrollLeft;
                    } else {
                        // 到达边界时停止惯性
                        toolbarScrollState.velocity = 0;
                        toolbarScrollState.animationId = null;
                        return;
                    }
                }
                
                // 应用摩擦力
                toolbarScrollState.velocity *= friction;
                
                toolbarScrollState.animationId = requestAnimationFrame(animate);
            }
            
            if (Math.abs(toolbarScrollState.velocity) >= minVelocity) {
                toolbarScrollState.animationId = requestAnimationFrame(animate);
            }
        }
        
        // 触摸事件处理
        dom.toolbar.addEventListener('touchstart', (e) => {
            // 停止任何正在进行的惯性滚动
            if (toolbarScrollState.animationId) {
                cancelAnimationFrame(toolbarScrollState.animationId);
                toolbarScrollState.animationId = null;
            }
            
            toolbarScrollState.isScrolling = true;
            toolbarScrollState.startX = e.touches[0].clientX;
            toolbarScrollState.lastX = e.touches[0].clientX;
            toolbarScrollState.scrollLeft = dom.toolbar.scrollLeft;
            toolbarScrollState.hasMoved = false;
            toolbarScrollState.velocity = 0;
            toolbarScrollState.lastTime = Date.now();
        }, { passive: true });
        
        dom.toolbar.addEventListener('touchmove', (e) => {
            if (!toolbarScrollState.isScrolling) return;
            
            e.preventDefault();
            const x = e.touches[0].clientX;
            const currentTime = Date.now();
            const walk = (toolbarScrollState.startX - x) * 1.5; // 滑动速度倍数
            
            // 计算速度（像素/毫秒）
            const deltaX = x - toolbarScrollState.lastX;
            const deltaTime = currentTime - toolbarScrollState.lastTime;
            if (deltaTime > 0) {
                toolbarScrollState.velocity = -deltaX * 1.5 / deltaTime * 16; // 转换为每帧的像素数
            }
            
            // 检查工具栏是否可以滚动
            const canScroll = dom.toolbar.scrollWidth > dom.toolbar.clientWidth;
            if (canScroll) {
                dom.toolbar.scrollLeft = toolbarScrollState.scrollLeft + walk;
            }
            
            // 如果移动距离超过阈值，标记为已移动
            if (Math.abs(walk) > 5) {
                toolbarScrollState.hasMoved = true;
            }
            
            // 更新上一次的位置和时间
            toolbarScrollState.lastX = x;
            toolbarScrollState.lastTime = currentTime;
        }, { passive: false });
        
        dom.toolbar.addEventListener('touchend', (e) => {
            toolbarScrollState.isScrolling = false;
            
            // 启动惯性滚动
            startInertiaScroll();
            
            // 如果有移动，阻止可能的点击事件
            if (toolbarScrollState.hasMoved) {
                setTimeout(() => {
                    toolbarScrollState.hasMoved = false;
                }, 100);
            }
        }, { passive: true });
        
        // 鼠标事件处理
        dom.toolbar.addEventListener('mousedown', (e) => {
            // 只处理左键
            if (e.button !== 0) return;
            
            // 如果点击的是输入框，不要处理拖拽
            if (e.target === dom.canvasNameInput) {
                return;
            }
            
            // 停止任何正在进行的惯性滚动
            if (toolbarScrollState.animationId) {
                cancelAnimationFrame(toolbarScrollState.animationId);
                toolbarScrollState.animationId = null;
            }
            
            toolbarScrollState.isDragging = true;
            toolbarScrollState.startX = e.clientX;
            toolbarScrollState.lastX = e.clientX;
            toolbarScrollState.scrollLeft = dom.toolbar.scrollLeft;
            toolbarScrollState.hasMoved = false;
            toolbarScrollState.velocity = 0;
            toolbarScrollState.lastTime = Date.now();
            
            // 阻止默认行为，避免文本选择
            e.preventDefault();
        });
        
        // 全局鼠标移动事件（需要在document上监听以支持拖拽到工具栏外）
        document.addEventListener('mousemove', (e) => {
            if (!toolbarScrollState.isDragging) return;
            
            e.preventDefault();
            const x = e.clientX;
            const currentTime = Date.now();
            const walk = (toolbarScrollState.startX - x) * 1.5; // 滑动速度倍数
            
            // 计算速度（像素/毫秒）
            const deltaX = x - toolbarScrollState.lastX;
            const deltaTime = currentTime - toolbarScrollState.lastTime;
            if (deltaTime > 0) {
                toolbarScrollState.velocity = -deltaX * 1.5 / deltaTime * 16; // 转换为每帧的像素数
            }
            
            // 检查工具栏是否可以滚动
            const canScroll = dom.toolbar.scrollWidth > dom.toolbar.clientWidth;
            if (canScroll) {
                dom.toolbar.scrollLeft = toolbarScrollState.scrollLeft + walk;
            }
            
            // 如果移动距离超过阈值，标记为已移动
            if (Math.abs(walk) > 5) {
                toolbarScrollState.hasMoved = true;
            }
            
            // 更新上一次的位置和时间
            toolbarScrollState.lastX = x;
            toolbarScrollState.lastTime = currentTime;
        });
        
        // 全局鼠标释放事件
        document.addEventListener('mouseup', (e) => {
            if (!toolbarScrollState.isDragging) return;
            
            toolbarScrollState.isDragging = false;
            
            // 启动惯性滚动
            startInertiaScroll();
            
            // 如果有移动，阻止可能的点击事件
            if (toolbarScrollState.hasMoved) {
                setTimeout(() => {
                    toolbarScrollState.hasMoved = false;
                }, 100);
            }
        });
        
        // 为工具栏按钮添加点击拦截
        dom.toolbar.addEventListener('click', (e) => {
            // 如果点击的是输入框，不要拦截
            if (e.target === dom.canvasNameInput) {
                return;
            }
            
            // 如果正在滑动或刚刚滑动过，阻止按钮点击
            if (toolbarScrollState.hasMoved || toolbarScrollState.isScrolling || toolbarScrollState.isDragging) {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
            
            // 如果正在编辑节点，点击工具栏任意位置退出编辑状态
            if (state.editingItem) {
                stopEditing();
            }
        }, true); // 使用捕获阶段，确保在按钮事件之前执行
        
        // 添加全局事件监听器作为备用重置机制
        document.addEventListener('mouseup', handleGlobalMouseUp);
        document.addEventListener('mouseleave', handleGlobalMouseLeave);
        window.addEventListener('blur', handleWindowBlur);



        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keydown', handleThemeKeyDown);
        
        // 确保body可以接收焦点
        if (document.body.tabIndex === -1) {
            document.body.tabIndex = 0;
        }
        
        // 强制聚焦到body
        document.body.focus();
        
        // 添加点击页面时自动获得焦点的功能
        document.addEventListener('click', function() {
            if (!document.hasFocus()) {
                document.body.focus();
            }
        });
        
        // 添加窗口焦点事件监听
        window.addEventListener('focus', function() {
            document.body.focus();
        });
        
        window.addEventListener('blur', function() {
            // 窗口失去焦点时的处理
        });
        document.addEventListener('click', handleDocumentClick);
        document.addEventListener('paste', handlePaste);
        window.addEventListener('dragover', e => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
        window.addEventListener('drop', handleDrop);

        dom.textEditor.addEventListener('keydown', handleTextEditorKeyDown);
        dom.textEditor.addEventListener('keyup', handleTextEditorKeyUp);
        
        // 修复移动端编辑时画布内容消失问题
        // 在文本编辑器focus和blur时异步强制刷新画布
        dom.textEditor.addEventListener('focus', () => {
            setTimeout(() => setStateDirty(), 0);
        });
        dom.textEditor.addEventListener('blur', () => {
            // 编辑框失去焦点时，应该调用stopEditing来清理编辑状态
            stopEditing();
            setTimeout(() => setStateDirty(), 0);
        });
        
        dom.saveBtn.addEventListener('click', directSave);
        dom.saveAsBtn.addEventListener('click', saveAs);
        
        // 自动保存开关事件监听器
        dom.autoSaveToggleBtn.addEventListener('click', toggleAutoSave);
        
        // 实时备份开关事件监听器
        dom.realtimeBackupToggleBtn.addEventListener('click', toggleRealtimeBackup);
        async function loadFileWithPicker() {
            // 防止重复调用文件选择器
            if (isFilePickerActive) {
                return;
            }
            
            isFilePickerActive = true;
            
            try {
                const [handle] = await window.showOpenFilePicker({
                    types: [
                        { description: 'JSON Files', accept: { 'application/json': ['.json'] } }
                    ],
                    multiple: false
                });
                
                // 读取文件内容
                const file = await handle.getFile();
                const fileContent = await file.text();
                
                // 处理文件内容，复用loadCanvas的逻辑
                await processLoadedFileContent(fileContent, handle);
                
                // 显示加载成功提示
                showToast('文件加载成功', 'success', 1500);
            } catch (err) {
                console.warn('文件加载失败', err);
            } finally {
                // 无论成功失败，都重置状态标志
                setTimeout(() => {
                    isFilePickerActive = false;
                }, 300); // 添加小延迟，确保操作完全完成
            }
        }
        
        // 处理加载的文件内容
        async function processLoadedFileContent(fileContent, fileHandle = null) {
            try {
                // 首先检查文件内容是否为Markdown格式
                if (isImportableContent(fileContent)) {
                    // 检测到Markdown内容
                    
                    // 尝试解析为JSON
                    let jsonData = null;
                    try {
                        jsonData = JSON.parse(fileContent);
                    } catch (jsonError) {
                        // JSON解析失败，说明是纯Markdown内容
                        showUnifiedMarkdownImportConfirmation(fileContent, {
                            type: 'load'
                        }).then(choice => {
                            handleUnifiedMarkdownImportChoice(fileContent, choice, {
                                type: 'load'
                            });
                        });
                        return;
                    }
                    
                    // JSON解析成功，检查是否为层级结构
                    if (isHierarchicalJSON(jsonData)) {
                        showUnifiedMarkdownImportConfirmation(fileContent, {
                            type: 'load',
                            isJsonFile: true,
                            jsonData: jsonData,
                            fileHandle: fileHandle
                        }).then(choice => {
                            if (choice === 'mindmap') {
                                try {
                                    clearCanvas();
                                    const parsedItems = parseJsonStructure(jsonData);
                                    const result = generateNodesFromMarkdown(parsedItems, { x: 100, y: 100 });
                                    
                                    if (result) {
                                        state.nodes = result.nodes;
                                        state.groups = result.groups;
                                        saveState('JSON-MD加载');
                                        updateCanvasCountInfo();
                                        updateCanvasSelectionInfo();
                                        setStateDirty();
                                        // 显示加载成功提示
                                        showToast('文件加载成功', 'success', 1500);
                                        
                                        // 设置当前打开的文件句柄和文件名
                                        if (fileHandle) {
                                            currentFileHandle = fileHandle;
                                            currentOpenedFileName = fileHandle.name;
                                        }
                                    }
                                } catch (error) {
                                    alert('加载失败：' + (error.message || '未知错误'));
                                }
                            } else if (choice === 'text') {
                                try {
                                    // 使用deserializeNode处理每个导入的节点
                                    state.nodes = (jsonData.nodes || []).map(nodeData => deserializeNode(nodeData));
                                    state.groups = jsonData.groups || [];
                                    state.magneticGroups = (jsonData.magneticGroups || []).map(clusterArray => new Set(clusterArray));
                                    state.view = jsonData.view || { panX: 0, panY: 0, zoom: 1 };
                                    
                                    // 设置画布名称和文件句柄
                                    if (fileHandle) {
                                        dom.canvasNameInput.value = fileHandle.name.replace(/\.json$/i, '');
                                        currentFileHandle = fileHandle;
                                        currentOpenedFileName = fileHandle.name;
                                    }
                                    
                                    saveState('加载项目');
                                    focusOnSelection();
                                    updateCanvasCountInfo();
                                    updateCanvasSelectionInfo();
                                    setStateDirty();
                                    // 显示加载成功提示
                                    showToast('文件加载成功', 'success', 1500);
                                } catch (error) {
                                    alert('加载失败：' + (error.message || '未知错误'));
                                }
                            }
                        });
                        return;
                    }
                }
                
                // 尝试作为标准JSON画布文件加载
                const data = JSON.parse(fileContent);
                
                // 使用deserializeNode处理每个导入的节点
                state.nodes = (data.nodes || []).map(nodeData => deserializeNode(nodeData));
                state.groups = data.groups || [];
                state.magneticGroups = (data.magneticGroups || []).map(clusterArray => new Set(clusterArray));
                state.view = data.view || { panX: 0, panY: 0, zoom: 1 };
                
                // 设置画布名称和文件句柄
                if (fileHandle) {
                    dom.canvasNameInput.value = fileHandle.name.replace(/\.json$/i, '');
                    currentFileHandle = fileHandle;
                    currentOpenedFileName = fileHandle.name;
                }
                
                saveState('加载项目');
                focusOnSelection();
                updateCanvasCountInfo();
                updateCanvasSelectionInfo();
                setStateDirty();
            } catch (parseError) {
                // JSON解析失败，检查是否为Markdown内容
                if (isImportableContent(fileContent)) {
                    showUnifiedMarkdownImportConfirmation(fileContent, {
                        type: 'load'
                    }).then(choice => {
                        handleUnifiedMarkdownImportChoice(fileContent, choice, {
                            type: 'load'
                        });
                    });
                } else {
                    alert('加载失败：无效的JSON文件');
                }
            }
        }
        
        // 修改加载按钮事件处理
        dom.loadBtn.addEventListener('click', async () => {
            // 检查浏览器是否支持File System Access API
            if (supportsFileSystemAccess) {
                // 检查画布是否为空（没有节点和组）
                if (state.nodes.length === 0 && state.groups.length === 0) {
                    // 画布为空，直接打开文件选择器
                    await loadFileWithPicker();
                } else {
                    // 画布有内容，弹出确认对话框
                    showConfirmationModal("加载新项目将覆盖当前内容，确定吗?", async () => {
                        await loadFileWithPicker();
                    });
                }
            } else {
                // 不支持File System Access API时使用传统方式
                if (state.nodes.length === 0 && state.groups.length === 0) {
                    dom.fileInput.click();
                } else {
                    showConfirmationModal("加载新项目将覆盖当前内容，确定吗?", () => dom.fileInput.click());
                }
            }
        });
        dom.mdConvertBtn.addEventListener('click', convertMarkdownToNodes);
        
        // MD导入弹窗事件监听器
        dom.mdConvertModalCloseBtn.addEventListener('click', hideMdConvertModal);
        dom.mdConvertCancelBtn.addEventListener('click', hideMdConvertModal);
        dom.mdConvertConfirmBtn.addEventListener('click', processMdConversion);
        
        // 点击背景关闭弹窗
        dom.mdConvertModalBackdrop.addEventListener('click', (e) => {
            if (e.target === dom.mdConvertModalBackdrop) {
                hideMdConvertModal();
            }
        });
        
        // ESC键关闭弹窗
        dom.mdConvertModal.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                hideMdConvertModal();
            }
        });
        
        // 为MD导入文本输入区域添加专门的事件处理
        dom.mdInputTextarea.addEventListener('paste', (e) => {
            // 阻止事件冒泡到背景画布
            e.stopPropagation();
            // 允许默认的粘贴行为
        });
        
        dom.mdInputTextarea.addEventListener('keydown', (e) => {
            // 阻止事件冒泡到背景画布
            e.stopPropagation();
            
            // 处理特殊键盘事件
            if (e.key === 'Escape') {
                hideMdConvertModal();
            } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                // Ctrl+Enter 或 Cmd+Enter 执行转换
                processMdConversion();
            }
            // 其他键盘事件允许默认行为
        });
        
        dom.clearBtn.addEventListener('click', () => {
            showConfirmationModal("确定要清空整个画布吗? 此操作无法撤销。", () => clearCanvas());
        });
        dom.helpBtn.addEventListener('click', () => showHelpModal(false));
        dom.helpModalCloseBtn.addEventListener('click', hideHelpModal);
        if (dom.helpPageCloseBtn) {
            dom.helpPageCloseBtn.addEventListener('click', hideHelpModal);
        }
        
        // Focus button event listener
        dom.focusBtn.addEventListener('click', (e) => {
            // 如果正在编辑节点，先退出编辑状态
            if (state.editingItem) {
                stopEditing();
            }
            // 然后执行聚焦功能
            focusOnSelection();
        });
        
        // Ensure help modal OK button is properly bound
        const helpOkBtn = document.getElementById('help-modal-ok-btn');
        if (helpOkBtn) {
            helpOkBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                hideHelpModal();
            });
        }
        


        
        // History snapshot modal events (removed - using new modal system)

        dom.mergeBtn.addEventListener('click', () => dom.mergeFileInput.click());
        dom.mergeFileInput.addEventListener('change', (e) => mergeFromFile(e.target.files[0]));
        dom.exportModuleBtn.addEventListener('click', exportModule);
        
        // Setup shortcut configuration
        setupShortcutConfiguration();
        
        // Setup history panel
        setupHistoryPanel();
        setupNewHistoryModal();


        dom.fileInput.addEventListener('change', loadCanvas);
        
        setupColorPickers();
        setupShortcutInputs();

        document.querySelectorAll('.context-menu-item').forEach(item => {
            item.addEventListener('click', async (e) => {
                // Handle submenu items and regular items
                if (item.dataset.action) {
                    e.stopPropagation();
                    await handleContextMenuItemClick(item.dataset.action);
                    // Close all context menus after action
                    document.querySelectorAll('.context-menu').forEach(menu => {
                        menu.style.display = 'none';
                    });
                } else if (item.classList.contains('has-submenu')) {
                    // For items with submenu, don't close the menu
                    e.stopPropagation();
                    
                    // 移动端处理：一次点击直接显示子菜单
                    if (isMobile()) {
                        const submenu = item.querySelector('.submenu');
                        if (submenu) {
                            // 切换子菜单显示状态
                            const isVisible = submenu.style.display === 'block';
                            
                            // 先隐藏所有其他子菜单
                            document.querySelectorAll('.context-menu .submenu').forEach(sub => {
                                if (sub !== submenu) {
                                    sub.style.display = 'none';
                                }
                            });
                            
                            // 切换当前子菜单
                            submenu.style.display = isVisible ? 'none' : 'block';
                            
                            // 移动端子菜单定位优化
                            if (submenu.style.display === 'block') {
                                adjustSubmenuPosition(submenu, item);
                            }
                        }
                    }
                }
            });
            
            // Add mouseenter/mouseleave for better submenu control (PC端)
            if (item.classList.contains('has-submenu') && !isMobile()) {
                const showSubmenu = () => {
                    const submenu = item.querySelector('.submenu');
                    if (submenu) {
                        submenu.style.display = 'block';
                        adjustSubmenuPosition(submenu, item);
                    }
                };
                
                const hideSubmenu = () => {
                    const submenu = item.querySelector('.submenu');
                    if (submenu) {
                        submenu.style.display = 'none';
                    }
                };
                
                // Parent menu item events
                item.addEventListener('mouseenter', showSubmenu);
                item.addEventListener('mouseleave', (e) => {
                    const submenu = item.querySelector('.submenu');
                    // Only hide if mouse is not moving to submenu
                    if (submenu && !submenu.contains(e.relatedTarget) && !item.contains(e.relatedTarget)) {
                        hideSubmenu();
                    }
                });
                
                // Submenu events
                const submenu = item.querySelector('.submenu');
                if (submenu) {
                    submenu.addEventListener('mouseenter', showSubmenu);
                    submenu.addEventListener('mouseleave', (e) => {
                        // Only hide if mouse is not moving back to parent
                        if (!item.contains(e.relatedTarget)) {
                            hideSubmenu();
                        }
                    });
                }
            }
        });
        
        // 移除实时搜索，改为手动触发
        dom.searchBtn.addEventListener('click', () => {
            handleSearch({ target: dom.searchBox });
        });
        
        // 支持回车键搜索
        dom.searchBox.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                handleSearch({ target: dom.searchBox });
            }
        });
        
        dom.searchClearBtn.addEventListener('click', () => {
            dom.searchBox.value = '';
            dom.searchClearBtn.style.display = 'none'; // 隐藏清空按钮
            handleSearch({ target: dom.searchBox }); // 清空搜索结果
        });
        
        // 监听搜索框输入，动态显示/隐藏清空按钮
        dom.searchBox.addEventListener('input', () => {
            if (dom.searchBox.value.trim() !== '') {
                dom.searchClearBtn.style.display = 'block';
            } else {
                dom.searchClearBtn.style.display = 'none';
            }
        });
        dom.searchScopeToggle.addEventListener('click', () => {
            // 切换搜索范围
            state.interaction.searchScope = state.interaction.searchScope === 'current' ? 'global' : 'current';
            
            // 更新按钮文本和样式
            if (state.interaction.searchScope === 'current') {
                dom.searchScopeToggle.textContent = '当前';
                dom.searchScopeToggle.title = '切换搜索范围：当前层级 / 全局搜索';
                dom.searchScopeToggle.classList.remove('global-mode');
            } else {
                dom.searchScopeToggle.textContent = '全局';
                dom.searchScopeToggle.title = '切换搜索范围：全局搜索 / 当前层级';
                dom.searchScopeToggle.classList.add('global-mode');
            }
            
            // 如果有搜索内容，重新执行搜索
            if (dom.searchBox.value.trim() !== '') {
                handleSearch({ target: dom.searchBox });
            }
        });
        
        // 搜索组开关按钮事件监听器
        dom.searchGroupToggle.addEventListener('click', () => {
            // 切换搜索组状态
            state.interaction.searchGroups = !state.interaction.searchGroups;
            
            // 更新按钮样式（使用toggle-btn标准样式）
            dom.searchGroupToggle.classList.toggle('active');
            
            // 如果有搜索内容，重新执行搜索
            if (dom.searchBox.value.trim() !== '') {
                handleSearch({ target: dom.searchBox });
            }
            
            // 搜索组切换调试
        });
        
        dom.searchPrevBtn.addEventListener('click', () => focusOnSearchResult('prev'));
        dom.searchNextBtn.addEventListener('click', () => focusOnSearchResult('next'));
        
        // 搜索框修复：确保能够正常点击和获得焦点
        function fixSearchBoxInteraction() {
            const searchBox = document.getElementById('search-box');
            const searchContainer = document.getElementById('search-container');
            
            if (searchBox && searchContainer) {
                // 强制设置样式
                searchBox.style.pointerEvents = 'auto';
                searchBox.style.zIndex = '1000';
                searchBox.style.position = 'relative';
                searchContainer.style.pointerEvents = 'auto';
                searchContainer.style.overflow = 'visible';
                
                // 添加点击事件确保焦点
                searchBox.addEventListener('click', function(e) {
                    e.stopPropagation();
                    this.focus();
                });
                
                // 添加触摸事件（移动端）
                searchBox.addEventListener('touchstart', function(e) {
                    e.stopPropagation();
                    this.focus();
                }, { passive: true });
                
                // 添加复制粘贴事件处理，阻止事件冒泡
                searchBox.addEventListener('copy', function(e) {
                    e.stopPropagation();
                });
                
                searchBox.addEventListener('cut', function(e) {
                    e.stopPropagation();
                });
                
                searchBox.addEventListener('paste', function(e) {
                    e.stopPropagation();
                });
                
                // 确保文字选择功能正常工作
                searchBox.addEventListener('mousedown', function(e) {
                    // 不阻止默认行为，允许文字选择
                    e.stopPropagation();
                });
                
                searchBox.addEventListener('selectstart', function(e) {
                    // 允许文字选择开始
                    e.stopPropagation();
                });
                
                // 搜索框交互和复制粘贴修复
            }
        }
        
        // 页面加载完成后执行修复
        fixSearchBoxInteraction();
        
        // 延迟执行确保所有样式都已应用
        setTimeout(fixSearchBoxInteraction, 100);
    }

    // Wait for DOM to be fully loaded before initializing
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', async () => {
            await initialize();
        });
    } else {
        // 在顶级作用域中使用立即执行异步函数
        (async function() {
            await initialize();
        })();
    }

}());


</script>

    <!-- 自定义对话框样式 -->
    <style>
        .custom-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .custom-dialog {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            min-width: 300px;
            max-width: 500px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            font-family: Arial, sans-serif;
        }
        
        .custom-dialog-header {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .custom-dialog-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin: 0;
        }
        
        .custom-dialog-content {
            margin-bottom: 20px;
            color: #666;
            line-height: 1.5;
        }
        
        .custom-dialog-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        .custom-dialog-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background-color 0.2s;
        }
        
        .custom-dialog-button:hover {
            opacity: 0.9;
        }
        
        .custom-dialog-button.confirm {
            background-color: #4CAF50;
            color: white;
        }
        
        .custom-dialog-button.cancel {
            background-color: #f5f5f5;
            color: #666;
            border: 1px solid #ddd;
        }
        
        .custom-dialog-button.confirm:hover {
            background-color: #45a049;
        }
        
        .custom-dialog-button.cancel:hover {
            background-color: #e0e0e0;
        }
    </style>
    
    <!-- 自定义对话框HTML结构 -->
    <div id="custom-confirm-dialog" class="custom-dialog-overlay" style="display: none;">
        <div class="custom-dialog">
            <div class="custom-dialog-header">
                <h3 id="confirm-dialog-title" class="custom-dialog-title"></h3>
            </div>
            <div class="custom-dialog-content">
                <p id="confirm-dialog-message"></p>
            </div>
            <div class="custom-dialog-footer">
                <button id="confirm-dialog-cancel" class="custom-dialog-button cancel">取消</button>
                <button id="confirm-dialog-ok" class="custom-dialog-button confirm">确认</button>
            </div>
        </div>
    </div>
    
    <div id="custom-alert-dialog" class="custom-dialog-overlay" style="display: none;">
        <div class="custom-dialog">
            <div class="custom-dialog-header">
                <h3 class="custom-dialog-title">提示</h3>
            </div>
            <div class="custom-dialog-content">
                <p id="alert-dialog-message"></p>
            </div>
            <div class="custom-dialog-footer">
                <button id="alert-dialog-ok" class="custom-dialog-button confirm">确定</button>
            </div>
        </div>
    </div>
    
    <!-- 自定义对话框JavaScript实现 -->
    <script>
        // 显示自定义确认对话框
        function showCustomConfirmDialog(title, message, confirmCallback, cancelCallback) {
            // 存储回调函数
            window._confirmCallback = confirmCallback;
            window._cancelCallback = cancelCallback;
            
            // 设置对话框内容
            document.getElementById('confirm-dialog-title').textContent = title;
            document.getElementById('confirm-dialog-message').textContent = message;
            
            // 显示对话框
            document.getElementById('custom-confirm-dialog').style.display = 'flex';
            
            // 添加事件监听器
            document.getElementById('confirm-dialog-ok').onclick = handleConfirmOk;
            document.getElementById('confirm-dialog-cancel').onclick = handleConfirmCancel;
        }
        
        // 处理确认按钮点击
        function handleConfirmOk() {
            // 隐藏对话框
            document.getElementById('custom-confirm-dialog').style.display = 'none';
            
            // 执行确认回调
            if (typeof window._confirmCallback === 'function') {
                window._confirmCallback();
            }
            
            // 清理回调函数
            window._confirmCallback = null;
            window._cancelCallback = null;
        }
        
        // 处理取消按钮点击
        function handleConfirmCancel() {
            // 隐藏对话框
            document.getElementById('custom-confirm-dialog').style.display = 'none';
            
            // 执行取消回调
            if (typeof window._cancelCallback === 'function') {
                window._cancelCallback();
            }
            
            // 清理回调函数
            window._confirmCallback = null;
            window._cancelCallback = null;
        }
        
        // 显示自定义提示对话框
        function showCustomAlert(message) {
            // 设置对话框内容
            document.getElementById('alert-dialog-message').textContent = message;
            
            // 显示对话框
            document.getElementById('custom-alert-dialog').style.display = 'flex';
            
            // 添加事件监听器
            document.getElementById('alert-dialog-ok').onclick = handleAlertOk;
        }
        
        // 处理提示对话框确认按钮点击
        function handleAlertOk() {
            // 隐藏对话框
            document.getElementById('custom-alert-dialog').style.display = 'none';
        }
        
        // 允许按ESC键关闭对话框
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const confirmDialog = document.getElementById('custom-confirm-dialog');
                const alertDialog = document.getElementById('custom-alert-dialog');
                
                if (confirmDialog.style.display === 'flex') {
                    handleConfirmCancel();
                } else if (alertDialog.style.display === 'flex') {
                    handleAlertOk();
                }
            }
        });
    </script>
</body>
</html>
